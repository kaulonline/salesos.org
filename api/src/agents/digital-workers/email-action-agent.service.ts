/**
 * IRIS Digital Worker Agent - Email Action Agent
 *
 * Drafts and sends personalized emails based on signals:
 * - Generates contextual email content using AI
 * - Personalizes based on contact and account data
 * - Supports follow-up, introduction, and outreach emails
 * - Requires approval before sending
 */

import { Injectable, Logger } from '@nestjs/common';
import { EventEmitter2 } from '@nestjs/event-emitter';
import { PrismaService } from '../../database/prisma.service';
import { AiSdkService } from '../../ai-sdk/ai-sdk.service';
import { CacheService } from '../../cache/cache.service';
import { BaseAgentService, DEFAULT_AGENT_LIMITS } from '../base/base-agent.service';
import { createCRMTools } from '../tools/crm-tools';
import {
  AgentType,
  AgentContext,
  AgentConfig,
  AgentTool,
  InsightType,
  ActionType,
  Priority,
  CRMEntityType,
} from '../types';

/**
 * Email draft generated by LLM
 */
interface EmailDraft {
  subject: string;
  body: string;
  tone: string;
  callToAction: string;
  personalizationUsed: string[];
}

interface EmailGenerationResult {
  draft: EmailDraft;
  alternativeSubjects: string[];
  sendingTips: string[];
}

@Injectable()
export class EmailActionAgentService extends BaseAgentService {
  protected readonly agentType = AgentType.EMAIL_ACTION;
  protected readonly logger = new Logger(EmailActionAgentService.name);

  protected readonly config: AgentConfig = {
    type: AgentType.EMAIL_ACTION,
    name: 'Email Action Agent',
    description: 'Drafts and sends emails based on signals',
    version: '1.0.0',

    // Manual only - triggered by user or other agents
    schedule: {
      enabled: false,
    },

    eventTriggers: [
      { eventName: 'signal.recommendation.ready' },
    ],

    limits: {
      ...DEFAULT_AGENT_LIMITS,
      maxLLMCalls: 5,
      maxActionsPerExecution: 5,
    },

    enabled: true,
    requiresApproval: true, // Always require approval before sending
  };

  constructor(
    prisma: PrismaService,
    aiSdk: AiSdkService,
    eventEmitter: EventEmitter2,
    cacheService: CacheService,
  ) {
    super();
    this.initializeBase(prisma, aiSdk, eventEmitter, cacheService);
  }

  protected getTools(): AgentTool[] {
    return createCRMTools(this.prisma);
  }

  protected async executeAgent(context: AgentContext): Promise<void> {
    this.logger.log('Starting Email Action Agent - drafting email...');

    // Get email request from context metadata
    const emailRequest = context.metadata as {
      contactId?: string;
      accountId?: string;
      signalId?: string;
      emailType?: 'FOLLOW_UP' | 'INTRODUCTION' | 'OUTREACH' | 'THANK_YOU' | 'CUSTOM';
      talkingPoints?: string[];
      customInstructions?: string;
    };

    if (!emailRequest.contactId && !emailRequest.accountId) {
      this.addInsight({
        type: InsightType.INFORMATION,
        priority: Priority.LOW,
        confidence: 1,
        title: 'Missing Recipient',
        description: 'Email Action Agent requires a contactId or accountId',
      });
      return;
    }

    // Gather recipient and context information
    const emailContext = await this.gatherEmailContext(emailRequest, context);

    if (!emailContext.recipientEmail) {
      this.addInsight({
        type: InsightType.INFORMATION,
        priority: Priority.MEDIUM,
        confidence: 1,
        title: 'No Email Address',
        description: `Could not find email address for the specified recipient`,
      });
      return;
    }

    // Generate email draft
    const emailResult = await this.generateEmail(emailRequest, emailContext, context);

    // Queue the email action for approval
    this.queueAction({
      actionType: ActionType.SEND_EMAIL,
      priority: Priority.MEDIUM,
      description: `Send ${emailRequest.emailType || 'CUSTOM'} email to ${emailContext.recipientName}`,
      params: {
        to: emailContext.recipientEmail,
        recipientName: emailContext.recipientName,
        subject: emailResult.draft.subject,
        body: emailResult.draft.body,
        contactId: emailRequest.contactId,
        accountId: emailRequest.accountId,
        signalId: emailRequest.signalId,
        alternativeSubjects: emailResult.alternativeSubjects,
      },
      entityType: emailRequest.contactId ? CRMEntityType.CONTACT : CRMEntityType.ACCOUNT,
      entityId: emailRequest.contactId || emailRequest.accountId!,
      requiresApproval: true,
    });

    // Add insight with the draft
    this.addInsight({
      type: InsightType.INFORMATION,
      priority: Priority.MEDIUM,
      confidence: 0.9,
      title: 'Email Draft Ready',
      description: `Generated ${emailRequest.emailType || 'custom'} email for ${emailContext.recipientName}`,
      entityType: emailRequest.contactId ? CRMEntityType.CONTACT : CRMEntityType.ACCOUNT,
      entityId: emailRequest.contactId || emailRequest.accountId,
      metadata: {
        draft: emailResult.draft,
        tips: emailResult.sendingTips,
      },
    });

    // Emit event for UI to show draft
    this.eventEmitter.emit('email.draft.ready', {
      draft: emailResult.draft,
      recipient: {
        email: emailContext.recipientEmail,
        name: emailContext.recipientName,
      },
      alternatives: emailResult.alternativeSubjects,
      tips: emailResult.sendingTips,
      userId: context.userId,
    });
  }

  private async gatherEmailContext(emailRequest: any, context: AgentContext): Promise<any> {
    const result: any = {
      recipientEmail: null,
      recipientName: null,
      recipientTitle: null,
      companyName: null,
      opportunities: [],
      recentActivities: [],
      signal: null,
    };

    // Get contact information
    if (emailRequest.contactId) {
      const contact = await this.prisma.contact.findUnique({
        where: { id: emailRequest.contactId },
        include: { account: true },
      });

      if (contact) {
        result.recipientEmail = contact.email;
        result.recipientName = `${contact.firstName} ${contact.lastName}`;
        result.recipientTitle = contact.title;
        result.companyName = contact.account?.name;
        result.accountId = contact.accountId;
      }
    }

    // Get account information if no contact
    if (!result.recipientEmail && emailRequest.accountId) {
      const account = await this.prisma.account.findUnique({
        where: { id: emailRequest.accountId },
        include: {
          contacts: {
            take: 1,
            orderBy: { createdAt: 'desc' },
          },
        },
      });

      if (account && account.contacts.length > 0) {
        const contact = account.contacts[0];
        result.recipientEmail = contact.email;
        result.recipientName = `${contact.firstName} ${contact.lastName}`;
        result.recipientTitle = contact.title;
        result.companyName = account.name;
      }
    }

    // Get opportunities
    if (result.accountId || emailRequest.accountId) {
      const accountId = result.accountId || emailRequest.accountId;
      result.opportunities = await this.prisma.opportunity.findMany({
        where: {
          accountId,
          stage: { notIn: ['CLOSED_WON', 'CLOSED_LOST'] },
        },
        take: 3,
      });
    }

    // Get recent activities
    if (emailRequest.contactId || emailRequest.accountId) {
      result.recentActivities = await this.prisma.activity.findMany({
        where: {
          OR: [
            { contactId: emailRequest.contactId },
            { accountId: emailRequest.accountId },
          ],
        },
        take: 5,
        orderBy: { createdAt: 'desc' },
      });
    }

    // Get signal if referenced
    if (emailRequest.signalId) {
      result.signal = await this.prisma.accountSignal.findUnique({
        where: { id: emailRequest.signalId },
      });
    }

    return result;
  }

  private async generateEmail(emailRequest: any, emailContext: any, context: AgentContext): Promise<EmailGenerationResult> {
    const emailType = emailRequest.emailType || 'CUSTOM';
    const talkingPoints = emailRequest.talkingPoints || [];

    // Build context string
    const contextInfo: string[] = [];

    if (emailContext.signal) {
      contextInfo.push(`SIGNAL: ${emailContext.signal.type} - ${emailContext.signal.title}`);
      contextInfo.push(`Signal Details: ${emailContext.signal.description}`);
    }

    if (emailContext.opportunities.length > 0) {
      contextInfo.push('\nOPEN OPPORTUNITIES:');
      emailContext.opportunities.forEach((o: any) => {
        contextInfo.push(`- ${o.name}: $${o.amount || 0} (${o.stage})`);
      });
    }

    if (emailContext.recentActivities.length > 0) {
      contextInfo.push('\nRECENT INTERACTIONS:');
      emailContext.recentActivities.forEach((a: any) => {
        contextInfo.push(`- ${a.type}: ${a.subject} (${a.createdAt.toLocaleDateString()})`);
      });
    }

    if (talkingPoints.length > 0) {
      contextInfo.push('\nKEY TALKING POINTS:');
      talkingPoints.forEach((p: string) => contextInfo.push(`- ${p}`));
    }

    const prompt = `Generate a professional sales email based on the following context.

EMAIL TYPE: ${emailType}
RECIPIENT: ${emailContext.recipientName}
TITLE: ${emailContext.recipientTitle || 'Professional'}
COMPANY: ${emailContext.companyName || 'their company'}

${contextInfo.join('\n')}

${emailRequest.customInstructions ? `CUSTOM INSTRUCTIONS: ${emailRequest.customInstructions}` : ''}

Create a personalized, professional email that:
1. Has a compelling subject line
2. Addresses the recipient by name
3. References relevant context (signals, opportunities, past interactions)
4. Has a clear call to action
5. Is concise and easy to read

Return JSON:
{
  "draft": {
    "subject": "Email subject line",
    "body": "Full email body with greeting and signature placeholder",
    "tone": "professional/friendly/urgent",
    "callToAction": "What you want them to do",
    "personalizationUsed": ["Element 1", "Element 2"]
  },
  "alternativeSubjects": ["Alt subject 1", "Alt subject 2"],
  "sendingTips": ["Tip 1", "Tip 2"]
}`;

    const systemPrompt = `You are an expert sales email writer. Create emails that are personalized, professional, and effective. Focus on value to the recipient and clear calls to action. Keep emails concise - busy executives appreciate brevity.`;

    try {
      return await this.callLLMForJSON<EmailGenerationResult>(prompt, systemPrompt);
    } catch (error) {
      // Return a basic template
      return {
        draft: {
          subject: `Following up - ${emailContext.companyName || 'our conversation'}`,
          body: `Hi ${emailContext.recipientName?.split(' ')[0] || 'there'},\n\nI wanted to follow up regarding our recent conversation.\n\n${talkingPoints.length > 0 ? talkingPoints.join('\n') : 'I would love to discuss how we can help.'}\n\nWould you have time for a brief call this week?\n\nBest regards,\n[Your name]`,
          tone: 'professional',
          callToAction: 'Schedule a call',
          personalizationUsed: ['Recipient name'],
        },
        alternativeSubjects: ['Quick follow-up', 'Checking in'],
        sendingTips: ['Send in the morning for better open rates'],
      };
    }
  }
}
