/**
 * IRIS Agent Framework - Type Definitions
 * 
 * This file contains all shared types for the agent framework.
 * These types are designed to be extensible for future agent implementations.
 */

import { z } from 'zod';

// ==================== AGENT IDENTIFICATION ====================

/**
 * Unique identifier for agent types.
 * Add new agent types here as they are created.
 */
export enum AgentType {
  // Sales Intelligence Agents
  DEAL_HEALTH = 'DEAL_HEALTH',
  PIPELINE_ACCELERATION = 'PIPELINE_ACCELERATION',
  ACCOUNT_INTELLIGENCE = 'ACCOUNT_INTELLIGENCE',
  
  // Engagement Agents
  OUTREACH_OPTIMIZATION = 'OUTREACH_OPTIMIZATION',
  MEETING_PREP = 'MEETING_PREP',
  
  // Performance Agents
  COACHING = 'COACHING',
  COMPETITIVE_INTELLIGENCE = 'COMPETITIVE_INTELLIGENCE',

  // Vertiv MVP Agents
  NEXT_BEST_ACTION = 'NEXT_BEST_ACTION',
  WIN_CYCLE_ANALYZER = 'WIN_CYCLE_ANALYZER',

  // Utility Agents
  DATA_ENRICHMENT = 'DATA_ENRICHMENT',
  WORKFLOW_AUTOMATION = 'WORKFLOW_AUTOMATION',

  // Digital Worker Agents (Admin Panel)
  LISTENING = 'LISTENING',
  REASONING = 'REASONING',
  LEARN_MORE = 'LEARN_MORE',
  EMAIL_ACTION = 'EMAIL_ACTION',
  CRM_ACTION = 'CRM_ACTION',
  MEETING_ACTION = 'MEETING_ACTION',
}

/**
 * What triggered the agent execution
 */
export enum AgentTrigger {
  SCHEDULED = 'SCHEDULED',      // Cron job / scheduled task
  EVENT = 'EVENT',              // System event (e.g., deal stage change)
  USER_REQUEST = 'USER_REQUEST', // Direct user invocation
  AGENT_CHAIN = 'AGENT_CHAIN',  // Another agent triggered this one
  WEBHOOK = 'WEBHOOK',          // External webhook trigger
}

/**
 * Agent execution status
 */
export enum AgentStatus {
  PENDING = 'PENDING',
  RUNNING = 'RUNNING',
  COMPLETED = 'COMPLETED',
  FAILED = 'FAILED',
  CANCELLED = 'CANCELLED',
  RATE_LIMITED = 'RATE_LIMITED',
}

// ==================== AGENT CONTEXT ====================

/**
 * Context passed to agent execution.
 * Contains all information needed for the agent to operate.
 */
export interface AgentContext {
  // Execution context
  executionId: string;
  trigger: AgentTrigger;
  triggeredBy?: string; // User ID or Agent ID that triggered
  
  // Target entity (optional - some agents operate globally)
  entityType?: CRMEntityType;
  entityId?: string;
  
  // User context
  userId?: string;
  userRole?: string;
  
  // Scope control
  scope?: AgentScope;
  
  // Additional metadata
  metadata?: Record<string, unknown>;
  
  // Parent context for chained agents
  parentExecutionId?: string;
  
  // Timing
  startedAt: Date;
  timeoutMs?: number;
}

/**
 * CRM entity types that agents can operate on
 */
export enum CRMEntityType {
  LEAD = 'Lead',
  ACCOUNT = 'Account',
  CONTACT = 'Contact',
  OPPORTUNITY = 'Opportunity',
  TASK = 'Task',
  ACTIVITY = 'Activity',
  MEETING = 'Meeting',
  EMAIL_THREAD = 'EmailThread',
  CAMPAIGN = 'Campaign',
  QUOTE = 'Quote',
  CONTRACT = 'Contract',
}

/**
 * Scope control for agent execution
 */
export interface AgentScope {
  // Limit to specific users
  userIds?: string[];
  
  // Limit to specific accounts
  accountIds?: string[];
  
  // Time range for analysis
  fromDate?: Date;
  toDate?: Date;
  
  // Maximum entities to process
  maxEntities?: number;
  
  // Custom filters
  filters?: Record<string, unknown>;
}

// ==================== AGENT RESULTS ====================

/**
 * Result returned from agent execution
 */
export interface AgentResult {
  success: boolean;
  status: AgentStatus;
  
  // Execution metrics
  executionTimeMs: number;
  llmCallsCount: number;
  tokensUsed: {
    input: number;
    output: number;
    total: number;
  };
  
  // Outputs
  insights: AgentInsight[];
  alerts: AgentAlert[];
  actions: AgentAction[];
  
  // For chained agents
  chainedAgents?: ChainedAgentRequest[];
  
  // Errors (if any)
  errors?: AgentError[];
  
  // Raw data for debugging
  debugData?: Record<string, unknown>;
}

/**
 * An insight generated by an agent
 */
export interface AgentInsight {
  id: string;
  type: InsightType;
  priority: Priority;
  confidence: number; // 0-1
  
  title: string;
  description: string;
  recommendation?: string;
  
  // Related entity
  entityType?: CRMEntityType;
  entityId?: string;
  
  // Evidence supporting this insight
  evidence?: InsightEvidence[];
  
  // Metadata
  metadata?: Record<string, unknown>;
  createdAt: Date;
}

export enum InsightType {
  // Risk insights
  RISK_DETECTED = 'RISK_DETECTED',
  STALL_WARNING = 'STALL_WARNING',
  CHURN_SIGNAL = 'CHURN_SIGNAL',
  
  // Opportunity insights
  EXPANSION_OPPORTUNITY = 'EXPANSION_OPPORTUNITY',
  BUYING_SIGNAL = 'BUYING_SIGNAL',
  UPSELL_POTENTIAL = 'UPSELL_POTENTIAL',
  
  // Action insights
  FOLLOW_UP_NEEDED = 'FOLLOW_UP_NEEDED',
  ENGAGEMENT_DROP = 'ENGAGEMENT_DROP',
  CHAMPION_CHANGE = 'CHAMPION_CHANGE',
  
  // Competitive insights
  COMPETITOR_MENTIONED = 'COMPETITOR_MENTIONED',
  COMPETITIVE_THREAT = 'COMPETITIVE_THREAT',
  
  // Performance insights
  SKILL_GAP = 'SKILL_GAP',
  BEST_PRACTICE = 'BEST_PRACTICE',
  
  // General
  INFORMATION = 'INFORMATION',
  ANOMALY = 'ANOMALY',
}

export interface InsightEvidence {
  source: string; // e.g., "Meeting Transcript", "Email Thread", "Activity History"
  sourceId?: string;
  excerpt?: string;
  timestamp?: Date;
}

/**
 * An alert generated by an agent (user-facing notification)
 */
export interface AgentAlert {
  id: string;
  agentType: AgentType;
  alertType: AlertType;
  priority: Priority;
  
  title: string;
  description: string;
  recommendation?: string;
  
  // Target user
  userId: string;
  
  // Related entity
  entityType: CRMEntityType;
  entityId: string;
  
  // Lifecycle
  status: AlertStatus;
  expiresAt?: Date;
  
  // Actions user can take
  suggestedActions?: SuggestedAction[];
  
  metadata?: Record<string, unknown>;
  createdAt: Date;
}

export enum AlertType {
  // Urgency levels
  URGENT_ACTION = 'URGENT_ACTION',
  ATTENTION_NEEDED = 'ATTENTION_NEEDED',
  FYI = 'FYI',
  
  // Categories
  DEAL_AT_RISK = 'DEAL_AT_RISK',
  DEAL_STALLED = 'DEAL_STALLED',
  OPPORTUNITY_DETECTED = 'OPPORTUNITY_DETECTED',
  FOLLOW_UP_OVERDUE = 'FOLLOW_UP_OVERDUE',
  MEETING_PREP = 'MEETING_PREP',
  COACHING_TIP = 'COACHING_TIP',

  // Vertiv MVP Alert Types
  NEXT_BEST_ACTION = 'NEXT_BEST_ACTION',
  COACHING_INSIGHT = 'COACHING_INSIGHT',
  ACCOUNTABILITY_CHECK = 'ACCOUNTABILITY_CHECK',
}

export enum AlertStatus {
  PENDING = 'PENDING',
  ACKNOWLEDGED = 'ACKNOWLEDGED',
  ACTIONED = 'ACTIONED',
  DISMISSED = 'DISMISSED',
  EXPIRED = 'EXPIRED',
}

export interface SuggestedAction {
  label: string;
  actionType: ActionType;
  params?: Record<string, unknown>;
}

/**
 * An action that an agent wants to execute
 */
export interface AgentAction {
  id: string;
  actionType: ActionType;
  priority: Priority;
  
  // What to do
  description: string;
  params: Record<string, unknown>;
  
  // Target
  entityType?: CRMEntityType;
  entityId?: string;
  
  // Approval
  requiresApproval: boolean;
  approvedBy?: string;
  approvedAt?: Date;
  
  // Execution
  status: ActionStatus;
  executedAt?: Date;
  result?: unknown;
  error?: string;
}

export enum ActionType {
  // CRM actions
  CREATE_TASK = 'CREATE_TASK',
  UPDATE_OPPORTUNITY = 'UPDATE_OPPORTUNITY',
  UPDATE_LEAD = 'UPDATE_LEAD',
  LOG_ACTIVITY = 'LOG_ACTIVITY',
  CREATE_NOTE = 'CREATE_NOTE',
  
  // Communication actions
  SEND_EMAIL = 'SEND_EMAIL',
  DRAFT_EMAIL = 'DRAFT_EMAIL',
  SCHEDULE_MEETING = 'SCHEDULE_MEETING',
  
  // Notification actions
  SEND_ALERT = 'SEND_ALERT',
  SEND_NOTIFICATION = 'SEND_NOTIFICATION',
  
  // Chain actions
  TRIGGER_AGENT = 'TRIGGER_AGENT',
  
  // Custom
  CUSTOM = 'CUSTOM',
}

export enum ActionStatus {
  PENDING_APPROVAL = 'PENDING_APPROVAL',
  APPROVED = 'APPROVED',
  REJECTED = 'REJECTED',
  EXECUTING = 'EXECUTING',
  COMPLETED = 'COMPLETED',
  FAILED = 'FAILED',
}

export enum Priority {
  LOW = 'LOW',
  MEDIUM = 'MEDIUM',
  HIGH = 'HIGH',
  URGENT = 'URGENT',
}

/**
 * Request to chain another agent
 */
export interface ChainedAgentRequest {
  agentType: AgentType;
  context: Partial<AgentContext>;
  delay?: number; // ms to wait before triggering
  condition?: string; // Optional condition expression
}

/**
 * Agent error structure
 */
export interface AgentError {
  code: string;
  message: string;
  details?: unknown;
  recoverable: boolean;
  timestamp: Date;
}

// ==================== AGENT CONFIGURATION ====================

/**
 * Configuration for an agent
 */
export interface AgentConfig {
  // Identity
  type: AgentType;
  name: string;
  description: string;
  version: string;
  
  // Scheduling
  schedule?: AgentSchedule;
  
  // Event triggers
  eventTriggers?: EventTriggerConfig[];
  
  // Execution limits
  limits: AgentLimits;
  
  // Feature flags
  enabled: boolean;
  requiresApproval: boolean;
  
  // Tools this agent can use
  tools?: string[];
  
  // Custom config
  customConfig?: Record<string, unknown>;
}

export interface AgentSchedule {
  cron?: string; // Cron expression
  interval?: number; // Interval in ms
  timezone?: string;
  enabled: boolean;
}

export interface EventTriggerConfig {
  eventName: string;
  filter?: Record<string, unknown>;
  debounceMs?: number;
}

export interface AgentLimits {
  maxExecutionTimeMs: number;
  maxLLMCalls: number;
  maxTokensPerExecution: number;
  maxAlertsPerExecution: number;
  maxActionsPerExecution: number;
  rateLimitPerHour: number;
  rateLimitPerDay: number;
}

// ==================== TOOL DEFINITIONS ====================

/**
 * Tool definition for agents (compatible with Vercel AI SDK)
 */
export interface AgentTool<TParams = unknown, TResult = unknown> {
  name: string;
  description: string;
  parameters: z.ZodSchema<TParams>;
  execute: (params: TParams, context: AgentContext) => Promise<TResult>;
}

/**
 * Tool execution result
 */
export interface ToolResult<T = unknown> {
  success: boolean;
  data?: T;
  error?: string;
  executionTimeMs: number;
}

// ==================== AGENT REGISTRY ====================

/**
 * Metadata for registered agents
 */
export interface RegisteredAgent {
  type: AgentType;
  config: AgentConfig;
  instance: unknown; // The actual agent service instance
  registeredAt: Date;
  lastExecutedAt?: Date;
  executionCount: number;
  errorCount: number;
}

// ==================== UTILITY TYPES ====================

/**
 * Deep partial type for configuration overrides
 */
export type DeepPartial<T> = {
  [P in keyof T]?: T[P] extends object ? DeepPartial<T[P]> : T[P];
};

/**
 * Generate unique ID
 */
export const generateId = (): string => {
  return `${Date.now()}-${Math.random().toString(36).substr(2, 9)}`;
};












