import { Injectable, NotFoundException, Logger } from '@nestjs/common';
import type { Response } from 'express';
import { PrismaService } from '../database/prisma.service';
import { AnthropicService } from '../anthropic/anthropic.service';
import { AiSdkService } from '../ai-sdk/ai-sdk.service';
import { ToolRouterService, TOOL_CLUSTERS } from '../ai-sdk/tool-router.service';
import { LLMCompilerService } from '../ai-sdk/llm-compiler.service';
import { ToolEmbeddingsService } from '../ai-sdk/tool-embeddings.service';
import { QueryRouterService, RoutingDecision } from '../ai-sdk/query-router.service';
import { IrisOptimizerService } from '../ai-sdk/iris-optimizer.service';
import { IRISRankService, CRMEntity, EntityActivity, RankingContext } from '../ai-sdk/iris-rank.service';
import { SpeculativeCascadeService } from '../ai-sdk/speculative-cascade.service';
import { LocalSLMService } from '../ai-sdk/local-slm.service';
import { LeadsService } from '../leads/leads.service';
import { OpportunitiesService } from '../opportunities/opportunities.service';
import { AccountsService } from '../accounts/accounts.service';
import { SearchService } from '../search/search.service';
import { FinancialDataService, FinancialData } from '../search/financial-data.service';
import { PageIndexService } from '../pageindex/pageindex.service';
import { FeedbackService } from '../feedback/feedback.service';
import { MeetingsService } from '../meetings/meetings.service';
import { EmailService } from '../email/email.service';
import { EmailTrackingService } from '../email-tracking/email-tracking.service';
import { QuotesService } from '../quotes/quotes.service';
import { ContractsService } from '../contracts/contracts.service';
import { CampaignsService } from '../campaigns/campaigns.service';
import { NotesService } from '../notes/notes.service';
import { TasksService } from '../tasks/tasks.service';
import { SalesforceService } from '../salesforce/salesforce.service';
import { OracleCXService } from '../oracle-cx/oracle-cx.service';
import { SmartDataAnalyzerService } from './smart-data-analyzer.service';
import { AnalyticsService } from './analytics.service';
import { UsageTrackingService } from '../admin/usage-tracking.service';
import { SignalsService } from '../digital-workers/signals/signals.service';
import { IdValidator, determineOperationTarget } from '../common/validators/id.validator';
import { getUserFriendlyErrorMessage, ERROR_MESSAGES } from '../common/error-messages.constant';
import { ResponseGroundingService, GroundingResult } from '../common/response-grounding.service';
import {
  GroundedToolResult,
  EmailSendFacts,
  MeetingScheduleFacts,
  MeetingCancelFacts,
  MeetingUpdateFacts,
  MeetingResendFacts,
  BulkOperationFacts,
  UserManagementFacts,
  CodeExecutionFacts,
  TestExecutionFacts,
  RecordCreateFacts,
  RecordUpdateFacts,
  RecordDeleteFacts,
  AnalysisFacts,
  DocumentSearchFacts,
  WebResearchFacts,
  createCriticalResult,
  createHighRiskResult,
  createMediumRiskResult,
  RESPONSE_TEMPLATES,
} from '../common/grounded-tool-result.interface';
import { CreateConversationDto } from './dto/create-conversation.dto';
import { MessageRole, ApiServiceType } from '@prisma/client';
import { tool } from 'ai';
import { z } from 'zod';

// Document source tracking for multi-document attribution
export interface DocumentSource {
  documentId: string;
  filename: string;
  sections: {
    title: string;
    pages: string;
    relevanceScore?: number;
  }[];
}

// Widget data for structured frontend rendering
export interface WidgetData {
  type: 'leads' | 'opportunities' | 'accounts' | 'contacts' | 'tasks' | 'email_draft' | 'meeting' | 'pipeline' | 'generic';
  title?: string;
  data: any[];
  metadata?: {
    totalCount?: number;
    query?: string;
    filters?: Record<string, any>;
    source?: 'local' | 'salesforce' | 'oracle_cx';
    searchTerm?: string;
  };
}

// CRM-only system prompt - no document intelligence instructions
const CRM_ONLY_SYSTEM_PROMPT = `You are IRIS Sales GPT, an AI-first sales assistant with deep CRM integration, sales expertise, and web research capabilities.

CURRENT DATE AND TIME: {{CURRENT_DATE_TIME}}
Use this for calculating dates like "tomorrow", "next week", "this month", etc. Never ask the user what today's date is.

**LOGGED-IN USER CONTEXT (SALES AGENT):**
- Name: {{USER_NAME}}
- Email: {{USER_EMAIL}}
- Title: {{USER_TITLE}}

**EMAIL SIGNATURE INSTRUCTIONS (CRITICAL):**
When composing, drafting, or sending any emails:
1. ALWAYS use the logged-in user's ACTUAL name ({{USER_NAME}}) and email ({{USER_EMAIL}}) in signatures
2. NEVER use placeholder text like "[Your Name]", "[Your Position]", "[Your Email]", or similar
3. Use a professional signature format like:
   Best regards,
   {{USER_NAME}}
   {{USER_TITLE}}
   {{USER_EMAIL}}

**DATA SOURCE: IRIS LOCAL CRM (INTERNAL DATABASE)**
CRITICAL: You are currently connected to the user's LOCAL IRIS CRM database. All data queries will fetch data from the internal IRIS database. IGNORE any data from previous messages in this conversation that may have come from a different data source (like Salesforce). Always execute tools to get current data from the local database.

ANTI-HALLUCINATION RULES (CRITICAL - NEVER VIOLATE):
1. ONLY reference data that was ACTUALLY returned by tool calls. NEVER invent record names, amounts, dates, or any other data.
2. If a tool returns 5 records, only mention those exact 5 - never fabricate additional ones.
3. If you don't have data from a tool result, say "I don't have that information" - NEVER guess or make up data.
4. All record names (Leads, Contacts, Accounts, Opportunities) must be COPIED EXACTLY from tool results - never paraphrased or invented.
5. For web research results, only cite information actually returned by research_company or web_search tools.

CRITICAL - NO MARKDOWN TABLES IN RESPONSE:
- NEVER format query results as markdown tables (using | pipes) in your text response
- The UI AUTOMATICALLY renders beautiful interactive charts (bar, line, pie) and tables from the structured data
- Your job is ONLY to provide insights and recommendations - NOT to display the raw data
- If you include a markdown table, you are duplicating what the UI already shows

IMPORTANT: You do NOT have access to document search tools in this mode. If users ask about documents or PDFs, inform them they need to switch to Document mode (using the toggle in the chat input) to search uploaded documents.

CORE CAPABILITIES:
- Complete CRM access: Create, read, update leads, opportunities, accounts, contacts, tasks, and activities
- Sales intelligence: Provide AI-powered insights, win probability analysis, and risk assessment
- Proactive recommendations: Suggest next best actions based on pipeline data and historical patterns
- Natural language understanding: Execute CRM operations from conversational queries
- Web Research: Search the internet for company information, news, leadership, competitors, and market trends using Google Search
- Meeting Scheduling: Schedule meetings on Zoom, Microsoft Teams, or Google Meet with automatic recording and transcription

NATURAL LANGUAGE PROCESSING:
Understand and execute these types of queries:
- "Show my top leads" â†’ search_leads with high scores
- "What deals close this month?" â†’ search_opportunities with closeDate filter
- "Create a lead for John at Acme" â†’ create_lead with extracted info
- "Create an opportunity for Acme" â†’ create_opportunity with name, accountName, amount
- "What should I focus on today?" â†’ get_recommended_actions + get_my_tasks
- "How's my pipeline looking?" â†’ get_pipeline_stats + get_forecast

CRITICAL - EXTRACT NUMERIC LIMITS FROM USER QUERIES:
When users specify a number in their query, ALWAYS extract and pass it as the limit parameter:
- "top 3 leads" â†’ get_top_leads with limit: 3
- "show me 5 opportunities" â†’ search_opportunities with limit: 5
- "list 10 tasks" â†’ get_my_tasks with limit: 10
- "what are my 4 biggest deals" â†’ search_opportunities with limit: 4
NEVER ignore the user's requested count - if they ask for 3, return exactly 3 (not 5 or 10).

CLARIFYING QUESTIONS FOR CRM WRITE OPERATIONS (CRITICAL):
When a user requests to CREATE, UPDATE, or DELETE a CRM record but omits REQUIRED information, ASK for clarification. NEVER attempt the operation with missing critical data.

DYNAMIC OPTION FETCHING (ALWAYS DO THIS):
1. When a picklist field needs to be updated (Stage, Status, Type, Priority, Rating, Industry, LeadSource, etc.) but the target value is missing:
   - FIRST call sf_describe_object with the appropriate object type to get valid picklist values
   - THEN ask the user which option they want, presenting the ACTUAL options from their Salesforce org
2. This works for ANY Salesforce object - Lead, Contact, Account, Opportunity, Task, Case, or custom objects
3. Examples:
   - "Update the stage for Acme deal" â†’ sf_describe_object(objectType: "Opportunity") â†’ present StageName options
   - "Change the status for John Smith lead" â†’ sf_describe_object(objectType: "Lead") â†’ present Status options
   - "Update the priority for the follow-up task" â†’ sf_describe_object(objectType: "Task") â†’ present Priority options
   - "Change the account type" â†’ sf_describe_object(objectType: "Account") â†’ present Type options

WHEN TO ASK (not exhaustive):
- "Update the stage/status/type for [record]" â†’ Fetch picklist values, then ask which one
- "Change [field] for [record]" without specifying the new value â†’ Ask what value they want
- "Update [record]" without specifying which field â†’ Ask which field(s) to update
- "Reassign [record]" without specifying to whom â†’ Ask who to assign it to
- "Create [record]" without required fields â†’ Ask for the missing required fields

NEVER attempt a CRM write operation without knowing WHAT VALUE to set - ask first.
NEVER hardcode or guess picklist values - always use sf_describe_object to get the real options.

WEB RESEARCH CAPABILITIES:
Use web research tools when users ask about:
- "Research [company name]" â†’ ALWAYS use research_company to get comprehensive company brief from the web
- "What's happening at [company]?" â†’ web_search for recent announcements  
- "Who leads [company]?" â†’ research_company for executive information
- "Search for [topic]" â†’ web_search for general information
- "Analyze [company] financial performance" â†’ research_company + search_company_news for financial data
- "[Company] stock/revenue/earnings" â†’ research_company for financial information

CRITICAL - RESEARCH COMMAND BEHAVIOR:
When a user says "Research [company]", "Analyze [company]", or asks about a company's financial performance, stock, revenue, or business information:
1. ALWAYS call the research_company tool with the company name or domain - this searches the web for company information
2. The research_company tool now AUTOMATICALLY searches both the web AND your CRM (Salesforce or local) for existing records
3. The response includes both web research AND any existing CRM records (existingCrmRecords section)
4. If the company is NOT in the CRM, suggest creating a lead or account for them
5. Do NOT just search the CRM and stop - the user expects external web research for company/financial analysis
6. For financial analysis queries ("Analyze Amex", "Apple stock performance"), ALWAYS use research_company - CRM data alone is not sufficient

IMPORTANT - NO PREAMBLE:
- Do NOT announce what you're about to do before showing results (e.g., "I'll search for..." or "Let me look up...")
- Go STRAIGHT to the research results - start with "## Company Overview" or the company name heading
- The user can see the tool execution in the UI, so announcing it is redundant and clutters the response

SHORT FOLLOW-UP QUERY HANDLING (CRITICAL):
When user sends a short message referencing previous results, interpret it correctly:
- "Lead record" or "the lead" â†’ Show FULL DETAILS of the Lead record just mentioned (use get_lead_details with the Lead Id)
- "Contact record" or "the contact" â†’ Show FULL DETAILS of the Contact record just mentioned
- "Account record" or "the account" â†’ Show FULL DETAILS of the Account record just mentioned
- "Opportunity record" or "the deal" â†’ Show FULL DETAILS of the Opportunity record just mentioned
- "More details" or "tell me more" â†’ Fetch and show ALL fields for the record(s) just discussed
- "[First name only]" (e.g., "David") â†’ Refers to the person just mentioned, show their record details
- "Email them" or "send email" â†’ Compose email to the person just mentioned
- "Schedule meeting" â†’ Schedule meeting with the person just mentioned
- "Update the opportunity" or "change stage" â†’ Use the Opportunity ID from the previous results. CRITICAL: Extract the ID (starts with 006 for Salesforce) from the data returned in your last query. Do NOT use Account ID (starts with 001).

OPPORTUNITY UPDATE FLOW (CRITICAL):
When updating an opportunity mentioned in conversation:
1. CHECK if you already have the Opportunity ID from a previous query in this conversation
2. If YES: Use that ID directly with sf_update_opportunity or update_opportunity
3. If NO: First query to get the ID: sf_query("SELECT Id, Name, StageName FROM Opportunity WHERE Name LIKE '%OpportunityName%'")
4. NEVER guess or make up an ID - always get it from query results
5. Salesforce Opportunity IDs start with "006" - Account IDs start with "001" - do not confuse them

DO NOT confuse "suggested follow-ups" shown in the UI with the user's actual request. The user's message is their intent - not the suggestions.

Example flow for "Research Deloitte.com":
- Call research_company with companyUrlOrName="Deloitte.com" â†’ Get company overview, news, leadership from the web
- Optionally call search_accounts with name containing "Deloitte" â†’ Check if account exists
- Combine: Present the web research, mention any existing CRM records, offer to create records if none exist

MEETING SCHEDULING (CRITICAL - ALWAYS FOLLOW THIS FLOW):
When users ask to schedule a meeting with someone:

**STEP 1 - SEARCH CRM FIRST (MANDATORY when a name is mentioned):**
- If user mentions a person's name, ALWAYS search the CRM first using search_contacts AND search_leads
- "Schedule a meeting with David" â†’ First search_contacts(query="David") AND search_leads(query="David")
- This finds existing CRM records with their email addresses

**STEP 2 - USE EXISTING RECORD OR ASK FOR EMAIL:**
- IF FOUND: Use the email from the CRM record as attendeeEmails and link the meeting to that contact/lead
  "I found David Lee at Acme Corp. Scheduling the meeting and sending invite to david.lee@acme.com"
- IF MULTIPLE MATCHES: Ask which one they mean
  "I found 2 people named David - David Lee at Acme and David Chen at Microsoft. Which one?"
- IF NOT FOUND: Ask for their email address
  "I don't have David in the CRM yet. What's their email address so I can send the invite?"

**STEP 3 - SCHEDULE WITH CONTEXT:**
- Use schedule_meeting with:
  - platform: ZOOM, TEAMS, or GOOGLE_MEET
  - attendeeEmails: Email address(es) from CRM lookup or user input (REQUIRED for invites to be sent)
  - leadId/contactId/accountId: Link to CRM record if found
  - Parse relative dates ("tomorrow", "next Tuesday at 2pm") using CURRENT DATE AND TIME above
  - Default to 60 minutes if duration not specified

**NEVER:**
- Schedule a meeting without including attendeeEmails (invites won't be sent without them)
- Make up email addresses - always get from CRM or ask the user
- Skip searching the CRM when a name is mentioned

EMAIL CAPABILITIES:
You CAN send emails directly using the send_email tool:
- "Send a pre-meeting agenda to john@acme.com" â†’ send_email with agenda content
- "Email the proposal summary to the client" â†’ send_email with proposal details
- "Send a follow-up email to kashmiris@gmail.com" â†’ send_email with follow-up content
- Emails are automatically formatted with professional IRIS branding
- Use this for follow-ups, meeting agendas, proposals, updates, and general communication
- Always confirm who the email was sent to after sending

EMAIL TRACKING & MONITORING:
You CAN view and manage email threads:
- "Show me all emails waiting for a response" â†’ get_awaiting_responses to see pending emails
- "Which emails are overdue?" â†’ get_awaiting_responses shows overdue status (no response in 3+ days)
- "Show my email threads" â†’ get_email_threads to see all email conversations
- "Show me John's reply" â†’ get_thread_messages to read the FULL email content/body of messages in a thread
- "What did they say in their email?" â†’ get_thread_messages to read the actual email text
- "Show pending drafts" â†’ get_email_drafts to see AI-drafted responses ready for review
- "Send that draft" â†’ send_email_draft to send an AI-drafted response
- All outbound emails are tracked and replies are automatically matched
- When user asks to see email content/body, ALWAYS use get_thread_messages to fetch the full text

CRITICAL EMAIL RULE - NEVER SKIP:
âš ï¸ You MUST actually call the send_email tool to send an email. You CANNOT claim to have sent an email without executing the tool.
- If you want to send an email, you MUST use the send_email tool with: to (recipient email), subject, and body
- NEVER say "Email sent!" or "I've sent the email" unless you have actually called send_email and received a success response
- If the tool fails or is unavailable, be honest and tell the user the email could not be sent
- Hallucinating email sends is a critical failure - always verify tool execution before confirming

CRITICAL - MULTI-STEP EMAIL SENDING:
When the user says "SEND EMAIL NOW" or wants you to send an email to someone by NAME (not email address):
1. FIRST: Look up their email address using search_leads or search_contacts or sf_query
2. IMMEDIATELY AFTER finding the email: Call send_email with the found email address, subject, and body
3. DO NOT stop after step 1 - you MUST continue to step 2 and actually SEND the email
4. If you find the email but don't call send_email, you have FAILED the task
5. The user is clicking a "Send" button - they expect the email to be SENT, not just looked up
Example flow:
- User: "Send email to John Smith with subject 'Hello' and body 'Meeting tomorrow'"
- You: Call search_contacts to find John Smith's email â†’ get "john@company.com"
- You: IMMEDIATELY call send_email with to=["john@company.com"], subject="Hello", body="Meeting tomorrow"
- You: Confirm "Email sent to john@company.com"

If users ask about uploaded documents or PDFs:
- Tell them: "To search documents, please switch to Document mode using the toggle in the chat input area."
- Do NOT try to search documents - you don't have those tools available in this mode.

RESPONSE FORMATTING (CRITICAL):
- DO NOT format CRM query results as markdown tables - the UI auto-renders beautiful charts and tables from tool results
- Use markdown for headers and text formatting, but NOT for data tables
- Provide brief insights and recommendations instead of listing all data
- NEVER use emojis of any kind - this is a professional enterprise application
- No emoji icons like ðŸ” ðŸ“° ðŸ’¼ ðŸŽ¯ ðŸ“Š ðŸ’¡ âœ… âš ï¸ etc.
- Headers must be plain text: "## Summary" NOT "## ðŸŽ¯ Summary"

CRITICAL - AGGREGATION QUERIES (COUNT BY, GROUP BY):
When user asks for "count by", "breakdown by", "distribution", "by status", "by stage", "by source", or any grouping:
- ALWAYS use GROUP BY with COUNT(Id) - NEVER return individual records
- Return aggregated counts/sums, NOT lists of records

AGGREGATION QUERY PATTERNS (ALWAYS USE THESE):
| User Query | Database Query Pattern |
|------------|------------------------|
| "Lead count by status" | Group leads by Status, return status + count |
| "Leads by source" | Group leads by LeadSource, return source + count |
| "Pipeline by stage" | Group opportunities by StageName, return stage + count + total amount |
| "Opportunities by stage" | Group opportunities by StageName, return stage + count + total amount |
| "Contacts by account" | Group contacts by Account, return account name + count |
| "Tasks by status" | Group tasks by Status, return status + count |

SALESFORCE REPORT CREATION (CRITICAL - YOU MUST CALL sf_create_report TOOL):
When user asks about "reports", determine their intent:

**QUERY DATA (default behavior)** - Use sf_query to fetch and display data:
- "Generate a report of..." â†’ Query data, display results
- "Show me a report of..." â†’ Query data, display results
- "List all accounts that..." â†’ Query data, display results
- "What accounts don't have..." â†’ Query data, display results

**CREATE PERSISTENT SALESFORCE REPORT** - YOU MUST CALL sf_create_report TOOL:
When user says ANY of these phrases, you MUST call the sf_create_report tool - do NOT just query data:
- "Create a Salesforce report..." â†’ MUST call sf_create_report tool
- "Create a report in Salesforce..." â†’ MUST call sf_create_report tool
- "Create a report called..." â†’ MUST call sf_create_report tool
- "Save this as a Salesforce report" â†’ MUST call sf_create_report tool
- "Build me a SF report for..." â†’ MUST call sf_create_report tool
- "Create this report in Salesforce" â†’ MUST call sf_create_report tool
- "I need a saved report in Salesforce" â†’ MUST call sf_create_report tool

CRITICAL: Do NOT say "I created a report" unless you actually called the sf_create_report tool and it returned success.
NEVER hallucinate report creation - you must execute the sf_create_report tool.

**sf_create_report REQUIRED PARAMETERS:**
- name: Descriptive report name (e.g., "Accounts Without Open Opportunities")
- reportType: Primary object - use the Salesforce report type API name:
  - For Account reports: "AccountList" (tabular) or "AccountCSO" (with opportunities)
  - For Lead reports: "LeadList"
  - For Opportunity reports: "OpportunityList" or "Opportunity"
  - For Contact reports: "ContactList"
  - For Activity reports: "Activity"
  - Use sf_get_report_types to find available report types if unsure
- format: TABULAR (flat list), SUMMARY (grouped with subtotals), or MATRIX (pivot table)
- columns: Array of Salesforce field API names (e.g., ["Name", "Owner.Name", "LastActivityDate"])
- filters: Optional array of filter conditions

**EXAMPLE - Create Salesforce Report:**
User: "Create a Salesforce report of accounts without open opportunities"
â†’ Call sf_create_report with:
  - name: "Accounts Without Open Opportunities"
  - reportType: "AccountList"
  - format: "TABULAR"
  - columns: ["Name", "Owner.Name", "LastActivityDate", "Industry", "Phone"]
  - filters: [{"column": "OPPORTUNITIES", "operator": "equals", "value": "0"}]

**AFTER QUERYING DATA:**
If you queried data and the user then says "Create this report in Salesforce" or "Save this as a report":
- Use sf_create_report with the same criteria from your previous query
- Confirm the report was created and provide the report name

VISUALIZATION (UI auto-renders charts based on data patterns):
The UI automatically displays beautiful visualizations - you don't need to format data:

For forecasts/trends/projections:
- Return data with time period + numeric values â†’ renders as LINE CHART
- Include fields like: Month, Quarter, Year, Period + Amount, Revenue, Value

For pipeline/stage analysis:
- Return data grouped by Stage, Status, Type + counts/amounts â†’ renders as BAR CHART or PIE CHART
- Example: Stage breakdown with opportunity count per stage

For rankings/comparisons:
- Return data with names/categories + numeric values â†’ renders as BAR CHART
- Example: Top performers by revenue, best leads by score

For KPIs/metrics:
- Return 1-4 aggregated values (totals, averages, counts) â†’ renders as KPI CARDS
- Example: Total pipeline value, average deal size, win rate

Remember: You're a sales coach and productivity partner helping users crush their quota.`;

const SYSTEM_PROMPT = `You are IRIS Sales GPT, an AI-first sales assistant with deep CRM integration, sales expertise, web research capabilities, and document intelligence.

CURRENT DATE AND TIME: {{CURRENT_DATE_TIME}}
Use this for calculating dates like "tomorrow", "next week", "this month", etc. Never ask the user what today's date is.

**LOGGED-IN USER CONTEXT (SALES AGENT):**
- Name: {{USER_NAME}}
- Email: {{USER_EMAIL}}
- Title: {{USER_TITLE}}

**EMAIL SIGNATURE INSTRUCTIONS (CRITICAL):**
When composing, drafting, or sending any emails:
1. ALWAYS use the logged-in user's ACTUAL name ({{USER_NAME}}) and email ({{USER_EMAIL}}) in signatures
2. NEVER use placeholder text like "[Your Name]", "[Your Position]", "[Your Email]", or similar
3. Use a professional signature format like:
   Best regards,
   {{USER_NAME}}
   {{USER_TITLE}}
   {{USER_EMAIL}}

ANTI-HALLUCINATION RULES (CRITICAL - NEVER VIOLATE):
1. ONLY reference data that was ACTUALLY returned by tool calls. NEVER invent record names, amounts, dates, or any other data.
2. If a tool returns 5 records, only mention those exact 5 - never fabricate additional ones.
3. When showing tables or lists, use EXACT field values from tool results (Name, Amount, CloseDate, Email, Phone, etc.).
4. If you don't have data from a tool result, say "I don't have that information" - NEVER guess or make up data.
5. All record names (Leads, Contacts, Accounts, Opportunities) must be COPIED EXACTLY from tool results - never paraphrased or invented.
6. For web research results, only cite information actually returned by research_company or web_search tools.
7. For document search results, only quote or reference text actually returned by search_document or get_document_summary tools.

CORE CAPABILITIES:
- Complete CRM access: Create, read, update leads, opportunities, accounts, contacts, tasks, and activities
- Sales intelligence: Provide AI-powered insights, win probability analysis, and risk assessment
- Proactive recommendations: Suggest next best actions based on pipeline data and historical patterns
- Natural language understanding: Execute CRM operations from conversational queries
- Web Research: Search the internet for company information, news, leadership, competitors, and market trends using Google Search
- Meeting Scheduling: Schedule meetings on Zoom, Microsoft Teams, or Google Meet with automatic recording and transcription
- Document Intelligence: Search and query indexed documents (PDFs, reports, contracts) to answer questions from uploaded files
- Email Communication: Send emails directly to contacts with professional IRIS-branded formatting
- Email Tracking: Monitor sent emails, see awaiting responses, identify overdue follow-ups, and manage AI-drafted replies

MEETING SCHEDULING CAPABILITIES (CRITICAL - FOLLOW THIS FLOW):
You CAN schedule meetings on Zoom, Teams, or Google Meet that send real invites:

**STEP 1 - SEARCH CRM FIRST (MANDATORY when a name is mentioned):**
- If user mentions a person's name, ALWAYS search the CRM first using search_contacts AND search_leads
- "Schedule a meeting with John" â†’ First search_contacts(query="John") AND search_leads(query="John")
- This finds existing CRM records with their email addresses

**STEP 2 - USE EXISTING RECORD OR ASK FOR EMAIL:**
- IF FOUND: Use the email from the CRM record as attendeeEmails
  "I found John Smith at Acme Corp. Scheduling the meeting and sending invite to john@acme.com"
- IF MULTIPLE MATCHES: Ask which one they mean
- IF NOT FOUND: Ask for their email address

**STEP 3 - SCHEDULE WITH ALL DETAILS:**
- "Schedule a Zoom meeting with Acme Corp tomorrow at 2pm" â†’ schedule_meeting with platform ZOOM
- "Set up a Teams call with John next Monday at 10am" â†’ schedule_meeting with platform TEAMS  
- "Book a Google Meet for Friday at 3pm" â†’ schedule_meeting with platform GOOGLE_MEET
- ALWAYS include attendeeEmails from CRM lookup or user input - without this, no invite is sent!
- Link meetings to the relevant CRM record (lead, account, or opportunity) when context is available
- Meetings will be automatically recorded and transcribed when they occur

**NEVER skip the CRM lookup when a name is mentioned - the email is required to send invites!**
- Be honest that this is a CRM tracking feature, not full calendar automation

DOCUMENT INTELLIGENCE CAPABILITIES:
Use document tools when users ask about uploaded files or documents:
- "What documents do I have?" â†’ list_indexed_documents to show available documents
- "Summarize the document" or "Give me an overview" â†’ get_document_summary to get AI-generated summaries of all sections
- "What are the key points?" â†’ get_document_summary for the hierarchical outline with summaries
- "Search the Amazon report for AWS revenue" â†’ search_document to find specific information
- "What does the contract say about..." â†’ search_document to find specific clauses
- When users ask for a summary or overview, ALWAYS use get_document_summary first, not search_document
- When users ask about specific topics or details, use search_document to find relevant sections
- If document not found, suggest uploading it via the Context Manager
- Messages prefixed with [DOCUMENT_SEARCH_MODE] indicate the user is in document search mode - prioritize document tools

MANDATORY DOCUMENT SEARCH RULE (CRITICAL - NEVER SKIP):
When a user asks ANY question about a specific document (by name or content):
1. ALWAYS call search_document or get_document_summary FIRST to get actual content
2. NEVER answer from memory or make up document content
3. If you only called list_indexed_documents, you MUST call search_document next before answering
4. Your response MUST be based ONLY on the actual search results returned
5. If you haven't searched the document, DO NOT describe its contents - search it first!

UNKNOWN REFERENCE RULE (CRITICAL):
When a user asks about something you don't recognize (like "Brainwave request", "the proposal", "that document", "the report", etc.):
1. NEVER say "I don't have context" or "Could you clarify?"
2. INSTEAD, FIRST call list_indexed_documents to check if there are any documents that might contain this information
3. If documents exist, call search_document with the user's query terms to find relevant content
4. Only say "I couldn't find information" AFTER you have actually searched the available documents
5. The user might be referring to content in an uploaded document - ALWAYS check documents first before saying you don't know something

DOCUMENT SUMMARY FORMATTING (Use this structure for document summaries):
When presenting document summaries, format them professionally:

## [Document Name]

**Document Type:** [Contract/Report/Proposal/etc.] | **Date:** [if available] | **Pages:** [if known]

### Overview
[2-3 sentence executive summary of what this document is about]

### Key Information
- **[Category 1]:** [Important detail]
- **[Category 2]:** [Important detail]
- **[Category 3]:** [Important detail]

### Main Sections
1. **[Section Title]** â€” [Brief description of what this section covers]
2. **[Section Title]** â€” [Brief description]
3. **[Section Title]** â€” [Brief description]

### Important Details
[Bullet points of critical information, terms, dates, amounts, parties involved]

> **Key Takeaway:** [One sentence summary of the most important thing to know]

IMPORTANT RESPONSE GUIDELINES (STRICTLY ENFORCED):
- ABSOLUTELY NEVER mention tool names, tool execution, or internal processes (FORBIDDEN phrases: "I executed", "tool", "get_document_summary", "search_document", "got this result")
- NEVER say things like "I executed the X tool" or "I used the Y function" - this breaks user immersion
- NEVER show raw JSON results or tool responses
- Present information naturally and conversationally as if YOU know it directly
- Instead of "I executed get_document_summary and got this result:", simply say "Here's what I found:" or start directly with the content
- Keep responses concise and well-structured

CRITICAL ANTI-HALLUCINATION RULES (MUST FOLLOW):
- ONLY state information that is EXPLICITLY provided in the tool results or document search results
- If information is NOT found in the search results, say "I couldn't find information about [topic] in the document" 
- NEVER make up dates, amounts, terms, parties, or any other details not explicitly in the results
- NEVER invent expiration dates, contract terms, or legal clauses
- If search results are empty or don't contain the requested information, be honest: "The document doesn't appear to contain information about [topic]"
- Today's date is always the CURRENT date - never state incorrect dates like "December 2024" when it's actually 2025
- When uncertain, say "Based on the available sections, I don't see specific information about [topic]. Would you like me to search for different terms?"
- DO NOT extrapolate or assume - only report what is explicitly stated in the document content provided
- FOR DOCUMENTS: You MUST call search_document or get_document_summary to get content. NEVER describe a document's contents without first searching it. If you only know the document exists (from list_indexed_documents), you still need to search it before answering questions about its content.

EMAIL ANTI-HALLUCINATION (CRITICAL - NEVER VIOLATE):
- You CANNOT claim to have sent an email unless you actually executed the send_email tool AND it returned success
- If user says "send this email", you MUST call send_email with to, subject, and body - don't just SAY you sent it
- NEVER say "Email sent!" or "Email delivered!" unless send_email tool returned {"success": true}
- If send_email fails or you didn't call it, say "I wasn't able to send the email" and explain why
- Pretending to send an email when you didn't is a CRITICAL FAILURE that destroys user trust

EMAIL TRACKING TOOL RESULTS (CRITICAL - NEVER MAKE UP DATA):
- When showing email threads or awaiting responses, ONLY show data from the actual tool results
- NEVER make up email addresses, subjects, or sender names like "john@acmecorp.com" or "sarah@example.com"
- Use the EXACT recipient, subject, and dates from the tool response
- If the tool returns empty or no threads, say "No emails found awaiting response"
- The thread data comes from the "threads" array in the result - each has id, subject, recipient, daysSinceLastEmail, isOverdue
- ONLY report what the tool returned - do not invent fictional email threads

EMAIL TRACKING CAPABILITIES:
Use email tracking tools to help users manage their outbound email communications:

Available tools:
- get_email_threads: Get all tracked email threads (sent through IRIS)
- get_awaiting_responses: Get emails awaiting response, optionally filtered by overdue status
- get_email_drafts: Get AI-drafted replies pending review and sending
- send_email_draft: Send a pending draft by its ID

Example queries and tool mappings:
- "Show me all emails waiting for response" â†’ get_awaiting_responses
- "Which emails are overdue?" â†’ get_awaiting_responses with overdueOnly: true
- "What drafts are pending?" â†’ get_email_drafts
- "Send the draft for [subject]" â†’ send_email_draft with draftId
- "Show my email threads" â†’ get_email_threads

Formatting email thread results:
- Show subject, recipient, status (Awaiting Response, Responded, Draft Ready)
- Highlight overdue emails (no response after expected timeframe)
- For drafts, show subject and preview of AI-suggested response

RESPONSE FORMATTING RULES (CRITICAL - Follow these exactly):
Your responses will be rendered as rich formatted content. Use markdown for professional structure:

**CRITICAL: NO EMOJIS**
- NEVER use emojis in your responses. This is a professional enterprise application.
- Do not use emoji icons like ðŸ” ðŸ“° ðŸ’¼ ðŸŽ¯ ðŸ“Š ðŸ’¡ âœ… âš ï¸ ðŸ“§ ðŸ“… etc.
- Headers should be plain text: "## Company Overview" NOT "## ðŸ¢ Company Overview"
- Use text labels and formatting instead of emoji symbols

**Hierarchy & Structure:**
- Use ## for main section headers (e.g., "## Pipeline Summary", "## Key Insights")
- Use ### for subsections (e.g., "### Top Opportunities", "### Risk Factors")
- Use #### sparingly for minor categories
- Always leave a blank line before and after headings

**Lists & Data Presentation:**
- Use bullet lists (-) for features, insights, or qualitative information
- Use numbered lists (1. 2. 3.) for sequential steps, rankings, or prioritized items
- Format key-value pairs as: **Label:** Value (bold the label, regular weight for value)
- Example: **Company:** Acme Corp | **Status:** Active | **Value:** $50,000

**Emphasis & Highlighting:**
- Use **bold** for important terms, names, statuses, and key metrics
- Use *italics* for supplementary notes, dates, or secondary information
- Use \`code formatting\` for specific values, IDs, percentages, or currency amounts
- Example: The deal is worth \`$125,000\` with a \`85%\` win probability

**Metrics & Numbers:**
- Format currency with \`$XX,XXX\` code style for emphasis
- Format percentages as \`XX%\`
- Format dates clearly: *December 6, 2025* or *Q4 2025*

**Callouts & Insights:**
- Use blockquotes (>) for important insights, recommendations, or warnings
- Example: > **Recommendation:** Follow up within 24 hours to maintain momentum

**Tables for Comparisons:**
When showing multiple records, use markdown tables:
| Lead | Company | Score | Status |
|------|---------|-------|--------|
| John Smith | Acme | \`85\` | **Hot** |

**Quote & Contract Display:**
When showing quote details, use this clean format:

## Quote: [Quote Name] ([Quote Number])

**Status:** [STATUS] | **Valid Until:** [Date]

### Overview
- **Account:** [Account Name]
- **Opportunity:** [Opportunity Name]
- **Payment Terms:** [Terms]
- **Description:** [Description]

### Line Items
| Product | Qty | Unit Price | Total |
|---------|-----|------------|-------|
| [Product Name] | [Qty] | $[Price] | $[Total] |

### Pricing Summary
- **Subtotal:** $[Amount]
- **Discount:** $[Amount]
- **Tax:** $[Amount]
- **Total:** $[Amount]

> **Next Steps:** [Suggest relevant actions based on quote status - e.g., send to customer, follow up, etc.]

**Response Flow:**
1. Start with a brief summary or direct answer (1-2 sentences)
2. Use a main heading (##) to introduce detailed content
3. Group related information under clear subheadings (###)
4. End with actionable recommendations in a blockquote
5. Keep each section concise - prefer bullets over long paragraphs

INTERACTION STYLE:
- Be conversational yet professional - talk like a helpful sales colleague, not a robot
- Anticipate needs - if a user asks about a lead, proactively mention related opportunities or tasks
- Provide context - when showing data, explain why it matters and what to do next
- Be concise but complete - give enough detail to be useful without overwhelming
- Use structure (bullets, tables, headers) for clarity when presenting multiple items

CRM INTELLIGENCE:
- When users ask vague questions like "what should I work on?", proactively check high-scoring leads, opportunities closing soon, overdue tasks, and at-risk deals
- For "show me X", always include relevant metrics and AI insights (scores, probabilities, risk factors)
- For updates, confirm what changed and suggest next steps

QUOTE LOOKUP WORKFLOW (CRITICAL):
When a user asks for quote details by quote NUMBER (e.g., "show quote Q-2025-003", "details for Q-2025-003"):
1. FIRST: Call search_quotes with the quoteNumber to find the quote and get its internal ID
2. THEN: Call get_quote_details with the ID from step 1 to get FULL details including line items
3. Present the full quote using the Quote & Contract Display format above
NEVER stop after search_quotes if user wants "details" - always follow up with get_quote_details.

CRITICAL - CREATING CRM RECORDS (NEVER HALLUCINATE DATA):
When a user asks to create ANY CRM record (lead, opportunity, account, contact, task, activity), you MUST:
1. NEVER make up, assume, or hallucinate values for ANY fields
2. ALWAYS ask the user for missing required information BEFORE calling the create tool
3. DO NOT call the create tool until you have all required information from the user
4. If user says "just create it" without providing details, ask: "I need a few details first. What is the [required field]?"

REQUIRED FIELDS BY ENTITY TYPE - Always ask if not provided:

OPPORTUNITY (create_opportunity):
- Amount (deal value) - REQUIRED, never guess
- Close Date - REQUIRED, never guess
- Account/Company Name - REQUIRED
- Example: "I'll create an opportunity for Acme. What's the expected deal value and target close date?"

LEAD (create_lead):
- First Name - REQUIRED
- Last Name - REQUIRED  
- Company Name - REQUIRED
- Email - REQUIRED (or ask for phone if no email)
- Example: "I'll create a lead at Acme. What's the contact's name and email?"

TASK (create_task):
- Subject/Title - REQUIRED
- Due Date - REQUIRED, never assume "tomorrow" or any date
- Example: "I'll create that task. When is it due?"

CONTACT (create_contact):
- First Name - REQUIRED
- Last Name - REQUIRED
- Account/Company - REQUIRED
- Email OR Phone - At least one required
- Example: "I'll create a contact. What's their full name, company, and email?"

ACCOUNT (create_account):
- Account Name - REQUIRED
- Example: "What's the company name for the new account?"

ACTIVITY (log_activity):
- Type (CALL, EMAIL, MEETING) - REQUIRED
- Subject - REQUIRED
- Related record - Ask what lead/opportunity/contact it's for

CONVERSATION FLOW FOR CREATING RECORDS:
1. User: "Create an opportunity for Microsoft"
2. You: "I'll create an opportunity for Microsoft. I need a few details:
   - What's the expected deal value?
   - What's the target close date?"
3. User: "$500k, end of Q1"
4. You: [NOW call create_opportunity with the provided values]

NEVER DO THIS:
- User: "Create an opportunity for Acme"
- You: [Immediately calls create_opportunity with made-up $150,000 amount and random date]

CRITICAL - DATA TABLE HANDLING (ABSOLUTE RULE - NEVER VIOLATE):

**For READ operations** (search, get, list):
When CRM tools return data (leads, opportunities, contacts, accounts, tasks, activities), the UI AUTOMATICALLY renders a smart interactive data table with ALL records. Your response must NEVER duplicate this data.

ABSOLUTELY FORBIDDEN for READ operations - NEVER include:
- Markdown tables (| Name | Company | Score |)
- Bullet lists of individual records (- John at Acme - 85 points)
- Numbered lists of records (1. John Smith, 2. Jane Doe)
- Any enumeration or listing of returned CRM records
- Name/company/score combinations in any format

YOUR ONLY JOB for READ operations:
1. Write a brief 1-sentence summary ("Found 5 leads" or "Here's your current lead")
2. Highlight ONE key insight about the most important record
3. Provide ONE actionable recommendation
4. STOP IMMEDIATELY - the data table handles everything else

PERFECT example response for READ (e.g., "show me the current lead details"):
"Here's your current lead:

**Analysis & Recommendations:**
This is a high-value contact (Managing Director at Deloitte), but the lead score is low because:
- No recent engagement activities logged
- Buying intent hasn't been assessed

**Immediate Action Items:**
1. Research the contact - Find relevant talking points
2. Make first contact - Reach out via email or phone
3. Log the activity - Record your outreach to boost engagement score"

WRONG example (NEVER do this for READ operations - the table shows the data):
"| Name | Company | Score | Status |
|------|---------|-------|--------|
| Ankur | Deloitte | 45 | NEW |"

**For WRITE operations** (create, update, delete):
These operations generate a "Generated Report" card showing what was changed. Your response SHOULD be detailed and confirmatory.

YOUR JOB for WRITE operations:
1. Confirm what was done with specific details (e.g., "Updated Mark Evans' contact information")
2. Summarize what fields were changed (e.g., "Phone number updated to 212-200-1299")
3. Provide relevant next steps or suggestions (e.g., "Want to reach out to Mark now?")

PERFECT example response for WRITE (e.g., "Update phone for Mark Evans as 212-200-1299"):
"## Mark Evans Contact Update

Updated contact information for Mark Evans at Costco Wholesale Depot:

**Changes Made:**
- **Phone:** 212-200-1299

The contact record has been updated successfully.

**Suggested Next Steps:**
- Reach out to Mark at the new number
- Log the call activity after connecting
- Update any related opportunities"

Remember: READ operations show data in tables (minimize your text), WRITE operations show confirmation cards (be detailed and helpful).

NATURAL LANGUAGE PROCESSING:
Understand and execute these types of queries:
- "Show my top leads" â†’ search_leads with high scores
- "What deals close this month?" â†’ search_opportunities with closeDate filter
- "Create a lead for John at Acme" â†’ create_lead with extracted info
- "Create an opportunity for Acme" â†’ create_opportunity with name, accountName, amount
- "Create a deal for $100k" â†’ create_opportunity with amount and details
- "Convert this lead to an opportunity" â†’ create_opportunity or convert_lead
- "Update opportunity X to negotiation stage" â†’ update_opportunity
- "What should I focus on today?" â†’ get_my_ai_insights + get_my_tasks
- "How's my pipeline looking?" â†’ get_pipeline_stats + get_deal_health
- "Give me coaching tips" â†’ get_sales_coaching
- "How am I doing?" â†’ get_sales_coaching for performance analysis
- "What deals are at risk?" â†’ get_deal_health with focus on risky deals
- "How is [account] doing?" â†’ get_account_intelligence with account name
- "What are my AI insights?" â†’ get_my_ai_insights for all alerts
- "Any recommendations for me?" â†’ get_my_ai_insights + get_sales_coaching
- "Coach me" â†’ get_sales_coaching for personalized tips
- "What can I improve?" â†’ get_sales_coaching with performance analysis

CRITICAL - EXTRACT NUMERIC LIMITS FROM USER QUERIES:
When users specify a number in their query, ALWAYS extract and pass it as the limit parameter:
- "top 3 leads" â†’ get_top_leads with limit: 3
- "show me 5 opportunities" â†’ search_opportunities with limit: 5
- "list 10 tasks" â†’ get_my_tasks with limit: 10
- "what are my 4 biggest deals" â†’ search_opportunities with limit: 4
NEVER ignore the user's requested count - if they ask for 3, return exactly 3 (not 5 or 10).

CLARIFYING QUESTIONS FOR CRM WRITE OPERATIONS (CRITICAL):
When a user requests to CREATE, UPDATE, or DELETE a CRM record but omits REQUIRED information, ASK for clarification. NEVER attempt the operation with missing critical data.

DYNAMIC OPTION FETCHING (ALWAYS DO THIS):
1. When a picklist field needs to be updated (Stage, Status, Type, Priority, Rating, Industry, LeadSource, etc.) but the target value is missing:
   - FIRST call sf_describe_object with the appropriate object type to get valid picklist values
   - THEN ask the user which option they want, presenting the ACTUAL options from their Salesforce org
2. This works for ANY Salesforce object - Lead, Contact, Account, Opportunity, Task, Case, or custom objects
3. Examples:
   - "Update the stage for Acme deal" â†’ sf_describe_object(objectType: "Opportunity") â†’ present StageName options
   - "Change the status for John Smith lead" â†’ sf_describe_object(objectType: "Lead") â†’ present Status options
   - "Update the priority for the follow-up task" â†’ sf_describe_object(objectType: "Task") â†’ present Priority options
   - "Change the account type" â†’ sf_describe_object(objectType: "Account") â†’ present Type options

WHEN TO ASK (not exhaustive):
- "Update the stage/status/type for [record]" â†’ Fetch picklist values, then ask which one
- "Change [field] for [record]" without specifying the new value â†’ Ask what value they want
- "Update [record]" without specifying which field â†’ Ask which field(s) to update
- "Reassign [record]" without specifying to whom â†’ Ask who to assign it to
- "Create [record]" without required fields â†’ Ask for the missing required fields

NEVER attempt a CRM write operation without knowing WHAT VALUE to set - ask first.
NEVER hardcode or guess picklist values - always use sf_describe_object to get the real options.

WEB RESEARCH CAPABILITIES:
Use web research tools when users ask about:
- "Research [company name]" â†’ ALWAYS use research_company to get comprehensive company brief from the web
- "What's happening at [company]?" â†’ search_company_news for recent announcements
- "Who leads [company]?" â†’ search_leadership for executive information
- "Who competes with [company]?" â†’ search_competitors for competitive landscape
- "Search for [topic]" â†’ web_search for general information
- "Analyze [company] financial performance" â†’ research_company + search_company_news for financial data
- "[Company] stock/revenue/earnings" â†’ research_company for financial information
- When preparing for a sales call, proactively offer to research the prospect company
- When creating leads or accounts, offer to research the company for additional context

CRITICAL - RESEARCH COMMAND BEHAVIOR:
When a user says "Research [company]", "Analyze [company]", or asks about a company's financial performance, stock, revenue, or business information:
1. ALWAYS call the research_company tool with the company name - this searches the web AND your CRM automatically
2. The research_company tool returns both web research AND any existing CRM records (in existingCrmRecords section)
3. If the company is NOT in the CRM, suggest creating a lead or account for them
4. Do NOT just search the CRM and stop - the user expects external web research for company/financial analysis
5. For financial analysis queries ("Analyze Amex", "Apple financial performance"), ALWAYS use research_company - CRM data alone is not sufficient

IMPORTANT - NO PREAMBLE:
- Do NOT announce what you're about to do before showing results (e.g., "I'll search for..." or "Let me look up...")
- Go STRAIGHT to the research results - start with "## Company Overview" or the company name heading
- The user can see the tool execution in the UI, so announcing it is redundant and clutters the response

Example flow for "Research Deloitte.com":
- Call research_company with companyUrlOrName="Deloitte.com" â†’ Get company overview, news, leadership from the web
- Optionally call sf_search with searchTerm="Deloitte" â†’ Check if account exists in Salesforce
- Combine: Present the web research, mention any existing CRM records, offer to create records if none exist

COMPANY RESEARCH RESPONSE FORMAT (CRITICAL - Use this exact structure):
When providing company research or account briefs, ALWAYS format data consistently for parsing:

## Company Overview

**[Company Name]** is a [brief description].

**Key Facts:**
- **Revenue:** $XX.X billion (or $XXX million) - ALWAYS include the $ symbol and billion/million unit
- **Employees:** XXX,XXX employees - ALWAYS use the word "employees" after the number
- **Founded:** XXXX - four digit year
- **Headquarters:** City, Country
- **Industry:** [Industry name]
- **Website:** domain.com

**Leadership Team:**
- **[Full Name]**, CEO (or Chief Executive Officer)
- **[Full Name]**, CFO (or Chief Financial Officer)
- **[Full Name]**, CTO (or Chief Technology Officer)
- **[Full Name]**, COO (or Chief Operating Officer)
- **[Full Name]**, President

## Recent News & Developments
[News items as bullet points]

## Products & Services
[Description of offerings]

## Competitive Landscape
**Competitors:** [Company1], [Company2], [Company3]

## Sales Intelligence
[Relevant insights for sales approach]

IMPORTANT DATA FORMATTING RULES:
1. Revenue: ALWAYS format as "$X.X billion" or "$XXX million" - never omit the $ or unit
2. Employees: ALWAYS include the word "employees" after the number (e.g., "470,000 employees")
3. Executives: ALWAYS format as "**Name**, Title" with the title being CEO/CFO/CTO/COO/President
4. Founded: ALWAYS use 4-digit year format
5. Never use abbreviations like "B" or "M" alone - spell out "billion" or "million"
6. Use commas in large numbers: 470,000 not 470000

SALES ASSET CREATION:
When asked for emails, call scripts, proposals, etc.:
- Generate professional, persuasive content in markdown format
- Include relevant structure (Subject lines for emails, sections for scripts)
- Tailor tone and approach based on the sales context
- Offer follow-up suggestions for personalization or next steps

DATA VISUALIZATION:
When users ask for charts, graphs, or visual representations of data:
- YOU CAN generate visual charts! Use the research_company tool to create Account Reports with interactive charts
- For any request involving "show me a chart", "graph", "visualize", "visual report" - use research_company for the relevant company
- The Account Report artifact includes: revenue charts, growth trends, market analysis with actual visual graphs
- For pipeline visualization: Present structured markdown tables, then offer "Would you like me to generate a visual pipeline report?"
- For company metrics: ALWAYS use research_company - it creates beautiful interactive charts
- NEVER say you cannot create charts - you CAN via the research_company tool and Account Report artifacts
- Example: If user asks "show me a revenue graph for Acme", use research_company with companyUrlOrName="Acme"

CONTEXTUAL AWARENESS:
- Remember what was discussed earlier in the conversation
- Reference specific leads, opportunities, or accounts by name when relevant
- Build on previous queries (e.g., if user asks about a lead, then says "create a task for them", know who "them" refers to)

ERROR HANDLING:
- If a tool fails, explain what went wrong in plain language
- Suggest alternatives or corrections
- Never expose technical error messages - translate them into actionable guidance

PROACTIVE VALUE:
- After showing data, offer insights: "I notice opportunity X has been in the same stage for 45 days - would you like me to analyze it?"
- Suggest best practices: "Since this lead has high buying intent, I recommend reaching out within 24 hours"
- Celebrate wins: "Great job closing that deal! Would you like me to create a renewal reminder?"

Remember: You're not just executing commands - you're a sales coach and productivity partner helping users crush their quota.`;

const CRM_TOOLS = [
  {
    name: 'resolve_entity',
    description: `Resolve an entity name to its CRM ID. Use this BEFORE creating activities, notes, or any operation that requires an entity ID when user provides a name instead of ID.

WHEN TO USE:
- User says "Log a call with Acme" â†’ resolve_entity(entityType: "account", name: "Acme") to get the account ID
- User says "Add a note to the Microsoft deal" â†’ resolve_entity(entityType: "opportunity", name: "Microsoft") to get the opportunity ID
- User says "Show me John Smith's contact" â†’ resolve_entity(entityType: "contact", name: "John Smith") to get the contact ID

ENTITY TYPES: lead, contact, account, opportunity

Returns the matching entity ID and basic details, or suggestions if multiple matches found.`,
    input_schema: {
      type: 'object',
      properties: {
        entityType: {
          type: 'string',
          description: 'Type of entity to look up: lead, contact, account, or opportunity',
          enum: ['lead', 'contact', 'account', 'opportunity'],
        },
        name: {
          type: 'string',
          description: 'The name to search for (company name, person name, or deal name)'
        },
        fuzzyMatch: {
          type: 'boolean',
          description: 'If true, returns partial matches. Default is true.',
        },
      },
      required: ['entityType', 'name'],
    },
  },
  {
    name: 'create_lead',
    description: 'Create a new lead in the CRM. IMPORTANT: Before calling this tool, you MUST ask the user for firstName, lastName, company, and email if they did not provide them. Never make up contact details.',
    input_schema: {
      type: 'object',
      properties: {
        firstName: { type: 'string', description: 'First name of the lead - MUST be provided by user' },
        lastName: { type: 'string', description: 'Last name of the lead - MUST be provided by user' },
        company: { type: 'string', description: 'Company name - MUST be provided by user' },
        email: { type: 'string', description: 'Email address - MUST be provided by user' },
        phone: { type: 'string', description: 'Phone number (optional)' },
        title: { type: 'string', description: 'Job title (optional)' },
        industry: { type: 'string', description: 'Industry (optional)' },
      },
      required: ['firstName', 'lastName', 'company', 'email'],
    },
  },
  {
    name: 'search_leads',
    description: 'Search for leads in the CRM based on criteria like status, score, rating, company name, or lead name. IMPORTANT: If user specifies a number (e.g., "show 3 leads", "5 hot leads"), extract that number and pass it as the limit parameter.',
    input_schema: {
      type: 'object',
      properties: {
        name: { type: 'string', description: 'Search by lead\'s first name, last name, or full name (e.g., "David Lee", "Sarah")' },
        status: { type: 'string', description: 'Lead status (NEW, CONTACTED, QUALIFIED, CONVERTED, etc.)' },
        rating: { type: 'string', description: 'Lead rating (HOT, WARM, COLD)' },
        minScore: { type: 'number', description: 'Minimum lead score (0-100)' },
        company: { type: 'string', description: 'Company name to search for' },
        limit: { type: 'number', description: 'Maximum results - MUST be extracted from user query if specified (e.g., "show 3" â†’ limit: 3). Default: 10' },
      },
    },
  },
  {
    name: 'get_lead_details',
    description: 'Get detailed information about a specific lead by ID, including all recent interactions, tasks, events, and activities. Use this tool when the user wants to view lead details, see recent interactions, or check activity history.',
    input_schema: {
      type: 'object',
      properties: {
        leadId: { type: 'string', description: 'The ID of the lead to retrieve' },
      },
      required: ['leadId'],
    },
  },
  {
    name: 'update_lead',
    description: 'Update an existing lead\'s information or status.',
    input_schema: {
      type: 'object',
      properties: {
        leadId: { type: 'string', description: 'The ID of the lead to update' },
        status: { type: 'string', description: 'New status for the lead' },
        rating: { type: 'string', description: 'New rating for the lead' },
        notes: { type: 'string', description: 'Notes about the update' },
      },
      required: ['leadId'],
    },
  },
  {
    name: 'qualify_lead',
    description: 'Mark a lead as qualified and ready for conversion.',
    input_schema: {
      type: 'object',
      properties: {
        leadId: { type: 'string', description: 'The ID of the lead to qualify' },
      },
      required: ['leadId'],
    },
  },
  {
    name: 'convert_lead',
    description: 'Convert a lead into an account, contact, and optionally an opportunity.',
    input_schema: {
      type: 'object',
      properties: {
        leadId: { type: 'string', description: 'The ID of the lead to convert' },
        createOpportunity: { type: 'boolean', description: 'Whether to create an opportunity' },
        opportunityAmount: { type: 'number', description: 'Expected opportunity amount' },
      },
      required: ['leadId'],
    },
  },
  {
    name: 'get_pipeline_stats',
    description: 'Get current pipeline statistics including total opportunities, value, and breakdown by stage.',
    input_schema: {
      type: 'object',
      properties: {},
    },
  },
  {
    name: 'search_opportunities',
    description: 'Search for opportunities in the pipeline based on criteria.',
    input_schema: {
      type: 'object',
      properties: {
        stage: { type: 'string', description: 'Opportunity stage to filter by' },
        minAmount: { type: 'number', description: 'Minimum opportunity amount' },
        closeDate: { type: 'string', description: 'Filter by close date (this_month, this_quarter, etc.)' },
        limit: { type: 'number', description: 'Maximum number of results (default 10)' },
      },
    },
  },
  {
    name: 'get_opportunity_details',
    description: 'Get detailed information about a specific opportunity by ID.',
    input_schema: {
      type: 'object',
      properties: {
        opportunityId: { type: 'string', description: 'The ID of the opportunity to retrieve' },
      },
      required: ['opportunityId'],
    },
  },
  {
    name: 'create_opportunity',
    description: 'Create a new opportunity in the CRM. IMPORTANT: Before calling this tool, you MUST ask the user for the deal amount and close date if they did not provide them. Never make up values - always confirm with the user first.',
    input_schema: {
      type: 'object',
      properties: {
        name: { type: 'string', description: 'Opportunity name (e.g., "Acme Corp - Product Deal")' },
        accountId: { type: 'string', description: 'The ID of the associated account (optional if accountName provided)' },
        accountName: { type: 'string', description: 'Name of the account/company (will search or create if accountId not provided)' },
        amount: { type: 'number', description: 'Expected deal value in dollars - MUST be provided by user, do not guess' },
        closeDate: { type: 'string', description: 'Expected close date (ISO format) - MUST be provided by user, do not guess' },
        stage: { type: 'string', description: 'Pipeline stage: PROSPECTING, QUALIFICATION, NEEDS_ANALYSIS, VALUE_PROPOSITION, DECISION_MAKERS_IDENTIFIED, PERCEPTION_ANALYSIS, PROPOSAL_PRICE_QUOTE, NEGOTIATION_REVIEW. Default to PROSPECTING if user says to just create it.' },
        type: { type: 'string', description: 'Opportunity type: NEW_BUSINESS, EXISTING_BUSINESS, UPSELL, CROSS_SELL, RENEWAL' },
        source: { type: 'string', description: 'Lead source: WEB, REFERRAL, PARTNER, TRADE_SHOW, COLD_CALL, MARKETING, etc.' },
        contactName: { type: 'string', description: 'Primary contact name (optional)' },
        contactEmail: { type: 'string', description: 'Primary contact email (optional)' },
        nextStep: { type: 'string', description: 'Next action to take on this opportunity' },
        description: { type: 'string', description: 'Description or notes about the opportunity' },
      },
      required: ['name', 'amount', 'closeDate'],
    },
  },
  {
    name: 'update_opportunity',
    description: 'Update an opportunity. CRITICAL REQUIREMENTS: (1) You MUST have the opportunity ID from a previous query. If user references an opportunity by NAME (e.g., "update CVS"), FIRST use search_opportunities to get the ID, then call this tool. (2) If user says "update the stage" without specifying WHICH stage, DO NOT call this - ASK the user which stage they want first. (3) For Salesforce opportunities (ID starts with 006), use sf_update_opportunity instead.',
    input_schema: {
      type: 'object',
      properties: {
        opportunityId: { type: 'string', description: 'The ID of the opportunity to update (from previous search/query results)' },
        stage: { type: 'string', description: 'New stage for the opportunity' },
        amount: { type: 'number', description: 'New amount for the opportunity' },
        closeDate: { type: 'string', description: 'New close date (ISO format)' },
        notes: { type: 'string', description: 'Notes about the update' },
      },
      required: ['opportunityId'],
    },
  },
  {
    name: 'analyze_opportunity',
    description: 'Use AI to analyze an opportunity and provide win probability, risks, and recommendations.',
    input_schema: {
      type: 'object',
      properties: {
        opportunityId: { type: 'string', description: 'The ID of the opportunity to analyze' },
      },
      required: ['opportunityId'],
    },
  },
  {
    name: 'close_opportunity',
    description: 'Close an opportunity as won or lost.',
    input_schema: {
      type: 'object',
      properties: {
        opportunityId: { type: 'string', description: 'The ID of the opportunity to close' },
        won: { type: 'boolean', description: 'True if won, false if lost' },
        reason: { type: 'string', description: 'Reason for closing (required if lost)' },
      },
      required: ['opportunityId', 'won'],
    },
  },
  {
    name: 'search_accounts',
    description: 'Search for accounts (companies) in the CRM.',
    input_schema: {
      type: 'object',
      properties: {
        name: { type: 'string', description: 'Account name to search for' },
        type: { type: 'string', description: 'Account type (CUSTOMER, PROSPECT, etc.)' },
        industry: { type: 'string', description: 'Industry filter' },
        limit: { type: 'number', description: 'Maximum number of results (default 10)' },
      },
    },
  },
  {
    name: 'get_account_details',
    description: 'Get detailed information about an account including related opportunities, contacts, and revenue.',
    input_schema: {
      type: 'object',
      properties: {
        accountId: { type: 'string', description: 'The ID of the account to retrieve' },
      },
      required: ['accountId'],
    },
  },
  {
    name: 'search_contacts',
    description: 'Search for contacts in the CRM.',
    input_schema: {
      type: 'object',
      properties: {
        name: { type: 'string', description: 'Contact name to search for' },
        accountId: { type: 'string', description: 'Filter by account ID' },
        title: { type: 'string', description: 'Job title filter' },
        limit: { type: 'number', description: 'Maximum number of results (default 10)' },
      },
    },
  },
  {
    name: 'search_quotes',
    description: 'Search for quotes in the CRM by quote number (e.g., Q-2025-003) or filter by status/account. Returns a SUMMARY list. For FULL DETAILS including line items, use get_quote_details with the quote ID from these results.',
    input_schema: {
      type: 'object',
      properties: {
        quoteNumber: { type: 'string', description: 'Search by quote number (e.g., Q-2025-003 or partial match like 2025-003)' },
        status: { type: 'string', description: 'Quote status filter: DRAFT, SENT, ACCEPTED, REJECTED, EXPIRED' },
        opportunityId: { type: 'string', description: 'Filter by opportunity ID' },
        accountId: { type: 'string', description: 'Filter by account ID' },
        limit: { type: 'number', description: 'Maximum number of results (default 10)' },
      },
    },
  },
  {
    name: 'get_quote_details',
    description: 'Get FULL details of a specific quote including line items, pricing breakdown, and all fields. ALWAYS use this after search_quotes when user asks for quote "details". Requires the quote ID (not quote number) from search_quotes.',
    input_schema: {
      type: 'object',
      properties: {
        quoteId: { type: 'string', description: 'The internal ID of the quote (from search_quotes), NOT the quote number' },
      },
      required: ['quoteId'],
    },
  },
  {
    name: 'create_quote',
    description: 'Create a new quote/proposal for an opportunity.',
    input_schema: {
      type: 'object',
      properties: {
        opportunityId: { type: 'string', description: 'The opportunity ID this quote is for' },
        accountId: { type: 'string', description: 'The account ID' },
        name: { type: 'string', description: 'Quote name/title' },
        validUntil: { type: 'string', description: 'Quote validity date (ISO format)' },
        paymentTerms: { type: 'string', description: 'Payment terms (e.g., Net 30)' },
        description: { type: 'string', description: 'Quote description or notes' },
      },
      required: ['opportunityId', 'accountId', 'name'],
    },
  },
  {
    name: 'update_quote',
    description: 'Update a quote status or details.',
    input_schema: {
      type: 'object',
      properties: {
        quoteId: { type: 'string', description: 'The quote ID to update' },
        status: { type: 'string', description: 'New status: DRAFT, SENT, ACCEPTED, REJECTED, EXPIRED' },
        validUntil: { type: 'string', description: 'New validity date' },
        paymentTerms: { type: 'string', description: 'Payment terms' },
      },
      required: ['quoteId'],
    },
  },
  {
    name: 'delete_quote',
    description: 'Delete a draft quote. Cannot delete sent or accepted quotes.',
    input_schema: {
      type: 'object',
      properties: {
        quoteId: { type: 'string', description: 'The quote ID to delete' },
      },
      required: ['quoteId'],
    },
  },
  // CONTRACT TOOLS
  {
    name: 'search_contracts',
    description: 'Search for contracts in the CRM. Returns active contracts, renewals due, and contract details.',
    input_schema: {
      type: 'object',
      properties: {
        status: { type: 'string', description: 'Contract status: DRAFT, PENDING_SIGNATURE, ACTIVE, EXPIRED, TERMINATED, RENEWED' },
        accountId: { type: 'string', description: 'Filter by account ID' },
        renewalDue: { type: 'boolean', description: 'Show contracts due for renewal in next 60 days' },
        limit: { type: 'number', description: 'Maximum results (default 10)' },
      },
    },
  },
  {
    name: 'get_contract_details',
    description: 'Get detailed information about a specific contract.',
    input_schema: {
      type: 'object',
      properties: {
        contractId: { type: 'string', description: 'The contract ID to retrieve' },
      },
      required: ['contractId'],
    },
  },
  {
    name: 'create_contract',
    description: 'Create a new contract, optionally from an accepted quote.',
    input_schema: {
      type: 'object',
      properties: {
        accountId: { type: 'string', description: 'The account ID' },
        quoteId: { type: 'string', description: 'Optional: Link to accepted quote' },
        contractName: { type: 'string', description: 'Contract name/title' },
        startDate: { type: 'string', description: 'Contract start date (ISO format)' },
        endDate: { type: 'string', description: 'Contract end date (ISO format)' },
        contractTerm: { type: 'number', description: 'Contract term in months' },
        contractValue: { type: 'number', description: 'Total contract value' },
        billingFrequency: { type: 'string', description: 'Billing frequency: Monthly, Quarterly, Annually' },
        autoRenew: { type: 'boolean', description: 'Auto-renew flag' },
        description: { type: 'string', description: 'Contract description' },
      },
      required: ['accountId', 'contractName'],
    },
  },
  {
    name: 'update_contract',
    description: 'Update contract status or details.',
    input_schema: {
      type: 'object',
      properties: {
        contractId: { type: 'string', description: 'The contract ID to update' },
        status: { type: 'string', description: 'New status: DRAFT, PENDING_SIGNATURE, ACTIVE, EXPIRED, TERMINATED' },
        endDate: { type: 'string', description: 'New end date' },
        autoRenew: { type: 'boolean', description: 'Auto-renew flag' },
      },
      required: ['contractId'],
    },
  },
  // CAMPAIGN TOOLS
  {
    name: 'search_campaigns',
    description: 'Search for marketing campaigns and their performance metrics.',
    input_schema: {
      type: 'object',
      properties: {
        status: { type: 'string', description: 'Campaign status: PLANNED, IN_PROGRESS, COMPLETED, ABORTED' },
        campaignType: { type: 'string', description: 'Campaign type: Email, Event, Webinar, etc.' },
        limit: { type: 'number', description: 'Maximum results (default 10)' },
      },
    },
  },
  {
    name: 'get_campaign_details',
    description: 'Get detailed campaign information including performance metrics and linked opportunities.',
    input_schema: {
      type: 'object',
      properties: {
        campaignId: { type: 'string', description: 'The campaign ID to retrieve' },
      },
      required: ['campaignId'],
    },
  },
  {
    name: 'get_campaign_roi',
    description: 'Get ROI analysis for a campaign including cost per lead and revenue attribution.',
    input_schema: {
      type: 'object',
      properties: {
        campaignId: { type: 'string', description: 'The campaign ID to analyze' },
      },
      required: ['campaignId'],
    },
  },
  // ACCOUNT CRUD
  {
    name: 'create_account',
    description: 'Create a new account/company in the CRM.',
    input_schema: {
      type: 'object',
      properties: {
        name: { type: 'string', description: 'Account/company name' },
        type: { type: 'string', description: 'Account type: PROSPECT, CUSTOMER, PARTNER, COMPETITOR, OTHER' },
        industry: { type: 'string', description: 'Industry sector' },
        website: { type: 'string', description: 'Company website URL' },
        phone: { type: 'string', description: 'Main phone number' },
        annualRevenue: { type: 'number', description: 'Annual revenue' },
        employees: { type: 'number', description: 'Number of employees' },
        description: { type: 'string', description: 'Account description' },
        billingCity: { type: 'string', description: 'Billing city' },
        billingState: { type: 'string', description: 'Billing state' },
        billingCountry: { type: 'string', description: 'Billing country' },
      },
      required: ['name'],
    },
  },
  {
    name: 'update_account',
    description: 'Update an existing account.',
    input_schema: {
      type: 'object',
      properties: {
        accountId: { type: 'string', description: 'The account ID to update' },
        name: { type: 'string', description: 'Account name' },
        type: { type: 'string', description: 'Account type' },
        industry: { type: 'string', description: 'Industry' },
        website: { type: 'string', description: 'Website URL' },
        phone: { type: 'string', description: 'Phone number' },
        annualRevenue: { type: 'number', description: 'Annual revenue' },
        employees: { type: 'number', description: 'Employee count' },
      },
      required: ['accountId'],
    },
  },
  {
    name: 'delete_account',
    description: 'Delete an account. WARNING: This will also delete all related contacts, opportunities, and activities.',
    input_schema: {
      type: 'object',
      properties: {
        accountId: { type: 'string', description: 'The account ID to delete' },
        confirm: { type: 'boolean', description: 'Must be true to confirm deletion' },
      },
      required: ['accountId', 'confirm'],
    },
  },
  // CONTACT CRUD
  {
    name: 'create_contact',
    description: 'Create a new contact in the CRM.',
    input_schema: {
      type: 'object',
      properties: {
        firstName: { type: 'string', description: 'First name' },
        lastName: { type: 'string', description: 'Last name' },
        accountId: { type: 'string', description: 'Associated account ID' },
        email: { type: 'string', description: 'Email address' },
        phone: { type: 'string', description: 'Phone number' },
        mobilePhone: { type: 'string', description: 'Mobile phone' },
        title: { type: 'string', description: 'Job title' },
        department: { type: 'string', description: 'Department' },
        role: { type: 'string', description: 'Role: DECISION_MAKER, INFLUENCER, CHAMPION, END_USER, ECONOMIC_BUYER, TECHNICAL_BUYER, GATEKEEPER' },
      },
      required: ['firstName', 'lastName'],
    },
  },
  {
    name: 'update_contact',
    description: 'Update an existing contact.',
    input_schema: {
      type: 'object',
      properties: {
        contactId: { type: 'string', description: 'The contact ID to update' },
        firstName: { type: 'string', description: 'First name' },
        lastName: { type: 'string', description: 'Last name' },
        email: { type: 'string', description: 'Email address' },
        phone: { type: 'string', description: 'Phone number' },
        title: { type: 'string', description: 'Job title' },
        department: { type: 'string', description: 'Department' },
        role: { type: 'string', description: 'Contact role' },
      },
      required: ['contactId'],
    },
  },
  {
    name: 'delete_contact',
    description: 'Delete a contact from the CRM.',
    input_schema: {
      type: 'object',
      properties: {
        contactId: { type: 'string', description: 'The contact ID to delete' },
      },
      required: ['contactId'],
    },
  },
  // NOTE TOOLS
  {
    name: 'create_note',
    description: 'Create a note attached to a lead, account, contact, or opportunity.',
    input_schema: {
      type: 'object',
      properties: {
        title: { type: 'string', description: 'Note title (optional)' },
        body: { type: 'string', description: 'Note content' },
        leadId: { type: 'string', description: 'Attach to lead ID' },
        accountId: { type: 'string', description: 'Attach to account ID' },
        contactId: { type: 'string', description: 'Attach to contact ID' },
        opportunityId: { type: 'string', description: 'Attach to opportunity ID' },
        isPrivate: { type: 'boolean', description: 'Private note (only visible to creator)' },
      },
      required: ['body'],
    },
  },
  {
    name: 'get_notes',
    description: 'Get notes for a specific record.',
    input_schema: {
      type: 'object',
      properties: {
        leadId: { type: 'string', description: 'Get notes for lead' },
        accountId: { type: 'string', description: 'Get notes for account' },
        contactId: { type: 'string', description: 'Get notes for contact' },
        opportunityId: { type: 'string', description: 'Get notes for opportunity' },
        limit: { type: 'number', description: 'Maximum results (default 10)' },
      },
    },
  },
  {
    name: 'delete_note',
    description: 'Delete a note.',
    input_schema: {
      type: 'object',
      properties: {
        noteId: { type: 'string', description: 'The note ID to delete' },
      },
      required: ['noteId'],
    },
  },
  // TASK CRUD COMPLETION
  {
    name: 'update_task',
    description: 'Update a task status, priority, or due date.',
    input_schema: {
      type: 'object',
      properties: {
        taskId: { type: 'string', description: 'The task ID to update' },
        status: { type: 'string', description: 'New status: NOT_STARTED, IN_PROGRESS, COMPLETED, WAITING, DEFERRED' },
        priority: { type: 'string', description: 'Priority: LOW, NORMAL, HIGH, URGENT' },
        dueDate: { type: 'string', description: 'New due date (ISO format)' },
        subject: { type: 'string', description: 'Task subject' },
        description: { type: 'string', description: 'Task description' },
      },
      required: ['taskId'],
    },
  },
  {
    name: 'complete_task',
    description: 'Mark a task as completed.',
    input_schema: {
      type: 'object',
      properties: {
        taskId: { type: 'string', description: 'The task ID to complete' },
        completionNotes: { type: 'string', description: 'Optional notes about completion' },
      },
      required: ['taskId'],
    },
  },
  {
    name: 'delete_task',
    description: 'Delete a task.',
    input_schema: {
      type: 'object',
      properties: {
        taskId: { type: 'string', description: 'The task ID to delete' },
      },
      required: ['taskId'],
    },
  },
  // LEAD DELETE
  {
    name: 'delete_lead',
    description: 'Delete a lead from the CRM. Use with caution.',
    input_schema: {
      type: 'object',
      properties: {
        leadId: { type: 'string', description: 'The lead ID to delete' },
      },
      required: ['leadId'],
    },
  },
  // OPPORTUNITY DELETE
  {
    name: 'delete_opportunity',
    description: 'Delete an opportunity. Cannot delete closed/won opportunities.',
    input_schema: {
      type: 'object',
      properties: {
        opportunityId: { type: 'string', description: 'The opportunity ID to delete' },
      },
      required: ['opportunityId'],
    },
  },
  {
    name: 'get_contact_details',
    description: 'Get detailed information about a contact including engagement history and opportunities.',
    input_schema: {
      type: 'object',
      properties: {
        contactId: { type: 'string', description: 'The ID of the contact to retrieve' },
      },
      required: ['contactId'],
    },
  },
  {
    name: 'create_task',
    description: 'Create a new task. IMPORTANT: Before calling this tool, you MUST ask the user for the due date if they did not provide it. Never assume or make up dates.',
    input_schema: {
      type: 'object',
      properties: {
        subject: { type: 'string', description: 'Task subject/title - REQUIRED, must be provided by user' },
        description: { type: 'string', description: 'Task description' },
        dueDate: { type: 'string', description: 'Due date (ISO format) - MUST be provided by user, never assume' },
        priority: { type: 'string', description: 'Priority (LOW, NORMAL, HIGH, URGENT)' },
        relatedTo: { type: 'string', description: 'Related entity (lead:ID, opportunity:ID, etc.)' },
      },
      required: ['subject'],
    },
  },
  {
    name: 'get_my_tasks',
    description: 'Get tasks assigned to the current user, optionally filtered by status or priority.',
    input_schema: {
      type: 'object',
      properties: {
        status: { type: 'string', description: 'Task status filter' },
        priority: { type: 'string', description: 'Priority filter' },
        dueToday: { type: 'boolean', description: 'Only show tasks due today' },
      },
    },
  },
  {
    name: 'log_activity',
    description: 'Log an activity (call, email, meeting) related to a CRM record.',
    input_schema: {
      type: 'object',
      properties: {
        type: { type: 'string', description: 'Activity type (CALL, EMAIL, MEETING, etc.)' },
        subject: { type: 'string', description: 'Activity subject' },
        description: { type: 'string', description: 'Activity details' },
        relatedTo: { type: 'string', description: 'Related entity (lead:ID, opportunity:ID, etc.)' },
        outcome: { type: 'string', description: 'Activity outcome' },
      },
      required: ['type', 'subject'],
    },
  },
  {
    name: 'get_activity_timeline',
    description: 'Get activity timeline for a specific CRM record.',
    input_schema: {
      type: 'object',
      properties: {
        entityType: { type: 'string', description: 'Entity type (lead, account, contact, opportunity)' },
        entityId: { type: 'string', description: 'Entity ID' },
      },
      required: ['entityType', 'entityId'],
    },
  },
  {
    name: 'get_forecast',
    description: 'Get sales forecast data for the current quarter or year.',
    input_schema: {
      type: 'object',
      properties: {
        period: { type: 'string', description: 'Forecast period (quarter, year)' },
      },
    },
  },
  {
    name: 'get_top_leads',
    description: 'Get the top-scoring leads (score >= 70) that need attention. Returns the highest scoring leads sorted by lead score. IMPORTANT: If user specifies a number (e.g., "top 3 leads", "show me 5 leads"), extract that number and pass it as the limit parameter.',
    input_schema: {
      type: 'object',
      properties: {
        limit: { type: 'number', description: 'Number of leads to return - MUST be extracted from user query if specified (e.g., "top 3" â†’ limit: 3). Default: 5' },
      },
    },
  },
  {
    name: 'get_at_risk_opportunities',
    description: 'Get opportunities that are at risk based on AI analysis.',
    input_schema: {
      type: 'object',
      properties: {
        limit: { type: 'number', description: 'Number of opportunities to return (default 5)' },
      },
    },
  },
  {
    name: 'get_recommended_actions',
    description: 'Get AI-recommended next actions based on current CRM data and context.',
    input_schema: {
      type: 'object',
      properties: {
        context: { type: 'string', description: 'Current context (e.g., viewing a specific lead)' },
      },
    },
  },
  // WEB RESEARCH TOOLS - Google Custom Search Integration
  {
    name: 'web_search',
    description: 'Search the web for any information using Google Custom Search. Use this for general research, finding information about topics, technologies, market trends, or any external information not in the CRM.',
    input_schema: {
      type: 'object',
      properties: {
        query: { type: 'string', description: 'The search query to look up on the web' },
      },
      required: ['query'],
    },
  },
  {
    name: 'research_company',
    description: 'Research a company by URL or name. Gathers comprehensive information including company overview, recent news, leadership, competitors, and job postings to identify growth signals.',
    input_schema: {
      type: 'object',
      properties: {
        companyUrlOrName: { type: 'string', description: 'Company website URL (e.g., stripe.com) or company name' },
        includeNews: { type: 'boolean', description: 'Include recent news (default: true)' },
        includeLeadership: { type: 'boolean', description: 'Include leadership/team info (default: true)' },
        includeCompetitors: { type: 'boolean', description: 'Include competitor analysis (default: false)' },
        includeJobs: { type: 'boolean', description: 'Include job postings as growth signals (default: true)' },
      },
      required: ['companyUrlOrName'],
    },
  },
  {
    name: 'search_company_news',
    description: 'Search for recent news and announcements about a specific company. Useful for finding buying signals, leadership changes, funding announcements, or product launches.',
    input_schema: {
      type: 'object',
      properties: {
        companyName: { type: 'string', description: 'Name of the company to search news for' },
        days: { type: 'number', description: 'Number of days to look back (default: 30)' },
      },
      required: ['companyName'],
    },
  },
  {
    name: 'search_competitors',
    description: 'Search for competitors and alternatives to a company. Useful for competitive analysis and positioning.',
    input_schema: {
      type: 'object',
      properties: {
        companyName: { type: 'string', description: 'Name of the company to find competitors for' },
        industry: { type: 'string', description: 'Industry to narrow down competitor search (optional)' },
      },
      required: ['companyName'],
    },
  },
  {
    name: 'search_leadership',
    description: 'Search for leadership team and key executives at a company. Useful for identifying decision makers and stakeholders.',
    input_schema: {
      type: 'object',
      properties: {
        companyName: { type: 'string', description: 'Name of the company to find leadership for' },
      },
      required: ['companyName'],
    },
  },

  // ==================== MEETING INTELLIGENCE TOOLS ====================
  {
    name: 'schedule_meeting',
    description: `Schedule a new meeting with a client on Zoom, Microsoft Teams, or Google Meet. The meeting will be automatically recorded and transcribed.

IMPORTANT: To send calendar invites to attendees, you MUST either:
1. Provide attendeeEmails array with the attendee's email addresses (RECOMMENDED), OR
2. Provide leadId or contactId so the system can look up the email automatically.

If you know the attendee's email from earlier in the conversation (e.g., from a Lead lookup), ALWAYS include it in attendeeEmails.
Without an email address, the meeting will be created but NO calendar invite will be sent to attendees.`,
    input_schema: {
      type: 'object',
      properties: {
        title: { type: 'string', description: 'Title of the meeting' },
        platform: { type: 'string', enum: ['ZOOM', 'TEAMS', 'GOOGLE_MEET'], description: 'Meeting platform to use' },
        scheduledStart: { type: 'string', description: 'ISO 8601 datetime for meeting start (e.g., "2024-01-15T14:00:00Z")' },
        scheduledEnd: { type: 'string', description: 'ISO 8601 datetime for meeting end (optional)' },
        description: { type: 'string', description: 'Meeting description or agenda (optional)' },
        leadId: { type: 'string', description: 'ID of the lead this meeting is about. If attendeeEmails is not provided, the lead\'s email will be used to send the invite.' },
        contactId: { type: 'string', description: 'ID of the contact this meeting is about. If attendeeEmails is not provided, the contact\'s email will be used to send the invite.' },
        accountId: { type: 'string', description: 'ID of the account this meeting is about (optional)' },
        opportunityId: { type: 'string', description: 'ID of the opportunity this meeting is about (optional)' },
        attendeeEmails: { type: 'array', items: { type: 'string' }, description: 'Email addresses of attendees to invite. HIGHLY RECOMMENDED - provide this to ensure calendar invites are sent. If not provided, the system will try to fetch email from the linked lead/contact.' },
      },
      required: ['title', 'platform', 'scheduledStart'],
    },
  },
  {
    name: 'get_meeting',
    description: 'Get details of a specific meeting session including status, recording, transcript, and analysis.',
    input_schema: {
      type: 'object',
      properties: {
        meetingId: { type: 'string', description: 'ID of the meeting session to retrieve' },
      },
      required: ['meetingId'],
    },
  },
  {
    name: 'list_meetings',
    description: 'List all IRIS meeting sessions. ALWAYS call this tool FIRST when user mentions a meeting by person name (e.g., "meeting with David", "my meeting tomorrow") to find the meeting ID needed for cancel_meeting, get_meeting_rsvp_status, and other meeting operations.',
    input_schema: {
      type: 'object',
      properties: {
        leadId: { type: 'string', description: 'Filter by lead ID (optional)' },
        accountId: { type: 'string', description: 'Filter by account ID (optional)' },
        opportunityId: { type: 'string', description: 'Filter by opportunity ID (optional)' },
        status: { type: 'string', enum: ['SCHEDULED', 'IN_PROGRESS', 'COMPLETED', 'CANCELLED'], description: 'Filter by meeting status (optional)' },
        platform: { type: 'string', enum: ['ZOOM', 'TEAMS', 'GOOGLE_MEET'], description: 'Filter by platform (optional)' },
        startDate: { type: 'string', description: 'Filter meetings after this date (ISO 8601, optional)' },
        endDate: { type: 'string', description: 'Filter meetings before this date (ISO 8601, optional)' },
        limit: { type: 'number', description: 'Maximum number of meetings to return (default: 10)' },
      },
      required: [],
    },
  },
  {
    name: 'get_meeting_transcript',
    description: 'Get the full transcript of a completed meeting, including speaker attribution and timestamps.',
    input_schema: {
      type: 'object',
      properties: {
        meetingId: { type: 'string', description: 'ID of the meeting session to get transcript for' },
        format: { type: 'string', enum: ['full', 'summary', 'by_speaker'], description: 'Transcript format (default: full)' },
      },
      required: ['meetingId'],
    },
  },
  {
    name: 'get_meeting_analysis',
    description: 'Get AI-generated analysis of a completed meeting including summary, key points, action items, buying signals, objections, and deal risk assessment.',
    input_schema: {
      type: 'object',
      properties: {
        meetingId: { type: 'string', description: 'ID of the meeting session to get analysis for' },
      },
      required: ['meetingId'],
    },
  },
  {
    name: 'get_meeting_insights',
    description: 'Get extracted insights from a meeting such as pain points, buying signals, objections, competitor mentions, and next actions.',
    input_schema: {
      type: 'object',
      properties: {
        meetingId: { type: 'string', description: 'ID of the meeting session to get insights for' },
        type: { type: 'string', enum: ['PAIN_POINT', 'BUYING_SIGNAL', 'OBJECTION', 'COMPETITOR_MENTION', 'NEXT_ACTION', 'PRICING_CONCERN'], description: 'Filter by insight type (optional)' },
        priority: { type: 'string', enum: ['LOW', 'MEDIUM', 'HIGH', 'URGENT'], description: 'Filter by priority (optional)' },
      },
      required: ['meetingId'],
    },
  },
  {
    name: 'search_meeting_transcripts',
    description: 'Search across all meeting transcripts for specific topics, keywords, or phrases. Useful for finding past discussions about specific features, competitors, or concerns.',
    input_schema: {
      type: 'object',
      properties: {
        query: { type: 'string', description: 'Search query to find in transcripts' },
        leadId: { type: 'string', description: 'Filter by lead ID (optional)' },
        accountId: { type: 'string', description: 'Filter by account ID (optional)' },
        dateRange: { type: 'number', description: 'Number of days to search back (default: 90)' },
        limit: { type: 'number', description: 'Maximum number of results (default: 10)' },
      },
      required: ['query'],
    },
  },
  {
    name: 'create_tasks_from_meeting',
    description: 'Create CRM tasks from meeting action items. Automatically generates tasks based on the meeting analysis.',
    input_schema: {
      type: 'object',
      properties: {
        meetingId: { type: 'string', description: 'ID of the meeting to create tasks from' },
        autoAssign: { type: 'boolean', description: 'Automatically assign tasks based on action item assignees (default: true)' },
      },
      required: ['meetingId'],
    },
  },
  {
    name: 'update_crm_from_meeting',
    description: 'Update CRM records based on meeting insights. Can update lead status, opportunity stage, add notes, and log activities.',
    input_schema: {
      type: 'object',
      properties: {
        meetingId: { type: 'string', description: 'ID of the meeting to process' },
        updateLead: { type: 'boolean', description: 'Update lead status and score based on meeting (default: true)' },
        updateOpportunity: { type: 'boolean', description: 'Update opportunity stage and probability (default: true)' },
        createActivity: { type: 'boolean', description: 'Create activity record for this meeting (default: true)' },
        addNotes: { type: 'boolean', description: 'Add meeting summary as notes to related records (default: true)' },
      },
      required: ['meetingId'],
    },
  },
  // MEETING RSVP & PARTICIPANT MANAGEMENT TOOLS
  {
    name: 'get_meeting_rsvp_status',
    description: 'Get the RSVP status summary for a meeting including who has accepted, declined, or not yet responded. Shows participant response details and notes.',
    input_schema: {
      type: 'object',
      properties: {
        meetingId: { type: 'string', description: 'ID of the meeting to check RSVP status for' },
      },
      required: ['meetingId'],
    },
  },
  {
    name: 'get_meeting_participants',
    description: 'Get detailed information about all participants in a meeting including their roles, response status, engagement during meeting, and contact information.',
    input_schema: {
      type: 'object',
      properties: {
        meetingId: { type: 'string', description: 'ID of the meeting to get participants for' },
        includeContactDetails: { type: 'boolean', description: 'Include linked contact details if available (default: true)' },
      },
      required: ['meetingId'],
    },
  },
  {
    name: 'update_meeting_rsvp',
    description: 'Update the RSVP response for a meeting participant. Use this when a participant responds via phone, email, or other channel.',
    input_schema: {
      type: 'object',
      properties: {
        meetingId: { type: 'string', description: 'ID of the meeting' },
        participantEmail: { type: 'string', description: 'Email address of the participant to update' },
        responseStatus: { type: 'string', enum: ['ACCEPTED', 'DECLINED', 'TENTATIVE'], description: 'New response status' },
        responseNote: { type: 'string', description: 'Optional note about the response (e.g., reason for declining)' },
      },
      required: ['meetingId', 'participantEmail', 'responseStatus'],
    },
  },
  {
    name: 'cancel_meeting',
    description: 'Cancel/delete a scheduled meeting and send cancellation emails to all participants. Use this when user says "cancel meeting", "delete meeting", "remove meeting", or similar. First use list_meetings to find the meeting ID if user refers to meeting by person name.',
    input_schema: {
      type: 'object',
      properties: {
        meetingId: { type: 'string', description: 'ID of the meeting to cancel (get from list_meetings first)' },
        reason: { type: 'string', description: 'Reason for cancellation (will be included in notification email)' },
        sendNotification: { type: 'boolean', description: 'Send cancellation email to participants (default: true)' },
      },
      required: ['meetingId'],
    },
  },
  {
    name: 'get_meeting_response_history',
    description: 'Get the full history of RSVP response changes for a meeting. Shows audit trail of who responded when and how their response changed over time.',
    input_schema: {
      type: 'object',
      properties: {
        meetingId: { type: 'string', description: 'ID of the meeting to get response history for' },
        participantEmail: { type: 'string', description: 'Optional: filter to specific participant email' },
      },
      required: ['meetingId'],
    },
  },
  {
    name: 'resend_meeting_invite',
    description: 'Resend meeting invite to participants who have not responded or to specific participants. Useful for follow-up on pending RSVPs.',
    input_schema: {
      type: 'object',
      properties: {
        meetingId: { type: 'string', description: 'ID of the meeting' },
        emails: { type: 'array', items: { type: 'string' }, description: 'Specific email addresses to resend to (optional - if not provided, sends to all pending)' },
        onlyPending: { type: 'boolean', description: 'Only resend to participants with PENDING status (default: true)' },
      },
      required: ['meetingId'],
    },
  },
  {
    name: 'check_meeting_availability',
    description: 'Check if participants are likely available for a meeting by analyzing their past meeting patterns and response history. Helps optimize meeting scheduling.',
    input_schema: {
      type: 'object',
      properties: {
        participantEmails: { type: 'array', items: { type: 'string' }, description: 'Email addresses of potential participants' },
        proposedTime: { type: 'string', description: 'Proposed meeting time in ISO 8601 format' },
        duration: { type: 'number', description: 'Meeting duration in minutes (default: 30)' },
      },
      required: ['participantEmails', 'proposedTime'],
    },
  },
  // 10X PRODUCTIVITY TOOLS
  {
    name: 'generate_followup_email',
    description: 'Generate a personalized follow-up email based on a recent meeting. Uses meeting insights, action items, and CRM context to craft the perfect follow-up.',
    input_schema: {
      type: 'object',
      properties: {
        meetingId: { type: 'string', description: 'ID of the meeting to base the email on' },
        recipientName: { type: 'string', description: 'Name of the email recipient (optional - auto-detected from meeting)' },
        tone: { type: 'string', enum: ['formal', 'friendly', 'urgent', 'consultative'], description: 'Email tone (default: consultative)' },
        includeActionItems: { type: 'boolean', description: 'Include discussed action items in the email (default: true)' },
        includeNextSteps: { type: 'boolean', description: 'Include proposed next steps (default: true)' },
      },
      required: ['meetingId'],
    },
  },
  {
    name: 'analyze_deal_risk',
    description: 'Perform comprehensive deal risk analysis for an opportunity. Analyzes meeting history, engagement patterns, timeline, and competitive factors to identify risks and suggest mitigation strategies.',
    input_schema: {
      type: 'object',
      properties: {
        opportunityId: { type: 'string', description: 'ID of the opportunity to analyze' },
        includeRecommendations: { type: 'boolean', description: 'Include AI-recommended actions to mitigate risks (default: true)' },
      },
      required: ['opportunityId'],
    },
  },
  {
    name: 'get_daily_priorities',
    description: 'Get AI-prioritized list of tasks and actions for today based on deal stages, meeting follow-ups, task deadlines, and engagement patterns. Helps users focus on highest-impact activities.',
    input_schema: {
      type: 'object',
      properties: {
        maxItems: { type: 'number', description: 'Maximum number of priorities to return (default: 10)' },
        includeReasoning: { type: 'boolean', description: 'Include AI reasoning for each priority (default: true)' },
      },
    },
  },
  {
    name: 'suggest_next_actions',
    description: 'Get AI-suggested next actions for a specific lead, opportunity, or account based on their current state, recent interactions, and sales best practices.',
    input_schema: {
      type: 'object',
      properties: {
        entityType: { type: 'string', enum: ['lead', 'opportunity', 'account'], description: 'Type of entity to get suggestions for' },
        entityId: { type: 'string', description: 'ID of the entity' },
        context: { type: 'string', description: 'Additional context about the situation (optional)' },
      },
      required: ['entityType', 'entityId'],
    },
  },
  {
    name: 'prepare_meeting_brief',
    description: 'Generate a comprehensive pre-meeting brief for an upcoming call. Includes account background, recent interactions, open opportunities, key contacts, potential objections, and suggested talking points.',
    input_schema: {
      type: 'object',
      properties: {
        meetingId: { type: 'string', description: 'ID of the upcoming meeting (optional - provide account/lead ID instead)' },
        accountId: { type: 'string', description: 'ID of the account (if no meeting ID)' },
        leadId: { type: 'string', description: 'ID of the lead (if no meeting or account ID)' },
        includeCompetitorIntel: { type: 'boolean', description: 'Include competitor intelligence if available (default: true)' },
      },
    },
  },
  {
    name: 'batch_update_pipeline',
    description: 'Perform batch updates on multiple opportunities. Useful for end-of-day/week pipeline hygiene - update stages, add notes, set next steps for multiple deals at once.',
    input_schema: {
      type: 'object',
      properties: {
        updates: {
          type: 'array',
          items: {
            type: 'object',
            properties: {
              opportunityId: { type: 'string', description: 'Opportunity ID' },
              stage: { type: 'string', description: 'New stage (optional)' },
              nextStep: { type: 'string', description: 'Next step description (optional)' },
              closeDate: { type: 'string', description: 'Updated close date (optional)' },
              notes: { type: 'string', description: 'Notes to add (optional)' },
            },
            required: ['opportunityId'],
          },
          description: 'Array of opportunity updates',
        },
      },
      required: ['updates'],
    },
  },
  // EMAIL TOOLS
  {
    name: 'send_email',
    description: 'Send an email to one or more recipients. Use this for follow-ups, meeting agendas, proposals, and general communication.',
    input_schema: {
      type: 'object',
      properties: {
        to: {
          type: 'array',
          items: { type: 'string' },
          description: 'Email addresses of recipients'
        },
        subject: { type: 'string', description: 'Email subject line' },
        body: { type: 'string', description: 'Email body content (can include HTML formatting)' },
        isHtml: { type: 'boolean', description: 'Whether the body is HTML formatted (default: true)' },
      },
      required: ['to', 'subject', 'body'],
    },
  },
  // EMAIL TRACKING TOOLS
  {
    name: 'get_email_threads',
    description: 'Get all email threads/conversations for the current user. Shows email history, status (awaiting response, responded, etc.), and thread details.',
    input_schema: {
      type: 'object',
      properties: {
        status: {
          type: 'string',
          enum: ['AWAITING_RESPONSE', 'RESPONDED', 'CLOSED', 'FOLLOW_UP_NEEDED'],
          description: 'Filter by thread status (optional)'
        },
        limit: { type: 'number', description: 'Maximum number of threads to return (default: 20)' },
      },
    },
  },
  {
    name: 'get_awaiting_responses',
    description: 'Get all email threads that are waiting for a response from the recipient. Use this to find emails that need follow-up.',
    input_schema: {
      type: 'object',
      properties: {},
    },
  },
  {
    name: 'get_thread_messages',
    description: 'Get the full email messages/content from a specific email thread. Use this to read the actual email body text of messages including replies. This allows viewing the complete email trail.',
    input_schema: {
      type: 'object',
      properties: {
        threadId: { type: 'string', description: 'The ID of the email thread to get messages from' },
      },
      required: ['threadId'],
    },
  },
  {
    name: 'get_email_drafts',
    description: 'Get all AI-generated email drafts that are ready for review and sending. These are auto-drafted responses to incoming emails. Optionally filter by thread ID.',
    input_schema: {
      type: 'object',
      properties: {
        threadId: { type: 'string', description: 'Optional thread ID to filter drafts for a specific email thread' },
      },
    },
  },
  {
    name: 'send_email_draft',
    description: 'Send a previously generated email draft. Use this after reviewing an AI-drafted response.',
    input_schema: {
      type: 'object',
      properties: {
        draftId: { type: 'string', description: 'The ID of the draft to send' },
      },
      required: ['draftId'],
    },
  },
  // ==================== AI INSIGHTS & COACHING TOOLS (MVP #1 & #2) ====================
  {
    name: 'get_my_ai_insights',
    description: `Get AI-generated insights and recommendations for the current user. Use this when the user asks about:
- "What should I focus on today?"
- "Give me coaching tips"
- "What are my AI insights?"
- "What deals need attention?"
- "Any recommendations for me?"

Returns prioritized alerts from AI agents including deal health warnings, coaching recommendations, account intelligence, and next best actions.`,
    input_schema: {
      type: 'object',
      properties: {
        agentType: {
          type: 'string',
          description: 'Filter by agent type: DEAL_HEALTH, COACHING, ACCOUNT_INTELLIGENCE, PIPELINE_ACCELERATION, NEXT_BEST_ACTION',
          enum: ['DEAL_HEALTH', 'COACHING', 'ACCOUNT_INTELLIGENCE', 'PIPELINE_ACCELERATION', 'NEXT_BEST_ACTION'],
        },
        priority: {
          type: 'string',
          description: 'Filter by priority level',
          enum: ['URGENT', 'HIGH', 'MEDIUM', 'LOW'],
        },
        limit: { type: 'number', description: 'Maximum number of insights to return (default: 10)' },
      },
    },
  },
  {
    name: 'get_account_signals',
    description: `Get AI-detected account signals and alerts from the Listening Agent. ALWAYS use this tool when user asks:
- "Show me my signals"
- "What signals do I have?"
- "What's happening with my accounts?"
- "Any account alerts?"
- "Account notifications"
- "Show me account activity"

Returns executive changes, funding events, expansion signals, technology changes, news mentions, and usage patterns detected by AI agents. This is DIFFERENT from get_my_ai_insights which returns coaching/deal insights.`,
    input_schema: {
      type: 'object',
      properties: {
        accountId: { type: 'string', description: 'Filter signals by specific account ID' },
        status: {
          type: 'string',
          description: 'Filter by signal status',
          enum: ['PENDING', 'ACKNOWLEDGED', 'ACTIONED', 'DISMISSED'],
        },
        priority: {
          type: 'string',
          description: 'Filter by priority level',
          enum: ['LOW', 'MEDIUM', 'HIGH', 'CRITICAL'],
        },
        signalTypes: {
          type: 'array',
          items: {
            type: 'string',
            enum: ['EXEC_CHANGE', 'FUNDING', 'EXPANSION', 'TECH_CHANGE', 'NEWS', 'USAGE_SPIKE'],
          },
          description: 'Filter by signal types',
        },
        timeframe: {
          type: 'string',
          description: 'Time range for signals',
          enum: ['24h', '7d', '30d', '90d'],
        },
        limit: { type: 'number', description: 'Maximum number of signals to return' },
      },
    },
  },
  {
    name: 'get_sales_coaching',
    description: `Get personalized AI sales coaching advice and performance analysis. Use this when the user asks:
- "How am I doing?"
- "Give me sales tips"
- "Coach me on my deals"
- "What can I improve?"
- "Analyze my performance"
- "Help me close more deals"

Returns coaching insights, win patterns, performance metrics, and actionable recommendations.`,
    input_schema: {
      type: 'object',
      properties: {
        focusArea: {
          type: 'string',
          description: 'Optional focus area for coaching',
          enum: ['discovery', 'negotiation', 'closing', 'prospecting', 'pipeline_management', 'general'],
        },
      },
    },
  },
  {
    name: 'get_account_intelligence',
    description: `Get AI-generated intelligence and health score for a specific account. Use this when user asks:
- "How is [account name] doing?"
- "What's the health of my account?"
- "Any risks with [company]?"
- "Tell me about [account] engagement"

Returns account health score, engagement metrics, risk indicators, and recommended actions.`,
    input_schema: {
      type: 'object',
      properties: {
        accountId: { type: 'string', description: 'The account ID to analyze' },
        accountName: { type: 'string', description: 'Account name to search for (if ID not provided)' },
      },
    },
  },
  {
    name: 'get_deal_health',
    description: `Get AI analysis of deal health and risk factors for opportunities. Use this when user asks:
- "Which deals are at risk?"
- "What's the health of my pipeline?"
- "Any stalled deals?"
- "Which opportunities need attention?"

Returns deal health scores, risk factors, and recommended next steps.`,
    input_schema: {
      type: 'object',
      properties: {
        opportunityId: { type: 'string', description: 'Specific opportunity ID to analyze (optional)' },
        riskLevel: {
          type: 'string',
          description: 'Filter by risk level',
          enum: ['high_risk', 'medium_risk', 'healthy'],
        },
        limit: { type: 'number', description: 'Maximum number of deals to return (default: 10)' },
      },
    },
  },
  {
    name: 'acknowledge_ai_insight',
    description: 'Acknowledge an AI insight/alert to mark it as seen. Use when user says "got it", "thanks", "acknowledged" after seeing an insight.',
    input_schema: {
      type: 'object',
      properties: {
        alertId: { type: 'string', description: 'The ID of the alert to acknowledge' },
      },
      required: ['alertId'],
    },
  },
  {
    name: 'dismiss_ai_insight',
    description: 'Dismiss an AI insight/alert as not relevant. Use when user says "dismiss this", "not relevant", "ignore this".',
    input_schema: {
      type: 'object',
      properties: {
        alertId: { type: 'string', description: 'The ID of the alert to dismiss' },
        reason: { type: 'string', description: 'Optional reason for dismissing' },
      },
      required: ['alertId'],
    },
  },
  // Video Coaching Tools (MVP #2 Enhancement)
  {
    name: 'list_coaching_sessions',
    description: `List the user's video coaching practice sessions. Use when user asks:
- "Show my coaching sessions"
- "What practice recordings do I have?"
- "My coaching history"
- "Show my sales practice sessions"

Returns a list of coaching sessions with scores and status.`,
    input_schema: {
      type: 'object',
      properties: {
        scenario: {
          type: 'string',
          description: 'Filter by scenario type',
          enum: ['ELEVATOR_PITCH', 'DISCOVERY_CALL', 'DEMO_PRESENTATION', 'OBJECTION_HANDLING', 'NEGOTIATION', 'CLOSING', 'COLD_CALL', 'FOLLOW_UP', 'GENERAL_PRACTICE'],
        },
        status: {
          type: 'string',
          description: 'Filter by status',
          enum: ['RECORDING', 'UPLOADING', 'TRANSCRIBING', 'ANALYZING', 'COMPLETED', 'FAILED'],
        },
        limit: { type: 'number', description: 'Maximum number of sessions to return (default: 10)' },
      },
    },
  },
  {
    name: 'get_coaching_session',
    description: `Get details of a specific video coaching session including AI feedback. Use when user asks:
- "Show me the feedback for session X"
- "What was my score on that pitch?"
- "Details of my last practice"

Returns the full coaching session with transcription, scores, and detailed feedback.`,
    input_schema: {
      type: 'object',
      properties: {
        sessionId: { type: 'string', description: 'The coaching session ID to retrieve' },
      },
      required: ['sessionId'],
    },
  },
  {
    name: 'get_coaching_progress',
    description: `Get the user's overall coaching progress and improvement trends. Use when user asks:
- "How am I improving?"
- "My coaching progress"
- "Am I getting better at sales?"
- "Show my practice stats"

Returns progress metrics, trends, strengths, and focus areas.`,
    input_schema: {
      type: 'object',
      properties: {},
    },
  },
  {
    name: 'get_coaching_scenarios',
    description: `Get available coaching scenarios for video practice. Use when user asks:
- "What scenarios can I practice?"
- "What should I practice?"
- "Types of sales coaching"

Returns available scenarios like elevator pitch, discovery call, objection handling, etc.`,
    input_schema: {
      type: 'object',
      properties: {},
    },
  },
  // AI Generated Code by Deloitte + Cursor (BEGIN)
  // Enhanced Coaching Tools (Gap Resolution)
  {
    name: 'start_coaching_session',
    description: `Guide the user to start a new coaching practice session. Use when user asks:
- "Practice my elevator pitch"
- "I want to practice objection handling"
- "Start a coaching session"
- "Help me practice"

Provides guidance on how to access the Practice Studio and start recording.`,
    input_schema: {
      type: 'object',
      properties: {
        scenario: {
          type: 'string',
          description: 'The scenario they want to practice',
          enum: ['ELEVATOR_PITCH', 'DISCOVERY_CALL', 'DEMO_PRESENTATION', 'OBJECTION_HANDLING', 'NEGOTIATION', 'CLOSING', 'COLD_CALL', 'FOLLOW_UP', 'GENERAL_PRACTICE'],
        },
      },
    },
  },
  {
    name: 'compare_coaching_sessions',
    description: `Compare multiple coaching sessions to show improvement or identify patterns. Use when user asks:
- "Compare my last 3 elevator pitch sessions"
- "How have I improved in objection handling?"
- "Show me my progress on demos"
- "Compare my recent sessions"

Analyzes and compares scores, identifies trends, and provides insights.`,
    input_schema: {
      type: 'object',
      properties: {
        sessionIds: {
          type: 'array',
          items: { type: 'string' },
          description: 'Array of 2-5 session IDs to compare',
        },
        scenario: {
          type: 'string',
          description: 'Optional: Filter to specific scenario',
          enum: ['ELEVATOR_PITCH', 'DISCOVERY_CALL', 'DEMO_PRESENTATION', 'OBJECTION_HANDLING', 'NEGOTIATION', 'CLOSING', 'COLD_CALL', 'FOLLOW_UP', 'GENERAL_PRACTICE'],
        },
        limit: {
          type: 'number',
          description: 'Number of recent sessions to compare if sessionIds not provided',
        },
      },
    },
  },
  {
    name: 'generate_coaching_agenda',
    description: `Generate a personalized coaching agenda based on the user's performance and weak areas. Use when user asks:
- "What should I focus on this week?"
- "Create a coaching plan for me"
- "What do I need to work on?"
- "Suggest practice areas"

Analyzes recent performance and suggests prioritized topics to practice.`,
    input_schema: {
      type: 'object',
      properties: {
        timeframe: {
          type: 'string',
          description: 'Timeframe for the agenda',
          enum: ['this_week', 'next_week', 'this_month'],
        },
        focusAreas: {
          type: 'array',
          items: { type: 'string' },
          description: 'Optional: Specific areas to focus on',
        },
      },
    },
  },
  // AI Generated Code by Deloitte + Cursor (END)
];

// Document tools names for filtering
const DOCUMENT_TOOL_NAMES = ['list_indexed_documents', 'search_document', 'get_document_structure', 'get_document_summary'];

// DOCUMENT INTELLIGENCE TOOLS - PageIndex Integration
const DOCUMENT_TOOLS_ARRAY = [
  {
    name: 'list_indexed_documents',
    description: 'List all documents that have been indexed and are available for searching. ALWAYS call this FIRST when user asks about something unfamiliar (like "Brainwave request", "the proposal", etc.) - they might be referring to content in an uploaded document. Use this to see what documents exist before claiming you don\'t know something.',
    input_schema: {
      type: 'object',
      properties: {},
    },
  },
  {
    name: 'search_document',
    description: 'Search within an indexed document to find relevant information. Use this to find specific content like requests, proposals, terms, requirements etc. IMPORTANT: You must ONLY report information that appears in the search results. If the search results do not contain the specific information requested, tell the user that information was not found. NEVER make up or invent details.',
    input_schema: {
      type: 'object',
      properties: {
        documentId: { type: 'string', description: 'The ID of the document to search (from list_indexed_documents)' },
        query: { type: 'string', description: 'The search query - what information to find in the document' },
        maxResults: { type: 'number', description: 'Maximum number of relevant sections to return (default: 5)' },
      },
      required: ['documentId', 'query'],
    },
  },
  {
    name: 'get_document_structure',
    description: 'Get the full hierarchical structure (table of contents) of an indexed document. Use this to understand what topics/sections a document covers.',
    input_schema: {
      type: 'object',
      properties: {
        documentId: { type: 'string', description: 'The ID of the document to get structure for' },
      },
      required: ['documentId'],
    },
  },
  {
    name: 'get_document_summary',
    description: 'Get a comprehensive summary of an indexed document including all section summaries. Use this when users ask to summarize a document, get an overview, or understand the key points. This returns AI-generated summaries for each section of the document.',
    input_schema: {
      type: 'object',
      properties: {
        documentId: { type: 'string', description: 'The ID of the document to summarize' },
      },
      required: ['documentId'],
    },
  },
];

// Full CRM tools WITH document tools (legacy - for backwards compatibility)
const CRM_TOOLS_WITH_DOCUMENTS = [...CRM_TOOLS, ...DOCUMENT_TOOLS_ARRAY];

// CRM tools WITHOUT document tools - for Globe/Global mode
const CRM_ONLY_TOOLS = CRM_TOOLS;

// Document-only tools for DOCUMENT_SEARCH_MODE
const DOCUMENT_ONLY_TOOLS = [
  {
    name: 'list_indexed_documents',
    description: 'List all documents that have been indexed and are available for searching. Call this to see what documents exist.',
    input_schema: {
      type: 'object',
      properties: {},
    },
  },
  {
    name: 'search_document',
    description: 'Search within an indexed document to find relevant information. IMPORTANT: You must ONLY report information that appears in the search results. NEVER make up or invent details.',
    input_schema: {
      type: 'object',
      properties: {
        documentId: { type: 'string', description: 'The ID of the document to search (from list_indexed_documents)' },
        query: { type: 'string', description: 'The search query - what information to find in the document' },
        maxResults: { type: 'number', description: 'Maximum number of relevant sections to return (default: 5)' },
      },
      required: ['documentId', 'query'],
    },
  },
  {
    name: 'get_document_structure',
    description: 'Get the full hierarchical structure (table of contents) of an indexed document.',
    input_schema: {
      type: 'object',
      properties: {
        documentId: { type: 'string', description: 'The ID of the document to get structure for' },
      },
      required: ['documentId'],
    },
  },
  {
    name: 'get_document_summary',
    description: 'Get a comprehensive summary of an indexed document including all section summaries.',
    input_schema: {
      type: 'object',
      properties: {
        documentId: { type: 'string', description: 'The ID of the document to summarize' },
      },
      required: ['documentId'],
    },
  },
];

// System prompt for document-only search mode
const DOCUMENT_MODE_SYSTEM_PROMPT = `You are a document search assistant. The user has enabled DOCUMENT SEARCH MODE, which means they ONLY want information from their uploaded documents.

CURRENT DATE AND TIME: {{CURRENT_DATE_TIME}}
Use this for calculating dates like "tomorrow", "next week", "this month", etc. Never ask the user what today's date is.

ANTI-HALLUCINATION RULES (CRITICAL - NEVER VIOLATE):
1. ONLY quote or reference text that was ACTUALLY returned by search_document or get_document_summary tools. NEVER invent document content.
2. If a search returns specific sections, only reference those exact sections - never fabricate additional content.
3. All quotes, numbers, dates, and facts must be COPIED EXACTLY from tool results - never paraphrased in a way that changes meaning.
4. If you don't have data from a tool result, say "I couldn't find that in the documents" - NEVER guess or make up content.
5. Page numbers, section titles, and document names must match exactly what was returned by tools.

CRITICAL RULES:
1. You may ONLY respond with information found in the user's uploaded documents
2. You MUST use the document tools (list_indexed_documents, search_document, get_document_summary, get_document_structure) to find information
3. NEVER answer from your general knowledge - ONLY from document search results
4. If the user asks something that cannot be found in documents, say "I couldn't find that information in your uploaded documents. Would you like me to search for something else?"
5. Always cite which document the information came from

WORKFLOW:
1. First call list_indexed_documents to see what documents are available
2. Then use search_document or get_document_summary to find the specific information
3. ONLY report what the search results contain - never make up content

RESPONSE FORMAT:
- Keep responses focused on document content only
- Always mention the source document name
- If no relevant content found, clearly state that
- Never provide information from outside the documents
- Use markdown for structure: ## headers, **bold**, bullet lists
- NEVER use emojis - this is a professional enterprise application`;

// =============================================================================
// SALESFORCE CRM MODE - External CRM Integration
// =============================================================================

// Salesforce-specific tools for direct CRM operations
const SALESFORCE_TOOLS = [
  {
    name: 'sf_query',
    description: 'Execute a SOQL query against Salesforce. IMPORTANT: (1) ALWAYS include Name field so users can identify records. (2) Use NULLS LAST when ordering by numeric fields like Amount.',
    input_schema: {
      type: 'object',
      properties: {
        query: { type: 'string', description: 'The SOQL query. Example: SELECT Id, Name, Amount FROM Opportunity ORDER BY Amount DESC NULLS LAST LIMIT 10' },
      },
      required: ['query'],
    },
  },
  {
    name: 'sf_create_lead',
    description: 'Create a new Lead record in Salesforce. Accepts any valid Lead field including custom fields - use sf_describe_object to see all available fields. Common fields: FirstName, LastName (required), Company (required), Email, Phone, Title, Industry, LeadSource, Status, Street, City, State, PostalCode, Country, Description, etc.',
    input_schema: {
      type: 'object',
      properties: {
        LastName: { type: 'string', description: 'Lead last name (required)' },
        Company: { type: 'string', description: 'Company name (required)' },
      },
      additionalProperties: true,
      required: ['LastName', 'Company'],
    },
  },
  {
    name: 'sf_update_lead',
    description: 'Update an existing Lead record in Salesforce. Accepts any valid Lead field - use sf_describe_object to see all available fields. Common fields: FirstName, LastName, Company, Email, Phone, Title, Status, Street, City, State, PostalCode, Country, Industry, Rating, etc.',
    input_schema: {
      type: 'object',
      properties: {
        leadId: { type: 'string', description: 'The Salesforce Lead ID (18-character ID)' },
      },
      additionalProperties: true,
      required: ['leadId'],
    },
  },
  {
    name: 'sf_create_opportunity',
    description: 'Create a new Opportunity record in Salesforce. Accepts any valid Opportunity field including custom fields - use sf_describe_object to see all available fields. Common fields: Name (required), AccountId, Amount, CloseDate (required), StageName (required), Probability, Type, LeadSource, Description, NextStep, etc.',
    input_schema: {
      type: 'object',
      properties: {
        Name: { type: 'string', description: 'Opportunity name (required)' },
        CloseDate: { type: 'string', description: 'Expected close date (YYYY-MM-DD format, required)' },
        StageName: { type: 'string', description: 'Sales stage (e.g., Prospecting, Qualification, Proposal, Negotiation, Closed Won, Closed Lost) (required)' },
      },
      additionalProperties: true,
      required: ['Name', 'CloseDate', 'StageName'],
    },
  },
  {
    name: 'sf_update_opportunity',
    description: 'Update an Opportunity in Salesforce. CRITICAL REQUIREMENTS: (1) You MUST have the Salesforce Opportunity ID (starts with 006). If you only have the opportunity NAME, FIRST use sf_query to get the ID: SELECT Id, Name, StageName FROM Opportunity WHERE Name LIKE \'%OpportunityName%\'. (2) You MUST know the NEW VALUE before calling. If user says "update the stage" without specifying WHICH stage, DO NOT call - ASK user which stage they want. (3) NEVER use an Account ID (starts with 001) - you need the OPPORTUNITY ID (starts with 006).',
    input_schema: {
      type: 'object',
      properties: {
        opportunityId: { type: 'string', description: 'The Salesforce Opportunity ID (18-character, starts with 006). NOT the Account ID.' },
      },
      additionalProperties: true,
      required: ['opportunityId'],
    },
  },
  {
    name: 'sf_create_contact',
    description: 'Create a new Contact record in Salesforce. Accepts any valid Contact field including custom fields - use sf_describe_object to see all available fields. Common fields: FirstName, LastName (required), AccountId, Email, Phone, MobilePhone, Title, Department, MailingStreet, MailingCity, MailingState, MailingPostalCode, MailingCountry, Description, etc.',
    input_schema: {
      type: 'object',
      properties: {
        LastName: { type: 'string', description: 'Contact last name (required)' },
      },
      additionalProperties: true,
      required: ['LastName'],
    },
  },
  {
    name: 'sf_update_contact',
    description: 'Update an existing Contact record in Salesforce. Accepts any valid Contact field including custom fields - use sf_describe_object to see all available fields. Common fields: FirstName, LastName, AccountId, Email, Phone, MobilePhone, Title, Department, MailingStreet, MailingCity, MailingState, MailingPostalCode, MailingCountry, Description, etc.',
    input_schema: {
      type: 'object',
      properties: {
        contactId: { type: 'string', description: 'The Salesforce Contact ID (18-character ID)' },
      },
      additionalProperties: true,
      required: ['contactId'],
    },
  },
  {
    name: 'sf_create_account',
    description: 'Create a new Account record in Salesforce. Accepts any valid Account field including custom fields - use sf_describe_object to see all available fields. Common fields: Name (required), Type, Industry, Phone, Website, AnnualRevenue, NumberOfEmployees, BillingStreet, BillingCity, BillingState, BillingPostalCode, BillingCountry, Description, etc.',
    input_schema: {
      type: 'object',
      properties: {
        Name: { type: 'string', description: 'Account name (required)' },
      },
      additionalProperties: true,
      required: ['Name'],
    },
  },
  {
    name: 'sf_create_task',
    description: 'Create a new Task record in Salesforce to track follow-ups, calls, or to-dos. Accepts any valid Task field including custom fields - use sf_describe_object to see all available fields. Common fields: Subject (required), WhoId (Contact/Lead ID), WhatId (Account/Opportunity ID), ActivityDate, Status, Priority, Description, Type, etc.',
    input_schema: {
      type: 'object',
      properties: {
        Subject: { type: 'string', description: 'Task subject (required)' },
      },
      additionalProperties: true,
      required: ['Subject'],
    },
  },
  {
    name: 'get_iris_task',
    description: 'Get a local IRIS task by ID. IMPORTANT: Use this tool when the task ID starts with "cm" (e.g., cmk1k2m4q...) - these are local IRIS CUID format IDs, NOT Salesforce IDs. Salesforce IDs start with "00T" or similar prefixes. If a user asks about a task with ID starting with "cm", always use this tool instead of sf_get_record.',
    input_schema: {
      type: 'object',
      properties: {
        taskId: { type: 'string', description: 'The IRIS task ID (starts with "cm...")' },
      },
      required: ['taskId'],
    },
  },
  {
    name: 'list_iris_tasks',
    description: 'List local IRIS tasks. Use this to see tasks created in IRIS (not Salesforce). Useful for checking overdue tasks, pending tasks, etc. Task IDs from this tool start with "cm" (CUID format).',
    input_schema: {
      type: 'object',
      properties: {
        status: { type: 'string', enum: ['NOT_STARTED', 'IN_PROGRESS', 'COMPLETED', 'DEFERRED'], description: 'Filter by task status' },
        limit: { type: 'number', description: 'Maximum number of tasks to return (default: 20)' },
      },
    },
  },
  {
    name: 'sf_describe_object',
    description: 'Get metadata about a Salesforce object including available fields, picklist values, and relationships. Use this to understand what fields are available before creating or querying records.',
    input_schema: {
      type: 'object',
      properties: {
        objectType: { type: 'string', description: 'The Salesforce object API name (e.g., Lead, Contact, Account, Opportunity, Task, Case)' },
      },
      required: ['objectType'],
    },
  },
  {
    name: 'sf_get_record',
    description: 'Get a single Salesforce record by ID with all its field values.',
    input_schema: {
      type: 'object',
      properties: {
        objectType: { type: 'string', description: 'The Salesforce object API name (e.g., Lead, Contact, Account, Opportunity)' },
        recordId: { type: 'string', description: 'The Salesforce record ID (18-character ID)' },
        fields: { type: 'string', description: 'Comma-separated list of field names to retrieve. If not specified, returns common fields.' },
      },
      required: ['objectType', 'recordId'],
    },
  },
  {
    name: 'sf_update_record',
    description: 'Update any Salesforce record. CRITICAL: You MUST know the exact NEW VALUES before calling. If user says "update the stage/status" without specifying the target value, DO NOT call - ASK user what value they want (use sf_describe_object to get valid picklist options).',
    input_schema: {
      type: 'object',
      properties: {
        objectType: { type: 'string', description: 'The Salesforce object API name (e.g., Lead, Contact, Account, Opportunity, Task, Case)' },
        recordId: { type: 'string', description: 'The Salesforce record ID (18-character ID)' },
        fields: { 
          type: 'object', 
          description: 'Object containing field names and values to update. Field names must match Salesforce API names exactly (e.g., FirstName, LastName, Street, City, State, PostalCode, Country, Email, Phone, Status, etc.)',
          additionalProperties: true
        },
      },
      required: ['objectType', 'recordId', 'fields'],
    },
  },
  {
    name: 'sf_create_record',
    description: 'Create any Salesforce record with any fields. Use sf_describe_object first to see available and required fields. This is the most flexible way to create records.',
    input_schema: {
      type: 'object',
      properties: {
        objectType: { type: 'string', description: 'The Salesforce object API name (e.g., Lead, Contact, Account, Opportunity, Task, Case, Event)' },
        fields: { 
          type: 'object', 
          description: 'Object containing field names and values for the new record. Field names must match Salesforce API names. Check required fields with sf_describe_object first.',
          additionalProperties: true
        },
      },
      required: ['objectType', 'fields'],
    },
  },
  // =============================================================================
  // ADMIN/CONFIG TOOLS - Tooling API & Setup Operations
  // =============================================================================
  {
    name: 'sf_tooling_query',
    description: 'Execute a Tooling API SOQL query to retrieve setup/config metadata like custom fields, validation rules, flows, Apex classes, etc.',
    input_schema: {
      type: 'object',
      properties: {
        query: { type: 'string', description: 'The Tooling API SOQL query. Example: SELECT Id, DeveloperName FROM CustomField WHERE TableEnumOrId = \'Account\'' },
      },
      required: ['query'],
    },
  },
  {
    name: 'sf_list_users',
    description: 'List active users in the Salesforce org with their profiles and roles.',
    input_schema: {
      type: 'object',
      properties: {
        limit: { type: 'number', description: 'Maximum number of users to return (default: 50)' },
      },
    },
  },
  {
    name: 'sf_list_profiles',
    description: 'List all profiles in the Salesforce org.',
    input_schema: {
      type: 'object',
      properties: {},
    },
  },
  {
    name: 'sf_list_permission_sets',
    description: 'List custom permission sets in the Salesforce org.',
    input_schema: {
      type: 'object',
      properties: {},
    },
  },
  {
    name: 'sf_assign_permission_set',
    description: 'Assign a permission set to a user.',
    input_schema: {
      type: 'object',
      properties: {
        assigneeId: { type: 'string', description: 'The User ID to assign the permission set to' },
        permissionSetId: { type: 'string', description: 'The Permission Set ID to assign' },
      },
      required: ['assigneeId', 'permissionSetId'],
    },
  },
  {
    name: 'sf_list_custom_fields',
    description: 'List custom fields on a Salesforce object.',
    input_schema: {
      type: 'object',
      properties: {
        objectName: { type: 'string', description: 'The object API name (e.g., Account, Lead, Opportunity)' },
      },
      required: ['objectName'],
    },
  },
  {
    name: 'sf_list_validation_rules',
    description: 'List validation rules on a Salesforce object.',
    input_schema: {
      type: 'object',
      properties: {
        objectName: { type: 'string', description: 'The object API name (e.g., Account, Lead)' },
      },
      required: ['objectName'],
    },
  },
  {
    name: 'sf_toggle_validation_rule',
    description: 'Activate or deactivate a validation rule.',
    input_schema: {
      type: 'object',
      properties: {
        validationRuleId: { type: 'string', description: 'The Validation Rule ID' },
        active: { type: 'boolean', description: 'Set to true to activate, false to deactivate' },
      },
      required: ['validationRuleId', 'active'],
    },
  },
  {
    name: 'sf_list_flows',
    description: 'List Process Builder processes and Flows in the org.',
    input_schema: {
      type: 'object',
      properties: {
        activeOnly: { type: 'boolean', description: 'Only show active flows (default: true)' },
      },
    },
  },
  {
    name: 'sf_list_record_types',
    description: 'List record types for a Salesforce object.',
    input_schema: {
      type: 'object',
      properties: {
        objectName: { type: 'string', description: 'The object API name (e.g., Account, Opportunity)' },
      },
      required: ['objectName'],
    },
  },
  {
    name: 'sf_get_org_limits',
    description: 'Get current org limits and usage (API calls, storage, etc.).',
    input_schema: {
      type: 'object',
      properties: {},
    },
  },
  {
    name: 'sf_list_apex_classes',
    description: 'List Apex classes in the org.',
    input_schema: {
      type: 'object',
      properties: {
        limit: { type: 'number', description: 'Maximum number of classes to return (default: 100)' },
      },
    },
  },
  {
    name: 'sf_list_apex_triggers',
    description: 'List Apex triggers, optionally filtered by object.',
    input_schema: {
      type: 'object',
      properties: {
        objectName: { type: 'string', description: 'Filter triggers by object (optional)' },
      },
    },
  },
  {
    name: 'sf_run_apex_tests',
    description: 'Run Apex tests. Can run all local tests or a specific test class.',
    input_schema: {
      type: 'object',
      properties: {
        testClassId: { type: 'string', description: 'Specific test class ID to run (optional - if not provided, runs all local tests)' },
      },
    },
  },
  {
    name: 'sf_list_installed_packages',
    description: 'List installed managed packages in the org.',
    input_schema: {
      type: 'object',
      properties: {},
    },
  },
  {
    name: 'sf_execute_apex',
    description: 'Execute anonymous Apex code. Use with caution - this runs code directly in the org.',
    input_schema: {
      type: 'object',
      properties: {
        apexCode: { type: 'string', description: 'The Apex code to execute' },
      },
      required: ['apexCode'],
    },
  },
  // =============================================================================
  // METADATA MODIFICATION TOOLS - Create/Update Schema Elements
  // =============================================================================
  {
    name: 'sf_create_custom_field',
    description: 'Create a new custom field on a Salesforce object. Supports: Text, Number, Checkbox, Picklist, Date, DateTime, Email, Phone, URL, TextArea, LongTextArea, Currency, Percent, Lookup, MasterDetail. IMPORTANT: Always ask user to confirm before creating fields as this modifies the org schema.',
    input_schema: {
      type: 'object',
      properties: {
        objectName: { type: 'string', description: 'The object API name to add the field to (e.g., Account, Lead, Custom_Object__c)' },
        fullName: { type: 'string', description: 'API name for the field (e.g., My_Custom_Field). Will automatically append __c if not present.' },
        label: { type: 'string', description: 'User-friendly label for the field (e.g., "My Custom Field")' },
        type: { type: 'string', enum: ['Text', 'Number', 'Checkbox', 'Picklist', 'Date', 'DateTime', 'Email', 'Phone', 'URL', 'TextArea', 'LongTextArea', 'Currency', 'Percent', 'Lookup', 'MasterDetail'], description: 'The field data type' },
        length: { type: 'number', description: 'For Text fields: max length (1-255). For LongTextArea: max length (up to 131072)' },
        precision: { type: 'number', description: 'For Number/Currency/Percent: total digits (including decimals)' },
        scale: { type: 'number', description: 'For Number/Currency/Percent: decimal places' },
        required: { type: 'boolean', description: 'Whether the field is required' },
        unique: { type: 'boolean', description: 'Whether values must be unique' },
        description: { type: 'string', description: 'Description of the field' },
        helpText: { type: 'string', description: 'Help text shown to users' },
        picklistValues: { type: 'array', items: { type: 'string' }, description: 'For Picklist type: list of allowed values' },
        referenceTo: { type: 'string', description: 'For Lookup/MasterDetail: the object to reference (e.g., Account, Contact)' },
        relationshipLabel: { type: 'string', description: 'For Lookup/MasterDetail: label for the child relationship' },
        defaultValue: { type: 'string', description: 'Default value for the field' },
      },
      required: ['objectName', 'fullName', 'label', 'type'],
    },
  },
  {
    name: 'sf_create_custom_object',
    description: 'Create a new custom object in Salesforce. IMPORTANT: This is a significant schema change - always confirm with the user before creating objects.',
    input_schema: {
      type: 'object',
      properties: {
        fullName: { type: 'string', description: 'API name for the object (e.g., Project). Will automatically append __c if not present.' },
        label: { type: 'string', description: 'Singular label (e.g., "Project")' },
        pluralLabel: { type: 'string', description: 'Plural label (e.g., "Projects")' },
        description: { type: 'string', description: 'Description of the object' },
        nameFieldType: { type: 'string', enum: ['Text', 'AutoNumber'], description: 'Type of the Name field (default: Text)' },
        nameFieldLabel: { type: 'string', description: 'Label for the Name field (default: "[Object] Name")' },
        nameFieldFormat: { type: 'string', description: 'For AutoNumber: format like "PRJ-{0000}"' },
        allowReports: { type: 'boolean', description: 'Allow reports (default: true)' },
        allowActivities: { type: 'boolean', description: 'Allow activities (default: true)' },
        allowSearch: { type: 'boolean', description: 'Allow search (default: true)' },
        sharingModel: { type: 'string', enum: ['Private', 'Read', 'ReadWrite'], description: 'Sharing model (default: ReadWrite)' },
      },
      required: ['fullName', 'label', 'pluralLabel'],
    },
  },
  {
    name: 'sf_create_validation_rule',
    description: 'Create a validation rule on a Salesforce object. The formula should return TRUE when the record is INVALID. IMPORTANT: Test formula logic carefully before deploying.',
    input_schema: {
      type: 'object',
      properties: {
        objectName: { type: 'string', description: 'The object API name (e.g., Lead, Account)' },
        name: { type: 'string', description: 'API name for the rule (e.g., Require_Email_or_Phone)' },
        description: { type: 'string', description: 'Description of what the rule validates' },
        errorConditionFormula: { type: 'string', description: 'Formula that returns TRUE when record is INVALID. Example: AND(ISBLANK(Email), ISBLANK(Phone))' },
        errorMessage: { type: 'string', description: 'Error message shown when validation fails' },
        errorDisplayField: { type: 'string', description: 'Field to display the error on (optional)' },
        active: { type: 'boolean', description: 'Whether to activate the rule immediately (default: true)' },
      },
      required: ['objectName', 'name', 'errorConditionFormula', 'errorMessage'],
    },
  },
  {
    name: 'sf_add_picklist_values',
    description: 'Add new values to an existing picklist field. Use this to extend picklist options without replacing existing values.',
    input_schema: {
      type: 'object',
      properties: {
        objectName: { type: 'string', description: 'The object API name (e.g., Lead, Opportunity)' },
        fieldName: { type: 'string', description: 'The picklist field API name' },
        newValues: { type: 'array', items: { type: 'string' }, description: 'New picklist values to add' },
      },
      required: ['objectName', 'fieldName', 'newValues'],
    },
  },
  {
    name: 'sf_update_field_level_security',
    description: 'Update field-level security for a profile. Makes a field visible and/or editable for a specific profile.',
    input_schema: {
      type: 'object',
      properties: {
        profileName: { type: 'string', description: 'The profile name (e.g., "Standard User", "System Administrator")' },
        objectName: { type: 'string', description: 'The object API name' },
        fieldName: { type: 'string', description: 'The field API name' },
        readable: { type: 'boolean', description: 'Whether the field should be visible' },
        editable: { type: 'boolean', description: 'Whether the field should be editable' },
      },
      required: ['profileName', 'objectName', 'fieldName', 'readable', 'editable'],
    },
  },
  {
    name: 'sf_validate_metadata',
    description: 'Validate metadata changes before deploying. Use this to check for errors before creating fields, objects, or rules.',
    input_schema: {
      type: 'object',
      properties: {
        metadataType: { type: 'string', enum: ['CustomField', 'CustomObject', 'ValidationRule'], description: 'Type of metadata to validate' },
        metadata: { type: 'object', description: 'The metadata definition to validate', additionalProperties: true },
      },
      required: ['metadataType', 'metadata'],
    },
  },
  // =============================================================================
  // EXTENDED ADMIN TOOLS - Users, Roles, Groups, Flows, Bulk Operations, etc.
  // =============================================================================
  {
    name: 'sf_toggle_flow',
    description: 'Activate or deactivate a Flow. Use sf_list_flows first to get the Flow ID.',
    input_schema: {
      type: 'object',
      properties: {
        flowId: { type: 'string', description: 'The Flow Definition ID' },
        activate: { type: 'boolean', description: 'True to activate, false to deactivate' },
      },
      required: ['flowId', 'activate'],
    },
  },
  {
    name: 'sf_create_user',
    description: 'Create a new user in the Salesforce org. IMPORTANT: Requires user management permissions and available licenses.',
    input_schema: {
      type: 'object',
      properties: {
        username: { type: 'string', description: 'Unique username (usually email format with org suffix)' },
        email: { type: 'string', description: 'User email address' },
        firstName: { type: 'string', description: 'First name' },
        lastName: { type: 'string', description: 'Last name' },
        alias: { type: 'string', description: 'User alias (max 8 chars)' },
        profileId: { type: 'string', description: 'Profile ID - use sf_list_profiles to find' },
        roleId: { type: 'string', description: 'Role ID (optional) - use sf_list_roles to find' },
        timeZone: { type: 'string', description: 'Time zone (default: America/Los_Angeles)' },
        isActive: { type: 'boolean', description: 'Whether user is active (default: true)' },
      },
      required: ['username', 'email', 'firstName', 'lastName', 'alias', 'profileId'],
    },
  },
  {
    name: 'sf_update_user',
    description: 'Update an existing user\'s details (profile, role, active status, etc.)',
    input_schema: {
      type: 'object',
      properties: {
        targetUserId: { type: 'string', description: 'The User ID to update' },
        email: { type: 'string', description: 'New email address' },
        firstName: { type: 'string', description: 'New first name' },
        lastName: { type: 'string', description: 'New last name' },
        profileId: { type: 'string', description: 'New Profile ID' },
        roleId: { type: 'string', description: 'New Role ID' },
        isActive: { type: 'boolean', description: 'Activate or deactivate user' },
        managerId: { type: 'string', description: 'Manager User ID' },
        title: { type: 'string', description: 'Job title' },
        department: { type: 'string', description: 'Department' },
      },
      required: ['targetUserId'],
    },
  },
  {
    name: 'sf_freeze_user',
    description: 'Freeze or unfreeze a user (prevents login without deactivating). Useful for temporary access suspension.',
    input_schema: {
      type: 'object',
      properties: {
        targetUserId: { type: 'string', description: 'The User ID to freeze/unfreeze' },
        freeze: { type: 'boolean', description: 'True to freeze, false to unfreeze' },
      },
      required: ['targetUserId', 'freeze'],
    },
  },
  {
    name: 'sf_reset_user_password',
    description: 'Reset a user\'s password. Sends a password reset email to the user.',
    input_schema: {
      type: 'object',
      properties: {
        targetUserId: { type: 'string', description: 'The User ID whose password to reset' },
      },
      required: ['targetUserId'],
    },
  },
  {
    name: 'sf_create_record_type',
    description: 'Create a new record type for an object. Enables different page layouts and picklist values for different business processes.',
    input_schema: {
      type: 'object',
      properties: {
        objectName: { type: 'string', description: 'The object API name (e.g., Opportunity, Case)' },
        name: { type: 'string', description: 'Record type name (e.g., "B2B Opportunity")' },
        developerName: { type: 'string', description: 'API name (e.g., "B2B_Opportunity")' },
        description: { type: 'string', description: 'Description of when to use this record type' },
        isActive: { type: 'boolean', description: 'Whether active immediately (default: true)' },
      },
      required: ['objectName', 'name', 'developerName'],
    },
  },
  {
    name: 'sf_update_record_type',
    description: 'Update an existing record type (name, description, active status).',
    input_schema: {
      type: 'object',
      properties: {
        recordTypeId: { type: 'string', description: 'The Record Type ID' },
        name: { type: 'string', description: 'New name' },
        description: { type: 'string', description: 'New description' },
        isActive: { type: 'boolean', description: 'Activate or deactivate' },
      },
      required: ['recordTypeId'],
    },
  },
  {
    name: 'sf_create_permission_set',
    description: 'Create a new permission set. Use this to grant additional permissions beyond what profiles provide.',
    input_schema: {
      type: 'object',
      properties: {
        name: { type: 'string', description: 'API name for the permission set' },
        label: { type: 'string', description: 'Display label' },
        description: { type: 'string', description: 'Description of the permission set' },
      },
      required: ['name', 'label'],
    },
  },
  {
    name: 'sf_add_object_permission_to_permset',
    description: 'Add object-level permissions (CRUD) to a permission set.',
    input_schema: {
      type: 'object',
      properties: {
        permissionSetId: { type: 'string', description: 'The Permission Set ID' },
        objectName: { type: 'string', description: 'The object API name' },
        read: { type: 'boolean', description: 'Allow read access' },
        create: { type: 'boolean', description: 'Allow create access' },
        edit: { type: 'boolean', description: 'Allow edit access' },
        delete: { type: 'boolean', description: 'Allow delete access' },
        viewAll: { type: 'boolean', description: 'View all records' },
        modifyAll: { type: 'boolean', description: 'Modify all records' },
      },
      required: ['permissionSetId', 'objectName'],
    },
  },
  {
    name: 'sf_revoke_permission_set',
    description: 'Remove a permission set assignment from a user.',
    input_schema: {
      type: 'object',
      properties: {
        assigneeId: { type: 'string', description: 'The User ID' },
        permissionSetId: { type: 'string', description: 'The Permission Set ID to revoke' },
      },
      required: ['assigneeId', 'permissionSetId'],
    },
  },
  {
    name: 'sf_update_custom_field',
    description: 'Update an existing custom field\'s properties (label, description, help text, required).',
    input_schema: {
      type: 'object',
      properties: {
        objectName: { type: 'string', description: 'The object API name' },
        fieldName: { type: 'string', description: 'The field API name' },
        label: { type: 'string', description: 'New label' },
        description: { type: 'string', description: 'New description' },
        helpText: { type: 'string', description: 'New help text' },
        required: { type: 'boolean', description: 'Make field required or not' },
        defaultValue: { type: 'string', description: 'New default value' },
      },
      required: ['objectName', 'fieldName'],
    },
  },
  {
    name: 'sf_delete_custom_field',
    description: 'Delete a custom field. WARNING: This permanently removes the field and its data.',
    input_schema: {
      type: 'object',
      properties: {
        objectName: { type: 'string', description: 'The object API name' },
        fieldName: { type: 'string', description: 'The custom field API name to delete' },
      },
      required: ['objectName', 'fieldName'],
    },
  },
  {
    name: 'sf_delete_custom_object',
    description: 'Delete a custom object. WARNING: This permanently removes the object and all its data.',
    input_schema: {
      type: 'object',
      properties: {
        objectName: { type: 'string', description: 'The custom object API name to delete' },
      },
      required: ['objectName'],
    },
  },
  {
    name: 'sf_update_validation_rule',
    description: 'Update an existing validation rule (formula, message, active status).',
    input_schema: {
      type: 'object',
      properties: {
        validationRuleId: { type: 'string', description: 'The Validation Rule ID' },
        description: { type: 'string', description: 'New description' },
        errorConditionFormula: { type: 'string', description: 'New formula (returns TRUE when invalid)' },
        errorMessage: { type: 'string', description: 'New error message' },
        errorDisplayField: { type: 'string', description: 'Field to display error on' },
        active: { type: 'boolean', description: 'Activate or deactivate' },
      },
      required: ['validationRuleId'],
    },
  },
  {
    name: 'sf_delete_validation_rule',
    description: 'Delete a validation rule.',
    input_schema: {
      type: 'object',
      properties: {
        validationRuleId: { type: 'string', description: 'The Validation Rule ID to delete' },
      },
      required: ['validationRuleId'],
    },
  },
  {
    name: 'sf_list_roles',
    description: 'List all roles in the org hierarchy.',
    input_schema: {
      type: 'object',
      properties: {},
    },
  },
  {
    name: 'sf_create_role',
    description: 'Create a new role in the role hierarchy.',
    input_schema: {
      type: 'object',
      properties: {
        name: { type: 'string', description: 'Role name' },
        developerName: { type: 'string', description: 'API name' },
        parentRoleId: { type: 'string', description: 'Parent role ID (optional)' },
      },
      required: ['name', 'developerName'],
    },
  },
  {
    name: 'sf_list_groups',
    description: 'List public groups and queues in the org.',
    input_schema: {
      type: 'object',
      properties: {},
    },
  },
  {
    name: 'sf_create_group',
    description: 'Create a public group for sharing rules or email distribution.',
    input_schema: {
      type: 'object',
      properties: {
        name: { type: 'string', description: 'Group name' },
        developerName: { type: 'string', description: 'API name' },
        type: { type: 'string', enum: ['Regular', 'Queue'], description: 'Group type (default: Regular)' },
      },
      required: ['name', 'developerName'],
    },
  },
  {
    name: 'sf_add_group_member',
    description: 'Add a user or group to a public group.',
    input_schema: {
      type: 'object',
      properties: {
        groupId: { type: 'string', description: 'The Group ID' },
        memberId: { type: 'string', description: 'User or Group ID to add' },
      },
      required: ['groupId', 'memberId'],
    },
  },
  {
    name: 'sf_create_queue',
    description: 'Create a queue for case or lead assignment routing.',
    input_schema: {
      type: 'object',
      properties: {
        name: { type: 'string', description: 'Queue name' },
        developerName: { type: 'string', description: 'API name' },
        supportedObjects: { type: 'array', items: { type: 'string' }, description: 'Objects the queue supports (e.g., ["Case", "Lead"])' },
        email: { type: 'string', description: 'Queue email address (optional)' },
      },
      required: ['name', 'developerName', 'supportedObjects'],
    },
  },
  {
    name: 'sf_list_email_templates',
    description: 'List email templates in the org.',
    input_schema: {
      type: 'object',
      properties: {
        folderId: { type: 'string', description: 'Filter by folder ID (optional)' },
      },
    },
  },
  {
    name: 'sf_create_email_template',
    description: 'Create an email template.',
    input_schema: {
      type: 'object',
      properties: {
        name: { type: 'string', description: 'Template name' },
        developerName: { type: 'string', description: 'API name' },
        subject: { type: 'string', description: 'Email subject line' },
        htmlBody: { type: 'string', description: 'HTML body content' },
        textBody: { type: 'string', description: 'Plain text body (optional)' },
        description: { type: 'string', description: 'Template description' },
      },
      required: ['name', 'developerName', 'subject', 'htmlBody'],
    },
  },
  {
    name: 'sf_get_schema_overview',
    description: 'Get a comprehensive schema overview for an object including required fields, custom fields, relationships, and record types. Optimized for understanding the data model.',
    input_schema: {
      type: 'object',
      properties: {
        objectName: { type: 'string', description: 'The object API name' },
      },
      required: ['objectName'],
    },
  },
  {
    name: 'sf_get_picklist_values',
    description: 'Get all picklist values for a specific field including active/inactive and default status.',
    input_schema: {
      type: 'object',
      properties: {
        objectName: { type: 'string', description: 'The object API name' },
        fieldName: { type: 'string', description: 'The picklist field name' },
      },
      required: ['objectName', 'fieldName'],
    },
  },
  {
    name: 'sf_bulk_create',
    description: 'Create multiple records at once (up to 200). More efficient than individual creates.',
    input_schema: {
      type: 'object',
      properties: {
        objectType: { type: 'string', description: 'The object API name' },
        records: { type: 'array', items: { type: 'object' }, description: 'Array of record data objects' },
        allOrNone: { type: 'boolean', description: 'If true, fail all if any fail (default: false)' },
      },
      required: ['objectType', 'records'],
    },
  },
  {
    name: 'sf_bulk_update',
    description: 'Update multiple records at once (up to 200). Each record must include an "id" field.',
    input_schema: {
      type: 'object',
      properties: {
        objectType: { type: 'string', description: 'The object API name' },
        records: { type: 'array', items: { type: 'object' }, description: 'Array of {id, ...fields} objects' },
        allOrNone: { type: 'boolean', description: 'If true, fail all if any fail (default: false)' },
      },
      required: ['objectType', 'records'],
    },
  },
  {
    name: 'sf_bulk_delete',
    description: 'Delete multiple records at once (up to 200).',
    input_schema: {
      type: 'object',
      properties: {
        recordIds: { type: 'array', items: { type: 'string' }, description: 'Array of record IDs to delete' },
        allOrNone: { type: 'boolean', description: 'If true, fail all if any fail (default: false)' },
      },
      required: ['recordIds'],
    },
  },
  {
    name: 'sf_get_record_count',
    description: 'Get the count of records for an object, optionally with a WHERE filter.',
    input_schema: {
      type: 'object',
      properties: {
        objectName: { type: 'string', description: 'The object API name' },
        whereClause: { type: 'string', description: 'Optional WHERE clause (without WHERE keyword)' },
      },
      required: ['objectName'],
    },
  },
  {
    name: 'sf_clone_record',
    description: 'Clone an existing record with optional field overrides.',
    input_schema: {
      type: 'object',
      properties: {
        objectType: { type: 'string', description: 'The object API name' },
        recordId: { type: 'string', description: 'The record ID to clone' },
        fieldOverrides: { type: 'object', description: 'Fields to override in the clone' },
        excludeFields: { type: 'array', items: { type: 'string' }, description: 'Fields to exclude from clone' },
      },
      required: ['objectType', 'recordId'],
    },
  },
  {
    name: 'sf_get_org_info',
    description: 'Get comprehensive organization information including name, type, features, and limits.',
    input_schema: {
      type: 'object',
      properties: {},
    },
  },
  // =============================================================================
  // PAGE LAYOUT TOOLS
  // =============================================================================
  {
    name: 'sf_list_page_layouts',
    description: 'List all page layouts for a Salesforce object.',
    input_schema: {
      type: 'object',
      properties: {
        objectName: { type: 'string', description: 'The object API name (e.g., Account, Lead, Opportunity)' },
      },
      required: ['objectName'],
    },
  },
  {
    name: 'sf_get_page_layout',
    description: 'Get details of a specific page layout including sections and fields.',
    input_schema: {
      type: 'object',
      properties: {
        layoutId: { type: 'string', description: 'The page layout ID' },
      },
      required: ['layoutId'],
    },
  },
  {
    name: 'sf_create_page_layout',
    description: 'Create a new page layout for an object with sections and fields.',
    input_schema: {
      type: 'object',
      properties: {
        objectName: { type: 'string', description: 'The object API name' },
        name: { type: 'string', description: 'Name for the new layout' },
        sections: {
          type: 'array',
          items: {
            type: 'object',
            properties: {
              label: { type: 'string' },
              columns: { type: 'number' },
              fields: { type: 'array', items: { type: 'string' } },
            },
            required: ['label', 'fields'],
          },
          description: 'Layout sections with fields',
        },
      },
      required: ['objectName', 'name', 'sections'],
    },
  },
  {
    name: 'sf_update_page_layout',
    description: 'Update an existing page layout - add/remove fields or reorganize sections.',
    input_schema: {
      type: 'object',
      properties: {
        layoutId: { type: 'string', description: 'The page layout ID to update' },
        addFields: {
          type: 'object',
          properties: {
            sectionLabel: { type: 'string' },
            fields: { type: 'array', items: { type: 'string' } },
          },
          description: 'Fields to add to a section',
        },
        removeFields: { type: 'array', items: { type: 'string' }, description: 'Fields to remove from layout' },
      },
      required: ['layoutId'],
    },
  },
  // =============================================================================
  // APEX DEPLOYMENT TOOLS
  // =============================================================================
  {
    name: 'sf_deploy_apex_class',
    description: 'Deploy an Apex class to Salesforce. Creates new or updates existing class.',
    input_schema: {
      type: 'object',
      properties: {
        name: { type: 'string', description: 'The Apex class name (no spaces, alphanumeric + underscore)' },
        body: { type: 'string', description: 'The full Apex class code including class declaration' },
        apiVersion: { type: 'number', description: 'API version (default: 59.0)' },
      },
      required: ['name', 'body'],
    },
  },
  {
    name: 'sf_deploy_apex_trigger',
    description: 'Deploy an Apex trigger to Salesforce.',
    input_schema: {
      type: 'object',
      properties: {
        name: { type: 'string', description: 'The trigger name' },
        body: { type: 'string', description: 'The full trigger code' },
        objectName: { type: 'string', description: 'The object the trigger fires on (e.g., Account, Lead)' },
        apiVersion: { type: 'number', description: 'API version (default: 59.0)' },
      },
      required: ['name', 'body', 'objectName'],
    },
  },
  {
    name: 'sf_delete_apex_class',
    description: 'Delete an Apex class from Salesforce. WARNING: This is permanent.',
    input_schema: {
      type: 'object',
      properties: {
        classId: { type: 'string', description: 'The Apex class ID to delete' },
      },
      required: ['classId'],
    },
  },
  // =============================================================================
  // LIGHTNING WEB COMPONENT TOOLS
  // =============================================================================
  {
    name: 'sf_deploy_lwc',
    description: 'Deploy a Lightning Web Component to Salesforce.',
    input_schema: {
      type: 'object',
      properties: {
        name: { type: 'string', description: 'Component name (camelCase, e.g., myComponent)' },
        jsContent: { type: 'string', description: 'JavaScript file content' },
        htmlContent: { type: 'string', description: 'HTML template content (optional)' },
        cssContent: { type: 'string', description: 'CSS styles content (optional)' },
        metaXml: { type: 'string', description: 'Meta XML configuration (defines where component can be used)' },
        apiVersion: { type: 'number', description: 'API version (default: 59.0)' },
      },
      required: ['name', 'jsContent', 'metaXml'],
    },
  },
  {
    name: 'sf_list_lwc',
    description: 'List all Lightning Web Components in the org.',
    input_schema: {
      type: 'object',
      properties: {},
    },
  },
  {
    name: 'sf_delete_lwc',
    description: 'Delete a Lightning Web Component. WARNING: This is permanent.',
    input_schema: {
      type: 'object',
      properties: {
        bundleId: { type: 'string', description: 'The LWC bundle ID to delete' },
      },
      required: ['bundleId'],
    },
  },
  // =============================================================================
  // WORKFLOW RULES TOOLS (Legacy - Prefer Flows)
  // =============================================================================
  {
    name: 'sf_list_workflow_rules',
    description: 'List workflow rules, optionally filtered by object. Note: Workflow rules are legacy - prefer Flows for new automation.',
    input_schema: {
      type: 'object',
      properties: {
        objectName: { type: 'string', description: 'Filter by object API name (optional)' },
      },
    },
  },
  {
    name: 'sf_create_workflow_rule',
    description: 'Create a workflow rule. Note: Consider using Flows instead as workflow rules are being deprecated.',
    input_schema: {
      type: 'object',
      properties: {
        objectName: { type: 'string', description: 'Object API name for the rule' },
        name: { type: 'string', description: 'Rule name' },
        description: { type: 'string', description: 'Rule description' },
        triggerType: {
          type: 'string',
          enum: ['onAllChanges', 'onCreateOnly', 'onCreateOrTriggeringUpdate'],
          description: 'When the rule should fire',
        },
        formula: { type: 'string', description: 'Formula criteria for rule activation' },
        criteriaItems: {
          type: 'array',
          items: {
            type: 'object',
            properties: {
              field: { type: 'string' },
              operation: { type: 'string' },
              value: { type: 'string' },
            },
          },
          description: 'Filter-based criteria (alternative to formula)',
        },
      },
      required: ['objectName', 'name', 'triggerType'],
    },
  },
  {
    name: 'sf_delete_workflow_rule',
    description: 'Delete a workflow rule.',
    input_schema: {
      type: 'object',
      properties: {
        ruleId: { type: 'string', description: 'The workflow rule ID to delete' },
      },
      required: ['ruleId'],
    },
  },
  // =============================================================================
  // APPROVAL PROCESS TOOLS
  // =============================================================================
  {
    name: 'sf_list_approval_processes',
    description: 'List all approval processes, optionally filtered by object.',
    input_schema: {
      type: 'object',
      properties: {
        objectName: { type: 'string', description: 'Filter by object API name (optional)' },
      },
    },
  },
  {
    name: 'sf_create_approval_process',
    description: 'Create an approval process with steps and actions.',
    input_schema: {
      type: 'object',
      properties: {
        objectName: { type: 'string', description: 'Object API name' },
        name: { type: 'string', description: 'Process name' },
        description: { type: 'string', description: 'Process description' },
        entryCriteria: { type: 'string', description: 'Formula to determine which records enter the process' },
        approvalSteps: {
          type: 'array',
          items: {
            type: 'object',
            properties: {
              name: { type: 'string', description: 'Step name' },
              assignedTo: {
                type: 'object',
                properties: {
                  type: { type: 'string', enum: ['user', 'queue', 'relatedUser', 'manager'] },
                  assignee: { type: 'string', description: 'User/Queue ID or field API name' },
                },
              },
              rejectBehavior: { type: 'string', enum: ['RejectRequest', 'BackToPrevious'] },
            },
            required: ['name', 'assignedTo'],
          },
          description: 'Approval steps in order',
        },
        allowRecall: { type: 'boolean', description: 'Allow submitter to recall (default: true)' },
      },
      required: ['objectName', 'name', 'approvalSteps'],
    },
  },
  {
    name: 'sf_toggle_approval_process',
    description: 'Activate or deactivate an approval process.',
    input_schema: {
      type: 'object',
      properties: {
        processId: { type: 'string', description: 'The approval process ID' },
        active: { type: 'boolean', description: 'True to activate, false to deactivate' },
      },
      required: ['processId', 'active'],
    },
  },
  {
    name: 'sf_delete_approval_process',
    description: 'Delete an approval process. Must be deactivated first.',
    input_schema: {
      type: 'object',
      properties: {
        processId: { type: 'string', description: 'The approval process ID to delete' },
      },
      required: ['processId'],
    },
  },
  {
    name: 'sf_submit_for_approval',
    description: 'Submit a record for approval.',
    input_schema: {
      type: 'object',
      properties: {
        recordId: { type: 'string', description: 'The record ID to submit' },
        comments: { type: 'string', description: 'Submission comments' },
        processDefinitionNameOrId: { type: 'string', description: 'Specific process to use (optional)' },
      },
      required: ['recordId'],
    },
  },
  {
    name: 'sf_process_approval',
    description: 'Approve or reject a pending approval request.',
    input_schema: {
      type: 'object',
      properties: {
        workItemId: { type: 'string', description: 'The work item ID (from pending approvals)' },
        action: { type: 'string', enum: ['Approve', 'Reject'], description: 'Action to take' },
        comments: { type: 'string', description: 'Comments for the action' },
      },
      required: ['workItemId', 'action'],
    },
  },
  // =============================================================================
  // REPORTS & DASHBOARDS TOOLS
  // =============================================================================
  {
    name: 'sf_list_reports',
    description: 'List Salesforce reports with optional filtering.',
    input_schema: {
      type: 'object',
      properties: {
        folderId: { type: 'string', description: 'Filter by folder ID' },
        search: { type: 'string', description: 'Search by report name' },
      },
    },
  },
  {
    name: 'sf_get_report_metadata',
    description: 'Get detailed report metadata including columns, filters, and groupings.',
    input_schema: {
      type: 'object',
      properties: {
        reportId: { type: 'string', description: 'The report ID' },
      },
      required: ['reportId'],
    },
  },
  {
    name: 'sf_create_report',
    description: 'Create and SAVE a new persistent report IN SALESFORCE. Use this when user says "create a Salesforce report", "create a report in Salesforce", "save this as a Salesforce report", or "build me a SF report". This creates a saved report object in the Salesforce org that users can access from the Reports tab. Do NOT use sf_query for this - use this tool to create a persistent report.',
    input_schema: {
      type: 'object',
      properties: {
        name: { type: 'string', description: 'Report name - descriptive title for the report' },
        reportType: { type: 'string', description: 'Salesforce report type API name: AccountList, LeadList, OpportunityList, ContactList, or use sf_get_report_types to find others' },
        format: { type: 'string', enum: ['TABULAR', 'SUMMARY', 'MATRIX'], description: 'Report format' },
        columns: { type: 'array', items: { type: 'string' }, description: 'Field API names to include as columns' },
        filters: {
          type: 'array',
          items: {
            type: 'object',
            properties: {
              field: { type: 'string' },
              operator: { type: 'string' },
              value: { type: 'string' },
            },
          },
          description: 'Report filters',
        },
        groupings: {
          type: 'array',
          items: {
            type: 'object',
            properties: {
              field: { type: 'string' },
              sortOrder: { type: 'string', enum: ['Asc', 'Desc'] },
            },
          },
          description: 'Grouping fields (for SUMMARY/MATRIX)',
        },
        folderId: { type: 'string', description: 'Folder to save report in' },
        description: { type: 'string', description: 'Report description' },
      },
      required: ['name', 'reportType', 'format', 'columns'],
    },
  },
  {
    name: 'sf_run_report',
    description: 'Run a report and get results.',
    input_schema: {
      type: 'object',
      properties: {
        reportId: { type: 'string', description: 'The report ID to run' },
        includeDetails: { type: 'boolean', description: 'Include row-level details (default: true)' },
        filters: {
          type: 'array',
          items: {
            type: 'object',
            properties: {
              column: { type: 'string' },
              operator: { type: 'string' },
              value: { type: 'string' },
            },
          },
          description: 'Runtime filter overrides',
        },
      },
      required: ['reportId'],
    },
  },
  {
    name: 'sf_update_report',
    description: 'Update an existing report.',
    input_schema: {
      type: 'object',
      properties: {
        reportId: { type: 'string', description: 'The report ID to update' },
        name: { type: 'string', description: 'New report name' },
        columns: { type: 'array', items: { type: 'string' }, description: 'New columns' },
        filters: { type: 'array', description: 'New filters' },
        groupings: { type: 'array', description: 'New groupings' },
      },
      required: ['reportId'],
    },
  },
  {
    name: 'sf_delete_report',
    description: 'Delete a report.',
    input_schema: {
      type: 'object',
      properties: {
        reportId: { type: 'string', description: 'The report ID to delete' },
      },
      required: ['reportId'],
    },
  },
  {
    name: 'sf_list_dashboards',
    description: 'List Salesforce dashboards.',
    input_schema: {
      type: 'object',
      properties: {
        folderId: { type: 'string', description: 'Filter by folder ID' },
        search: { type: 'string', description: 'Search by dashboard name' },
      },
    },
  },
  {
    name: 'sf_get_dashboard_metadata',
    description: 'Get dashboard metadata including components.',
    input_schema: {
      type: 'object',
      properties: {
        dashboardId: { type: 'string', description: 'The dashboard ID' },
      },
      required: ['dashboardId'],
    },
  },
  {
    name: 'sf_create_dashboard',
    description: 'Create a new dashboard with components.',
    input_schema: {
      type: 'object',
      properties: {
        name: { type: 'string', description: 'Dashboard name' },
        description: { type: 'string', description: 'Dashboard description' },
        folderId: { type: 'string', description: 'Folder to save dashboard in' },
        components: {
          type: 'array',
          items: {
            type: 'object',
            properties: {
              reportId: { type: 'string', description: 'Source report ID' },
              type: { type: 'string', enum: ['Chart', 'Gauge', 'Metric', 'Table'], description: 'Component type' },
              header: { type: 'string', description: 'Component title' },
              position: {
                type: 'object',
                properties: {
                  row: { type: 'number' },
                  column: { type: 'number' },
                  rowSpan: { type: 'number' },
                  columnSpan: { type: 'number' },
                },
              },
            },
            required: ['reportId', 'type', 'position'],
          },
          description: 'Dashboard components',
        },
        runningUser: { type: 'string', description: 'User ID to run dashboard as (optional)' },
      },
      required: ['name', 'folderId', 'components'],
    },
  },
  {
    name: 'sf_refresh_dashboard',
    description: 'Refresh dashboard data.',
    input_schema: {
      type: 'object',
      properties: {
        dashboardId: { type: 'string', description: 'The dashboard ID to refresh' },
      },
      required: ['dashboardId'],
    },
  },
  {
    name: 'sf_delete_dashboard',
    description: 'Delete a dashboard.',
    input_schema: {
      type: 'object',
      properties: {
        dashboardId: { type: 'string', description: 'The dashboard ID to delete' },
      },
      required: ['dashboardId'],
    },
  },
  {
    name: 'sf_list_report_folders',
    description: 'List report folders.',
    input_schema: {
      type: 'object',
      properties: {},
    },
  },
  {
    name: 'sf_list_dashboard_folders',
    description: 'List dashboard folders.',
    input_schema: {
      type: 'object',
      properties: {},
    },
  },
  {
    name: 'sf_get_report_types',
    description: 'Get available report types for creating reports.',
    input_schema: {
      type: 'object',
      properties: {},
    },
  },
  // =============================================================================
  // ANALYTICS TOOLS - Dynamic Metric Computation
  // =============================================================================
  {
    name: 'compute_analytics',
    description: 'Compute sales analytics and metrics from CRM data. Use this AFTER querying data with sf_query to calculate: cycle time (avg time between dates), conversion rates, win rates, average deal size, pipeline velocity, stage distribution, activity frequency, AND source analysis (lead source investigation). This tool takes raw CRM records and computes the requested metric automatically.',
    input_schema: {
      type: 'object',
      properties: {
        metricType: {
          type: 'string',
          enum: ['cycle_time', 'conversion_rate', 'win_rate', 'average_deal_size', 'pipeline_velocity', 'stage_velocity', 'activity_frequency', 'distribution', 'source_analysis', 'source_comparison'],
          description: 'The type of metric to compute. cycle_time: avg time between two dates (e.g., creation to close). conversion_rate: percentage that reached a target status. win_rate: closed won vs closed lost. average_deal_size: mean opportunity value. pipeline_velocity: revenue per day. stage_velocity: breakdown by stage. distribution: count by category. source_analysis: COMPREHENSIVE lead source investigation - analyzes conversion rates, deal sizes, cycle times BY SOURCE, and detects attribution clues in unattributed leads. source_comparison: head-to-head comparison of sources.'
        },
        data: {
          type: 'array',
          items: { type: 'object' },
          description: 'Array of CRM records to analyze (pass the records array from sf_query results)'
        },
        startDateField: { type: 'string', description: 'For cycle_time: field name for start date (default: CreatedDate)' },
        endDateField: { type: 'string', description: 'For cycle_time: field name for end date (default: CloseDate or ConvertedDate)' },
        groupByField: { type: 'string', description: 'Field to group results by (e.g., Status, StageName, LeadSource)' },
        valueField: { type: 'string', description: 'Field containing numeric values (e.g., Amount)' },
        statusField: { type: 'string', description: 'Field containing status values' },
        targetStatus: { type: 'string', description: 'For conversion_rate: the status to measure conversion to (e.g., "Converted", "Closed Won")' },
        convertedValues: {
          type: 'array',
          items: { type: 'string' },
          description: 'For source_analysis: explicit list of status values indicating conversion (e.g., ["Converted", "Closed Won"]). Auto-detected if not provided.'
        },
      },
      required: ['metricType', 'data'],
    },
  },
  // =============================================================================
  // IRIS RANK TOOLS - AI-Powered Entity Ranking
  // =============================================================================
  {
    name: 'iris_rank_entities',
    description: 'Get AI-ranked entities based on network importance, activity signals, and query relevance using IRISRank algorithm. Use this when user asks "which leads should I focus on", "who should I contact first", "prioritize my accounts", "rank my opportunities", or similar prioritization questions.',
    input_schema: {
      type: 'object',
      properties: {
        entityType: {
          type: 'string',
          enum: ['Lead', 'Contact', 'Account', 'Opportunity'],
          description: 'Type of Salesforce entity to rank'
        },
        query: {
          type: 'string',
          description: 'Optional query to influence ranking relevance (e.g., "high value", "needs follow up", "enterprise")'
        },
        limit: {
          type: 'number',
          description: 'Number of results to return (default: 10)'
        },
      },
      required: ['entityType'],
    },
  },
  {
    name: 'iris_get_at_risk',
    description: 'Get entities that need attention - high-value relationships with declining engagement. Use when user asks "what deals are at risk", "which accounts need attention", "who am I losing touch with", "stalled opportunities".',
    input_schema: {
      type: 'object',
      properties: {
        entityType: {
          type: 'string',
          enum: ['Lead', 'Contact', 'Account', 'Opportunity'],
          description: 'Filter by entity type (optional - returns all types if not specified)'
        },
        limit: {
          type: 'number',
          description: 'Number of results to return (default: 5)'
        },
      },
    },
  },
  {
    name: 'iris_get_momentum',
    description: 'Get entities with positive engagement momentum - recent activity signals like emails, meetings, calls. Use for "who is engaging", "show me momentum", "leads with recent activity". NOT for "hot opportunities in pipeline" (use get_hot_opportunities instead).',
    input_schema: {
      type: 'object',
      properties: {
        entityType: {
          type: 'string',
          enum: ['Lead', 'Contact', 'Account', 'Opportunity'],
          description: 'Filter by entity type (optional - returns all types if not specified)'
        },
        limit: {
          type: 'number',
          description: 'Number of results to return (default: 5)'
        },
      },
    },
  },
  {
    name: 'get_hot_opportunities',
    description: 'Get HOT OPPORTUNITIES in the pipeline - high-value deals (>$50K) in active sales stages like Prospecting, Qualification, Proposal, Negotiation. ALWAYS use this when user asks about "hot opportunities", "hot deals", "pipeline opportunities to focus on", "show me hot opportunities".',
    input_schema: {
      type: 'object',
      properties: {
        minAmount: {
          type: 'number',
          description: 'Minimum deal amount (default: 50000)'
        },
        limit: {
          type: 'number',
          description: 'Number of opportunities to return (default: 10)'
        },
      },
    },
  },
  {
    name: 'iris_explain_rank',
    description: 'Get detailed explanation of why a specific entity has its current rank. Shows network score, activity score, relevance score, and key signals. Use when user asks "why is this lead ranked high", "explain the ranking".',
    input_schema: {
      type: 'object',
      properties: {
        entityId: {
          type: 'string',
          description: 'Salesforce record ID (18-character ID)'
        },
        entityType: {
          type: 'string',
          enum: ['Lead', 'Contact', 'Account', 'Opportunity'],
          description: 'Type of entity'
        },
      },
      required: ['entityId', 'entityType'],
    },
  },
  // =============================================================================
  // LOCAL MEETING RSVP & PARTICIPANT MANAGEMENT TOOLS (stored in IRIS database)
  // =============================================================================
  {
    name: 'list_meetings',
    description: 'List all IRIS meeting sessions. ALWAYS call this tool FIRST when user mentions a meeting by person name (e.g., "meeting with David", "delete my meeting") to find the meeting ID needed for cancel_meeting, get_meeting_rsvp_status, and other meeting operations.',
    input_schema: {
      type: 'object',
      properties: {
        status: { type: 'string', enum: ['SCHEDULED', 'IN_PROGRESS', 'COMPLETED', 'CANCELLED'], description: 'Filter by meeting status (optional)' },
        limit: { type: 'number', description: 'Maximum number of meetings to return (default: 10)' },
      },
    },
  },
  {
    name: 'get_meeting_rsvp_status',
    description: 'Get the RSVP status summary for a meeting from IRIS database including who has accepted, declined, or not yet responded. Shows participant response details and notes.',
    input_schema: {
      type: 'object',
      properties: {
        meetingId: { type: 'string', description: 'IRIS meeting ID (cuid format like cmjw...) to check RSVP status for' },
      },
      required: ['meetingId'],
    },
  },
  {
    name: 'get_meeting_participants',
    description: 'Get detailed information about all participants in an IRIS meeting including their roles, response status, engagement during meeting, and contact information.',
    input_schema: {
      type: 'object',
      properties: {
        meetingId: { type: 'string', description: 'IRIS meeting ID to get participants for' },
        includeContactDetails: { type: 'boolean', description: 'Include linked contact details if available (default: true)' },
      },
      required: ['meetingId'],
    },
  },
  {
    name: 'update_meeting_rsvp',
    description: 'Update the RSVP response for a meeting participant in IRIS. Use this when a participant responds via phone, email, or other channel.',
    input_schema: {
      type: 'object',
      properties: {
        meetingId: { type: 'string', description: 'IRIS meeting ID' },
        participantEmail: { type: 'string', description: 'Email address of the participant to update' },
        responseStatus: { type: 'string', enum: ['ACCEPTED', 'DECLINED', 'TENTATIVE'], description: 'New response status' },
        responseNote: { type: 'string', description: 'Optional note about the response (e.g., reason for declining)' },
      },
      required: ['meetingId', 'participantEmail', 'responseStatus'],
    },
  },
  {
    name: 'cancel_meeting',
    description: 'Cancel/delete a scheduled IRIS meeting and send cancellation emails to all participants. Use this when user says "cancel meeting", "delete meeting", "remove meeting", or similar. First use list_meetings to find the meeting ID if user refers to meeting by person name.',
    input_schema: {
      type: 'object',
      properties: {
        meetingId: { type: 'string', description: 'IRIS meeting ID to cancel (get from list_meetings first)' },
        reason: { type: 'string', description: 'Reason for cancellation (will be included in notification email)' },
        sendNotification: { type: 'boolean', description: 'Send cancellation email to participants (default: true)' },
      },
      required: ['meetingId'],
    },
  },
  {
    name: 'get_meeting_response_history',
    description: 'Get the full history of RSVP response changes for an IRIS meeting. Shows audit trail of who responded when and how their response changed over time.',
    input_schema: {
      type: 'object',
      properties: {
        meetingId: { type: 'string', description: 'IRIS meeting ID to get response history for' },
        participantEmail: { type: 'string', description: 'Optional: filter to specific participant email' },
      },
      required: ['meetingId'],
    },
  },
  {
    name: 'resend_meeting_invite',
    description: 'Resend IRIS meeting invite to participants who have not responded or to specific participants. Useful for follow-up on pending RSVPs.',
    input_schema: {
      type: 'object',
      properties: {
        meetingId: { type: 'string', description: 'IRIS meeting ID' },
        emails: { type: 'array', items: { type: 'string' }, description: 'Specific email addresses to resend to (optional - if not provided, sends to all pending)' },
        onlyPending: { type: 'boolean', description: 'Only resend to participants with PENDING status (default: true)' },
      },
      required: ['meetingId'],
    },
  },
  // =============================================================================
  // WEB RESEARCH TOOLS - For company/financial analysis beyond CRM data
  // =============================================================================
  {
    name: 'web_search',
    description: 'Search the web for any information using Google Custom Search. Use this for general web searches, news, and current information.',
    input_schema: {
      type: 'object',
      properties: {
        query: { type: 'string', description: 'The search query to look up on the web' },
      },
      required: ['query'],
    },
  },
  {
    name: 'research_company',
    description: 'Research a company by URL or name using WEB SEARCH. Gathers comprehensive information from the web including company overview, recent news, leadership team, financial data, stock info, earnings, revenue, and competitors. MUST USE this tool when user asks to: "research [company]", "analyze [company] financial performance", "[company] stock/revenue/earnings", or any company analysis beyond CRM data. CRM data does NOT contain financial information - this tool DOES.',
    input_schema: {
      type: 'object',
      properties: {
        companyUrlOrName: { type: 'string', description: 'Company website URL (e.g., stripe.com) or company name' },
        includeNews: { type: 'boolean', description: 'Include recent news (default: true)' },
        includeLeadership: { type: 'boolean', description: 'Include leadership/team info (default: true)' },
        includeCompetitors: { type: 'boolean', description: 'Include competitor analysis (default: false)' },
        includeJobs: { type: 'boolean', description: 'Include job postings as growth signals (default: true)' },
      },
      required: ['companyUrlOrName'],
    },
  },
  {
    name: 'search_company_news',
    description: 'Search for recent news and announcements about a specific company. Useful for finding buying signals, leadership changes, funding announcements, or product launches.',
    input_schema: {
      type: 'object',
      properties: {
        companyName: { type: 'string', description: 'Name of the company to search news for' },
        days: { type: 'number', description: 'Number of days to look back (default: 30)' },
      },
      required: ['companyName'],
    },
  },
  // ==================== AI INSIGHTS & COACHING TOOLS ====================
  {
    name: 'get_my_ai_insights',
    description: `Get AI-generated insights and recommendations for the current user. Use this when the user asks about:
- "What should I focus on today?"
- "Give me coaching tips"
- "What are my AI insights?"
- "What deals need attention?"
- "Any recommendations for me?"

Returns prioritized alerts from AI agents including deal health warnings, coaching recommendations, account intelligence, and next best actions.`,
    input_schema: {
      type: 'object',
      properties: {
        agentType: {
          type: 'string',
          description: 'Filter by agent type: DEAL_HEALTH, COACHING, ACCOUNT_INTELLIGENCE, PIPELINE_ACCELERATION, NEXT_BEST_ACTION',
          enum: ['DEAL_HEALTH', 'COACHING', 'ACCOUNT_INTELLIGENCE', 'PIPELINE_ACCELERATION', 'NEXT_BEST_ACTION'],
        },
        priority: {
          type: 'string',
          description: 'Filter by priority level',
          enum: ['URGENT', 'HIGH', 'MEDIUM', 'LOW'],
        },
        limit: { type: 'number', description: 'Maximum number of insights to return (default: 10)' },
      },
    },
  },
  {
    name: 'get_sales_coaching',
    description: `Get personalized AI sales coaching advice and performance analysis based on YOUR actual CRM data. ALWAYS use this tool when the user asks:
- "How am I doing?"
- "Give me sales tips"
- "Coach me on my deals"
- "What can I improve?"
- "Analyze my performance"
- "Help me close more deals"

This tool analyzes the user's real opportunities, win rates, and pipeline to provide personalized coaching tips.`,
    input_schema: {
      type: 'object',
      properties: {
        focusArea: {
          type: 'string',
          description: 'Optional focus area for coaching',
          enum: ['discovery', 'negotiation', 'closing', 'prospecting', 'pipeline_management', 'general'],
        },
      },
    },
  },
  {
    name: 'get_account_intelligence',
    description: `Get AI-generated intelligence and health score for a specific account. Use this when user asks:
- "How is [account name] doing?"
- "What's the health of my account?"
- "Any risks with [company]?"
- "Tell me about [account] engagement"

Returns account health score, engagement metrics, risk indicators, and recommended actions.`,
    input_schema: {
      type: 'object',
      properties: {
        accountId: { type: 'string', description: 'The account ID to analyze' },
        accountName: { type: 'string', description: 'Account name to search for (if ID not provided)' },
      },
    },
  },
  {
    name: 'get_deal_health',
    description: `Get AI analysis of deal health and risk factors for opportunities. Use this when user asks:
- "Which deals are at risk?"
- "What's the health of my pipeline?"
- "Any stalled deals?"
- "Which opportunities need attention?"

Returns deal health scores, risk factors, and recommended next steps.`,
    input_schema: {
      type: 'object',
      properties: {
        opportunityId: { type: 'string', description: 'Specific opportunity ID to analyze (optional)' },
        riskLevel: {
          type: 'string',
          description: 'Filter by risk level',
          enum: ['high_risk', 'medium_risk', 'healthy'],
        },
        limit: { type: 'number', description: 'Maximum number of deals to return (default: 10)' },
      },
    },
  },
  {
    name: 'acknowledge_ai_insight',
    description: 'Acknowledge an AI insight/alert to mark it as seen. Use when user says "got it", "thanks", "acknowledged" after seeing an insight.',
    input_schema: {
      type: 'object',
      properties: {
        alertId: { type: 'string', description: 'The ID of the alert to acknowledge' },
      },
      required: ['alertId'],
    },
  },
  {
    name: 'dismiss_ai_insight',
    description: 'Dismiss an AI insight/alert as not relevant. Use when user says "dismiss this", "not relevant", "ignore this".',
    input_schema: {
      type: 'object',
      properties: {
        alertId: { type: 'string', description: 'The ID of the alert to dismiss' },
        reason: { type: 'string', description: 'Optional reason for dismissing' },
      },
      required: ['alertId'],
    },
  },
  // Video Coaching Tools (MVP #2 Enhancement)
  {
    name: 'list_coaching_sessions',
    description: `List the user's video coaching practice sessions. Use when user asks:
- "Show my coaching sessions"
- "What practice recordings do I have?"
- "My coaching history"

Returns a list of coaching sessions with scores and status.`,
    input_schema: {
      type: 'object',
      properties: {
        scenario: {
          type: 'string',
          description: 'Filter by scenario type',
          enum: ['ELEVATOR_PITCH', 'DISCOVERY_CALL', 'DEMO_PRESENTATION', 'OBJECTION_HANDLING', 'NEGOTIATION', 'CLOSING', 'COLD_CALL', 'FOLLOW_UP', 'GENERAL_PRACTICE'],
        },
        status: {
          type: 'string',
          description: 'Filter by status',
          enum: ['RECORDING', 'UPLOADING', 'TRANSCRIBING', 'ANALYZING', 'COMPLETED', 'FAILED'],
        },
        limit: { type: 'number', description: 'Maximum number of sessions to return (default: 10)' },
      },
    },
  },
  {
    name: 'get_coaching_session',
    description: `Get details of a specific video coaching session including AI feedback.`,
    input_schema: {
      type: 'object',
      properties: {
        sessionId: { type: 'string', description: 'The coaching session ID to retrieve' },
      },
      required: ['sessionId'],
    },
  },
  {
    name: 'get_coaching_progress',
    description: `Get the user's overall coaching progress and improvement trends.`,
    input_schema: {
      type: 'object',
      properties: {},
    },
  },
  {
    name: 'get_coaching_scenarios',
    description: `Get available coaching scenarios for video practice.`,
    input_schema: {
      type: 'object',
      properties: {},
    },
  },
];

// System prompt for Salesforce CRM mode
// PERFORMANCE: Optimized for speed - minimal prompt + concise response instructions
const SALESFORCE_MODE_SYSTEM_PROMPT = `You are IRIS Sales GPT, a fast Salesforce CRM assistant.

CURRENT DATE: {{CURRENT_DATE_TIME}}

**LOGGED-IN USER CONTEXT (SALES AGENT):**
- Name: {{USER_NAME}}
- Email: {{USER_EMAIL}}
- Title: {{USER_TITLE}}

**EMAIL SIGNATURE INSTRUCTIONS (CRITICAL):**
When composing, drafting, or sending any emails:
1. ALWAYS use the logged-in user's ACTUAL name ({{USER_NAME}}) and email ({{USER_EMAIL}}) in signatures
2. NEVER use placeholder text like "[Your Name]", "[Your Position]", "[Your Email]", or similar
3. Use a professional signature format like:
   Best regards,
   {{USER_NAME}}
   {{USER_TITLE}}
   {{USER_EMAIL}}

**MEETING SCHEDULING INSTRUCTIONS (CRITICAL - ALWAYS FOLLOW THIS FLOW):**
When users ask to schedule meetings with someone:

**STEP 1 - SEARCH SALESFORCE FIRST (MANDATORY when a name is mentioned):**
- If user mentions a person's name, ALWAYS search Salesforce first using sf_search or sf_query
- "Schedule a meeting with David" â†’ First sf_search with searchTerm="David" to find in Leads, Contacts
- OR sf_query: "SELECT Id, Name, Email FROM Contact WHERE Name LIKE '%David%'" 
- AND sf_query: "SELECT Id, Name, Email FROM Lead WHERE Name LIKE '%David%'"
- This finds existing CRM records with their email addresses

**STEP 2 - USE EXISTING RECORD OR ASK FOR EMAIL:**
- IF FOUND: Use the Email field from the Salesforce record as attendeeEmails
  "I found David Lee at Acme Corp. Scheduling the meeting and sending invite to david.lee@acme.com"
- IF MULTIPLE MATCHES: Ask which one they mean
  "I found 2 people named David - David Lee at Acme and David Chen at Microsoft. Which one?"
- IF NOT FOUND: Ask for their email address
  "I don't have David in Salesforce yet. What's their email address so I can send the invite?"

**STEP 3 - SCHEDULE WITH ALL DETAILS:**
1. Use schedule_meeting tool with the appropriate platform (ZOOM, TEAMS, or GOOGLE_MEET)
2. ALWAYS include attendeeEmails from Salesforce lookup or user input - without this, no invite is sent!
3. Parse the time relative to the current date/time above (e.g., "tomorrow at 2pm", "next Monday 10am IST")
4. Convert times to ISO 8601 format (e.g., 2026-01-02T14:00:00)
5. Link to CRM record: include leadId (for Lead) or accountId (for Contact's Account)
6. Create the meeting directly - do NOT ask the user to schedule it manually
7. **SALESFORCE SYNC**: When a meeting is scheduled, a corresponding Event is automatically created in Salesforce with:
   - Subject: Meeting title
   - StartDateTime/EndDateTime: Meeting times
   - Location: Zoom/Teams/Google Meet link
   - Description: Meeting details + video conference link
   - WhoId: Linked Lead/Contact (if available)
   - WhatId: Linked Account/Opportunity (if available)

**NEVER skip the Salesforce lookup when a name is mentioned - the email is required to send invites!**

**MEETING CANCELLATION & SALESFORCE SYNC:**
When you cancel a meeting using cancel_meeting:
- The meeting is cancelled in IRIS and participants are notified via email
- If the meeting was synced to Salesforce, the Salesforce Event is also updated with "[CANCELLED]" prefix in the subject
- The Event remains in Salesforce for audit purposes but clearly shows it was cancelled

**MEETING RSVP & PARTICIPANT MANAGEMENT (IRIS LOCAL DATABASE):**
Meetings are stored in the IRIS database (not Salesforce). Use these tools for meeting management:

1. **list_meetings** - Get all meetings with their status, title, and IDs
   - Use this FIRST to find meeting IDs when user asks about "my meeting with David" or similar
   - Filter by status: SCHEDULED, IN_PROGRESS, COMPLETED, CANCELLED

2. **get_meeting_rsvp_status** - Get RSVP summary (accepted/declined/pending counts and participant details)
   - Use when: "What's the RSVP status for my meeting with David?"
   - Returns summary counts AND individual participant response details

3. **get_meeting_participants** - Get detailed participant info including roles and engagement
   - Use when: "Who is attending my meeting?", "Show me the participants"

4. **update_meeting_rsvp** - Update participant response status
   - Use when: "David said he'll attend", "Mark Sarah as declined"
   - Requires: meetingId, participantEmail, responseStatus (ACCEPTED/DECLINED/TENTATIVE)

5. **cancel_meeting** - Cancel a meeting and notify participants
   - Use when: "Cancel my meeting with David", "I need to cancel tomorrow's meeting"
   - Sends cancellation emails automatically unless sendNotification=false

6. **get_meeting_response_history** - Get audit trail of response changes

7. **resend_meeting_invite** - Resend invites to pending participants

MEETING LOOKUP PATTERN:
When user refers to a meeting by person name (not ID):
1. FIRST: list_meetings to find the meeting(s) with that person
2. THEN: Use the meeting ID from list_meetings in get_meeting_rsvp_status or other tools

**AI COACHING & INSIGHTS TOOLS (USE THESE FIRST FOR COACHING REQUESTS):**
When users ask about performance, coaching, or insights, ALWAYS use these specialized tools instead of sf_query:

- "How am I doing?" / "Analyze my performance" / "Give me coaching tips" â†’ **get_sales_coaching** (provides personalized analysis)
- "What deals are at risk?" / "Pipeline health" / "Stalled deals" â†’ **get_deal_health** (analyzes deal health scores)
- "How is [account] doing?" / "Account health" â†’ **get_account_intelligence** (account health analysis)
- "What should I focus on?" / "AI insights" / "Recommendations" â†’ **get_my_ai_insights** (prioritized alerts)

These tools analyze LOCAL data and provide intelligent coaching - DO NOT use sf_query for these requests.

**DATA SOURCE: SALESFORCE (EXTERNAL CRM)**
CRITICAL: You are currently connected to the user's SALESFORCE org. For standard CRM queries (list leads, opportunities, contacts), use Salesforce tools (sf_query, sf_search, etc.) to fetch FRESH data. IGNORE any data from previous messages in this conversation that may have come from a different data source. Always execute tools to get current data.

**SALESFORCE ADMIN OPERATIONS (SCHEMA CHANGES - USE TOOLS PROACTIVELY):**
When users ask to create, modify, or manage Salesforce schema/config, EXECUTE the appropriate tool immediately:

1. **Validation Rules** - Use sf_create_validation_rule tool:
   - "Create a validation rule on Opportunity..." â†’ Call sf_create_validation_rule with objectName, name, errorConditionFormula, errorMessage
   - Formula must return TRUE when record is INVALID
   - Example formula for preventing backward stage: AND(ISCHANGED(StageName), NOT($Profile.Name = "System Administrator"), CASE(StageName,...) < CASE(PRIORVALUE(StageName),...))

2. **Custom Fields** - Use sf_create_custom_field tool:
   - "Add a field to Lead..." â†’ Call sf_create_custom_field with objectName, fullName, label, type

3. **Custom Objects** - Use sf_create_custom_object tool:
   - "Create an object for Projects..." â†’ Call sf_create_custom_object with fullName, label, pluralLabel

4. **Flow Management** - Use sf_toggle_flow tool:
   - "Deactivate the flow..." â†’ Call sf_toggle_flow with flowId and activate=false

5. **Field-Level Security** - Use sf_update_field_level_security tool:
   - "Make this field visible to..." â†’ Call sf_update_field_level_security

CRITICAL: When users describe what they want to create (validation rule, field, etc.), DO NOT just explain how to do it manually. EXECUTE the tool to create it in Salesforce immediately. The whole point of this assistant is to perform admin operations via natural language.

ANTI-HALLUCINATION RULES (CRITICAL - NEVER VIOLATE):
1. ONLY reference data that was ACTUALLY returned by tool calls. NEVER invent record names, amounts, dates, or any other data.
2. If tool returns 5 opportunities, only mention those exact 5 - never fabricate additional ones.
3. If you don't have data from a tool result, say "I don't have that information" - NEVER guess or make up data.
4. Opportunity names, Lead names, Account names must be COPIED EXACTLY from tool results - never paraphrased or invented.

SPEED RULES:
1. NO preamble. NO "Let me search". Just execute tools immediately.
2. Keep responses concise - focus on insights and recommendations.
3. Execute multiple tools in PARALLEL when possible.

CRITICAL - EXTRACT NUMERIC LIMITS FROM USER QUERIES:
When users specify a number in their query, ALWAYS extract and pass it as the limit parameter:
- "top 3 leads" â†’ get_top_leads with limit: 3
- "show me 5 opportunities" â†’ sf_query with LIMIT 5
- "list 10 tasks" â†’ get_my_tasks with limit: 10
- "what are my 4 biggest deals" â†’ sf_query with ORDER BY Amount DESC LIMIT 4
NEVER ignore the user's requested count - if they ask for 3, return exactly 3 (not 5 or 10).

SHORT FOLLOW-UP QUERY HANDLING (CRITICAL):
When user sends a short message referencing previous results, interpret it correctly:
- "Lead record" or "the lead" â†’ Show FULL DETAILS of the Lead record just mentioned (use sf_get_record with the Lead Id)
- "Contact record" or "the contact" â†’ Show FULL DETAILS of the Contact record just mentioned
- "Account record" or "the account" â†’ Show FULL DETAILS of the Account record just mentioned
- "Opportunity record" or "the deal" â†’ Show FULL DETAILS of the Opportunity record just mentioned
- "More details" or "tell me more" â†’ Fetch and show ALL fields for the record(s) just discussed
- "[First name only]" (e.g., "David") â†’ Refers to the person just mentioned, show their record details
- "Email them" or "send email" â†’ Compose email to the person just mentioned
- "Schedule meeting" â†’ Schedule meeting with the person just mentioned
- "Update the opportunity" or "change stage" â†’ Use the Opportunity ID (starts with 006) from the previous results. NEVER use Account ID (starts with 001).

OPPORTUNITY UPDATE FLOW (CRITICAL FOR SALESFORCE):
When updating an opportunity mentioned in conversation:
1. CHECK if you already have the Opportunity ID (starts with 006) from a previous query
2. If YES: Use that ID directly with sf_update_opportunity
3. If NO: First query to get the ID: sf_query("SELECT Id, Name, StageName FROM Opportunity WHERE Name LIKE '%OpportunityName%'")
4. NEVER guess or make up an ID - always get it from query results
5. Salesforce Opportunity IDs start with "006" - Account IDs start with "001" - do not confuse them

DO NOT confuse "suggested follow-ups" shown in the UI with the user's actual request. The user's message is their intent - not the suggestions.

SCHEMA-FIRST QUERY PATTERN (MANDATORY FOR COMPLEX QUERIES):
When querying objects you're unsure about, or when queries fail, ALWAYS use sf_describe_object FIRST:
1. Call sf_describe_object with objectName (e.g., 'Opportunity', 'Lead', 'Account')
2. Review the returned fields and relationships
3. THEN construct your SOQL using ONLY fields that exist in the schema
4. This prevents errors like "No such column 'LeadId' on entity 'Opportunity'"

For SIMPLE standard queries (top leads, recent accounts), you can use common fields directly.
For COMPLEX or RELATIONSHIP queries, ALWAYS describe the schema first.

SOQL SYNTAX RULES (CRITICAL - FOLLOW EXACTLY):
1. **DateTime format**: Use ISO8601 format: 2026-01-01T00:00:00Z (NOT 2026-01-01 without time)
2. **Date literals**: Use SOQL date literals: TODAY, YESTERDAY, THIS_WEEK, LAST_WEEK, THIS_MONTH, LAST_MONTH, LAST_N_DAYS:n, THIS_QUARTER, LAST_N_MONTHS:n
3. **Searching by name**: Use Name field, NOT Id. Example: WHERE Name LIKE '%John%' (NOT WHERE Id = 'John')
4. **Id field**: Only use for actual 15/18 char Salesforce IDs (e.g., 00Q1234567890AB)
5. **String literals**: Use single quotes. Example: Status = 'Open'

COMMON STANDARD OBJECT FIELDS (for simple queries only):
- **Lead**: Id, Name, FirstName, LastName, Email, Phone, Company, Status, LeadSource, Title, CreatedDate
- **Account**: Id, Name, Industry, Type, Website, Phone, BillingCity, BillingState
- **Contact**: Id, Name, FirstName, LastName, Email, Phone, Title, AccountId
- **Opportunity**: Id, Name, Amount, StageName, CloseDate, AccountId, Probability, Type

SALESFORCE DATA MODEL (CRITICAL RELATIONSHIPS):
- **Leads are SEPARATE from Opportunities**: There is NO LeadId on Opportunity. Leads convert to Contacts/Accounts.
- **Opportunities link to Accounts via AccountId** (not to Leads)
- **Contacts link to Accounts via AccountId**
- **To find related records for an Account**: First get the AccountId, then query child records with WHERE AccountId = 'xxx'

MANDATORY - CONVERSION RATE QUERIES (MUST USE compute_analytics):
When user asks about "conversion rate", "why sources convert", "attributed vs unattributed", or comparing lead source performance:
1. FIRST: sf_query to get raw leads: SELECT Id, LeadSource, Status, IsConverted, CreatedDate, ConvertedDate FROM Lead
2. THEN: compute_analytics with metricType='source_analysis' and data=records
This returns conversionRate as PERCENTAGES (e.g., 50%, 42%) per source - NOT just counts!
DO NOT try to calculate conversion rates in SOQL - use compute_analytics.

CRITICAL - NO MARKDOWN TABLES IN RESPONSE:
- NEVER format query results as markdown tables (using | pipes) in your text response
- The UI AUTOMATICALLY renders beautiful interactive charts (bar, line, pie) and tables from the structured data
- Your job is ONLY to provide insights and recommendations - NOT to display the raw data
- If you include a markdown table, you are duplicating what the UI already shows - this is wasteful and clutters the response

RESPONSE FORMAT & MARKDOWN STYLING:
Use rich markdown formatting for professional, scannable responses:

**Structure:**
- Start with a **bold summary** of what was found (e.g., "**Found 25 opportunities** worth \`$1.4M\` across 9 stages")
- Use ## for section headers when organizing multiple topics
- Use **bold** for labels: **Insight:** or **Recommendation:** or **Status:**
- Use \`code formatting\` for specific values, amounts, percentages, dates

**Text Formatting:**
- **Bold** for important names, statuses, key terms (e.g., **Bertha Boxer**, **Working - Contacted**, **Hot**)
- *Italics* for supplementary notes or secondary info
- \`Code style\` for values: \`$50,000\`, \`25%\`, \`Q4 2025\`
- Bullet points (-) for lists of insights or recommendations

**Example Response:**
**No opportunities found** for Farmers Coop. of Florida in your pipeline.

**Insight:** Despite **Bertha Boxer** being a *Working - Contacted* lead for \`8+ months\`, no opportunity has been created yet.

**Recommendation:** Schedule a follow-up call with Bertha to qualify her into an opportunity or understand blockers.

NEVER include markdown tables for data - the UI renders charts/tables automatically below your response.

CRITICAL - AGGREGATION QUERIES (COUNT BY, GROUP BY):
When user asks for "count by", "breakdown by", "distribution", "by status", "by stage", "by source", or any grouping:
- ALWAYS use GROUP BY with COUNT(Id) - NEVER return individual records
- Return aggregated counts/sums, NOT lists of records

AGGREGATION QUERY PATTERNS (ALWAYS USE THESE):
| User Query | SOQL Pattern |
|------------|--------------|
| "Lead count by status" | SELECT Status, COUNT(Id) cnt FROM Lead GROUP BY Status |
| "Leads by source" | SELECT LeadSource, COUNT(Id) cnt FROM Lead GROUP BY LeadSource |
| "Pipeline by stage" | SELECT StageName, COUNT(Id) cnt, SUM(Amount) total FROM Opportunity GROUP BY StageName |
| "Opportunities by stage" | SELECT StageName, COUNT(Id) cnt, SUM(Amount) total FROM Opportunity GROUP BY StageName |
| "Contacts by account" | SELECT Account.Name, COUNT(Id) cnt FROM Contact GROUP BY Account.Name |
| "Tasks by status" | SELECT Status, COUNT(Id) cnt FROM Task GROUP BY Status |

SALESFORCE REPORT CREATION (CRITICAL - YOU MUST CALL sf_create_report TOOL):
When user asks about "reports", determine their intent:

**QUERY DATA (default behavior)** - Use sf_query to fetch and display data:
- "Generate a report of..." â†’ sf_query, display results
- "Show me a report of..." â†’ sf_query, display results
- "List all accounts that..." â†’ sf_query, display results
- "What accounts don't have..." â†’ sf_query, display results

**CREATE PERSISTENT SALESFORCE REPORT** - YOU MUST CALL sf_create_report TOOL:
When user says ANY of these phrases, you MUST call the sf_create_report tool - do NOT just query data:
- "Create a Salesforce report..." â†’ MUST call sf_create_report tool
- "Create a report in Salesforce..." â†’ MUST call sf_create_report tool
- "Create a report called..." â†’ MUST call sf_create_report tool
- "Save this as a Salesforce report" â†’ MUST call sf_create_report tool
- "Build me a SF report for..." â†’ MUST call sf_create_report tool
- "Create this report in Salesforce" â†’ MUST call sf_create_report tool
- "I need a saved report in Salesforce" â†’ MUST call sf_create_report tool

CRITICAL: Do NOT say "I created a report" unless you actually called the sf_create_report tool and it returned success.
NEVER hallucinate report creation - you must execute the sf_create_report tool.

**sf_create_report REQUIRED PARAMETERS:**
- name: Descriptive report name (e.g., "Accounts Without Open Opportunities")
- reportType: Primary object - use the Salesforce report type API name:
  - For Account reports: "AccountList" (tabular) or "AccountCSO" (with opportunities)
  - For Lead reports: "LeadList"
  - For Opportunity reports: "OpportunityList" or "Opportunity"
  - For Contact reports: "ContactList"
  - For Activity reports: "Activity"
  - Use sf_get_report_types to find available report types if unsure
- format: TABULAR (flat list), SUMMARY (grouped with subtotals), or MATRIX (pivot table)
- columns: Array of Salesforce field API names (e.g., ["Name", "Owner.Name", "LastActivityDate"])
- filters: Optional array of filter conditions

**EXAMPLE - Create Salesforce Report:**
User: "Create a Salesforce report of accounts without open opportunities"
â†’ Call sf_create_report with:
  - name: "Accounts Without Open Opportunities"
  - reportType: "AccountList"
  - format: "TABULAR"
  - columns: ["Name", "Owner.Name", "LastActivityDate", "Industry", "Phone"]
  - filters: [{"column": "OPPORTUNITIES", "operator": "equals", "value": "0"}]

**AFTER QUERYING DATA:**
If you queried data and the user then says "Create this report in Salesforce" or "Save this as a report":
- Use sf_create_report with the same criteria from your previous query
- Confirm the report was created and provide the report name

CHART-FRIENDLY DATA (UI auto-renders charts for these patterns):
For forecast/trend/projection queries:
- Return data with date/period column + numeric value column (Amount, Revenue, etc.)
- Group by month/quarter/year for time-series charts (line charts)
- Example SOQL: SELECT CALENDAR_MONTH(CloseDate) Month, SUM(Amount) Total FROM Opportunity GROUP BY CALENDAR_MONTH(CloseDate)

For pipeline/stage/distribution queries:
- Return data with category column + count/amount (bar charts, pie charts)
- Example SOQL: SELECT StageName, COUNT(Id) Count, SUM(Amount) Total FROM Opportunity GROUP BY StageName
- Example SOQL: SELECT Status, COUNT(Id) Count FROM Lead GROUP BY Status

For comparison/ranking queries:
- Return data with name/label + numeric value for bar charts
- Example SOQL: SELECT Owner.Name, SUM(Amount) FROM Opportunity WHERE IsWon=true GROUP BY Owner.Name ORDER BY SUM(Amount) DESC LIMIT 10

For metrics/KPI queries (totals, averages):
- Return aggregated single-row results for KPI cards
- Example SOQL: SELECT COUNT(Id) Total, SUM(Amount) TotalValue, AVG(Amount) AvgValue FROM Opportunity

ANALYTICS & COMPUTED METRICS:
For questions about cycle time, conversion rates, or computed metrics:
1. First, query the raw data with sf_query (include relevant date/status fields)
2. Then, use compute_analytics to calculate the metric

Example - "What's the avg time from Open to Closed?":
Step 1: sf_query: SELECT Id, Status, CreatedDate, LastModifiedDate, ConvertedDate FROM Lead WHERE Status = 'Closed - Converted' OR Status = 'Closed - Not Converted'
Step 2: compute_analytics with metricType='cycle_time', data=records, groupByField='Status'

Available analytics metrics:
- cycle_time: Average days between two dates (e.g., creation to close)
- conversion_rate: Percentage converted to target status
- win_rate: Closed Won vs Closed Lost ratio
- average_deal_size: Mean opportunity amount
- pipeline_velocity: Revenue generation rate
- distribution: Breakdown by category
- source_analysis: COMPREHENSIVE lead source investigation - USE THIS for "why do X leads convert better?", "investigate lead sources", "why unattributed leads perform well"
- source_comparison: Head-to-head comparison of two or more lead sources

LEAD SOURCE INVESTIGATION (Phone Inquiry, Unattributed, etc.):
For questions about WHY certain lead sources perform better, or investigating unattributed leads:
Step 1: sf_query: SELECT Id, LeadSource, Status, IsConverted, CreatedDate, ConvertedDate, Email, Phone, Website, Description FROM Lead
Step 2: compute_analytics with metricType='source_analysis', data=records
The source_analysis metric provides:
- Conversion rates by source (as percentages)
- Average deal sizes by source (if Amount available)
- Average cycle times by source
- Attribution clues for unattributed/OTHER leads (detects patterns like campaign links, referral indicators, phone numbers)

CONVERSION RATE COMPARISON QUERIES - USE source_analysis:
| User Query | Action |
|------------|--------|
| "conversion rate by source" | source_analysis |
| "conversion rate vs attributed" | source_analysis |
| "attributed vs unattributed conversion" | source_analysis |
| "which sources convert best" | source_analysis |
| "compare lead source performance" | source_analysis |
For ALL these queries, compute_analytics with metricType='source_analysis' returns conversion rate PERCENTAGES per source.

TOOLS:
- sf_search: Search across objects by keyword
- sf_query: Run SOQL (SELECT fields FROM Object WHERE conditions LIMIT n)
- compute_analytics: Compute metrics from query results (cycle time, conversion rates, win rates, source_analysis for lead investigation, etc.)
- sf_create_lead: Create Lead record
- sf_create_contact: Create Contact record
- sf_create_account: Create Account record
- sf_create_opportunity: Create Opportunity record
- sf_create_task: Create Task record
- sf_update_record: Update any record (objectType, recordId, fields)
- sf_get_record: Get record details by ID
- research_company: Web research for company info
- iris_rank_entities: AI-powered entity ranking with velocity, acceleration, and momentum signals
- iris_get_at_risk: Find entities with declining engagement (churn risk)
- iris_get_momentum: Find entities with accelerating engagement (hot leads)
- send_email: Send email directly (to, subject, body)
- get_email_threads: View email conversation history
- get_awaiting_responses: Find emails waiting for replies
- send_email_draft: Send a previously drafted email

EMAIL CAPABILITIES - YOU CAN SEND EMAILS DIRECTLY:
You have FULL email sending capabilities. When user asks to send an email, you MUST use the send_email tool:
- "Send an email to john@example.com" â†’ send_email with to=['john@example.com'], subject, and body
- "Email the proposal to the client" â†’ send_email with recipient, subject, and professional body
- "Send a follow-up" â†’ send_email tool
CRITICAL: You MUST actually call send_email to send an email. NEVER say "I cannot send emails" - you CAN and MUST use the send_email tool.

CRITICAL - RANKING & PRIORITIZATION QUERIES (ALWAYS USE IRISRank):
When user asks about ranking, prioritizing, or focusing on entities, ALWAYS use iris_rank_entities instead of sf_query:

| User Query | Tool to Use |
|------------|-------------|
| "Rank my leads" | iris_rank_entities with entityType='Lead' |
| "Prioritize my contacts" | iris_rank_entities with entityType='Contact' |
| "Which leads should I focus on" | iris_rank_entities with entityType='Lead' |
| "Who should I call first" | iris_rank_entities with entityType='Lead' or 'Contact' |
| "Show hot leads" | iris_get_momentum with entityType='Lead' |
| "Hot opportunities in pipeline" | get_hot_opportunities (high-value deals in active stages) |
| "Show me hot opportunities" | get_hot_opportunities (NOT iris_get_momentum) |
| "At-risk deals" | iris_get_at_risk with entityType='Opportunity' |
| "Which accounts need attention" | iris_get_at_risk with entityType='Account' |
| "Top opportunities" | iris_rank_entities with entityType='Opportunity' |

IRISRank returns RICH DATA including:
- **rank**: Overall priority score (0-1)
- **momentum.velocity**: Week-over-week engagement change (+35% = increasing, -20% = declining)
- **momentum.acceleration**: Velocity trend (picking up speed vs losing steam)
- **momentum.trend**: 'accelerating' | 'steady' | 'decelerating' | 'at_risk' | 'churning'
- **explanation**: Human-readable insights about each entity

DO NOT use sf_query for ranking - it only returns raw data without intelligence.
ALWAYS use iris_rank_entities - it provides predictive engagement signals.

RESEARCH REQUESTS ("Research X company"):
1. FIRST: Use sf_search to find matching Leads, Contacts, Accounts in CRM
2. THEN: Use research_company for web info (news, leadership, etc.)
3. Format response with these sections:

## Key Facts
| Industry | Employees | Revenue | HQ | Founded |
|----------|-----------|---------|-----|---------|
| [value]  | [value]   | [value] | [value] | [value] |

## Company Overview
Brief 2-3 sentence description of what the company does and their market position.

## Leadership
| Role | Name |
|------|------|
| CEO | [name] |
| CFO | [name] |
| CIO/CTO | [name] |
| Other relevant | [name] |

## Sales Approach
- **Decision Makers**: Key titles to target
- **Value Proposition**: How our solution helps them
- **Entry Points**: Best ways to start conversation

## Sales Cycle Insights
- **Typical Cycle**: [X months]
- **Budget Season**: [Q1/Q2/etc]
- **Key Triggers**: Events that create buying opportunities

## Recent Activity
- Latest news and announcements relevant to sales

## CRM Records
(Table auto-rendered by UI - don't list records in text, just note "Found X matching records")

**RESPONSE FORMATTING (CRITICAL):**
- NEVER use emojis of any kind - this is a professional enterprise application
- No emoji icons like ðŸ” ðŸ“° ðŸ’¼ ðŸŽ¯ ðŸ“Š ðŸ’¡ âœ… âš ï¸ etc.
- Headers must be plain text: "## Summary" NOT "## ðŸŽ¯ Summary"
- Start with a **bold summary** of what was found
- Use **bold** for labels: **Insight:** or **Recommendation:**
- Use \`code formatting\` for specific values, amounts, percentages, dates

**CRITICAL BEHAVIOR RULES:**
1. ALWAYS USE TOOLS - Never make up CRM data. Always call the appropriate tool.
2. TAKE ACTION - When user asks you to do something, DO IT. Don't say "I can't" unless the tool genuinely fails.
3. CONFIRM ACTIONS - After doing something, confirm briefly: "Done! Lead created" or "Task marked complete"
4. BE PROACTIVE - After completing an action, suggest next steps (e.g., "Want me to create a follow-up task?")
5. CONTEXT MEMORY - Remember what was just discussed. If user says "update it" or "delete that", use the last mentioned entity.

SOQL: Use single quotes for strings. Objects: Lead, Contact, Account, Opportunity, Task. Date literals: TODAY, THIS_WEEK, LAST_N_DAYS:n`;

// =============================================================================
// ORACLE CX SALES CLOUD MODE - Enterprise CRM Integration
// =============================================================================

// Oracle CX-specific tools for direct CRM operations
const ORACLE_CX_TOOLS = [
  {
    name: 'ocx_query',
    description: 'Query Oracle CX Sales Cloud data. Fetches records from specified resource type with optional filters.',
    input_schema: {
      type: 'object',
      properties: {
        resource: { type: 'string', description: 'The Oracle CX resource type: opportunities, accounts, contacts, leads, activities, tasks' },
        filters: {
          type: 'object',
          description: 'Query filters as key-value pairs. Use q parameter for SCIM filter syntax: e.g., {"q": "OptyNumber = \'123\'"}',
          additionalProperties: true
        },
        limit: { type: 'number', description: 'Maximum number of records to return (default: 25, max: 500)' },
        offset: { type: 'number', description: 'Number of records to skip for pagination' },
        orderBy: { type: 'string', description: 'Field to sort by (e.g., "LastUpdateDate:desc")' },
        fields: { type: 'string', description: 'Comma-separated list of fields to return' },
      },
      required: ['resource'],
    },
  },
  {
    name: 'ocx_get_record',
    description: 'Get a single Oracle CX record by ID with all its field values.',
    input_schema: {
      type: 'object',
      properties: {
        resource: { type: 'string', description: 'The Oracle CX resource type (e.g., opportunities, accounts, contacts, leads)' },
        recordId: { type: 'string', description: 'The Oracle CX record ID' },
        expand: { type: 'string', description: 'Related resources to include (comma-separated)' },
      },
      required: ['resource', 'recordId'],
    },
  },
  {
    name: 'ocx_create_lead',
    description: 'Create a new Lead record in Oracle CX Sales Cloud.',
    input_schema: {
      type: 'object',
      properties: {
        FirstName: { type: 'string', description: 'Lead first name' },
        LastName: { type: 'string', description: 'Lead last name (required)' },
        CompanyName: { type: 'string', description: 'Company name' },
        EmailAddress: { type: 'string', description: 'Email address' },
        WorkPhoneNumber: { type: 'string', description: 'Work phone number' },
        Title: { type: 'string', description: 'Job title' },
      },
      additionalProperties: true,
      required: ['LastName'],
    },
  },
  {
    name: 'ocx_update_lead',
    description: 'Update an existing Lead record in Oracle CX Sales Cloud.',
    input_schema: {
      type: 'object',
      properties: {
        leadId: { type: 'string', description: 'The Oracle CX Lead ID' },
      },
      additionalProperties: true,
      required: ['leadId'],
    },
  },
  {
    name: 'ocx_create_opportunity',
    description: 'Create a new Opportunity record in Oracle CX Sales Cloud.',
    input_schema: {
      type: 'object',
      properties: {
        Name: { type: 'string', description: 'Opportunity name (required)' },
        AccountId: { type: 'string', description: 'Associated account ID' },
        Revenue: { type: 'number', description: 'Revenue amount' },
        CloseDate: { type: 'string', description: 'Expected close date (YYYY-MM-DD format)' },
        SalesStage: { type: 'string', description: 'Sales stage name' },
        WinProb: { type: 'number', description: 'Win probability (0-100)' },
      },
      additionalProperties: true,
      required: ['Name'],
    },
  },
  {
    name: 'ocx_update_opportunity',
    description: 'Update an existing Opportunity record in Oracle CX Sales Cloud. CRITICAL: You MUST have the Oracle CX Opportunity ID from a previous query. If you only have the opportunity NAME, FIRST use ocx_query to get the ID. You MUST know the NEW VALUE before calling.',
    input_schema: {
      type: 'object',
      properties: {
        opportunityId: { type: 'string', description: 'The Oracle CX Opportunity ID (from previous search/query results)' },
      },
      additionalProperties: true,
      required: ['opportunityId'],
    },
  },
  {
    name: 'ocx_create_contact',
    description: 'Create a new Contact record in Oracle CX Sales Cloud.',
    input_schema: {
      type: 'object',
      properties: {
        FirstName: { type: 'string', description: 'Contact first name' },
        LastName: { type: 'string', description: 'Contact last name (required)' },
        AccountId: { type: 'string', description: 'Associated account ID' },
        EmailAddress: { type: 'string', description: 'Email address' },
        WorkPhoneNumber: { type: 'string', description: 'Work phone number' },
        JobTitle: { type: 'string', description: 'Job title' },
      },
      additionalProperties: true,
      required: ['LastName'],
    },
  },
  {
    name: 'ocx_update_contact',
    description: 'Update an existing Contact record in Oracle CX Sales Cloud.',
    input_schema: {
      type: 'object',
      properties: {
        contactId: { type: 'string', description: 'The Oracle CX Contact ID' },
      },
      additionalProperties: true,
      required: ['contactId'],
    },
  },
  {
    name: 'ocx_create_account',
    description: 'Create a new Account (Organization) record in Oracle CX Sales Cloud.',
    input_schema: {
      type: 'object',
      properties: {
        OrganizationName: { type: 'string', description: 'Account/Organization name (required)' },
        Type: { type: 'string', description: 'Account type' },
        Industry: { type: 'string', description: 'Industry classification' },
        AnnualRevenue: { type: 'number', description: 'Annual revenue' },
        NumberOfEmployees: { type: 'number', description: 'Number of employees' },
      },
      additionalProperties: true,
      required: ['OrganizationName'],
    },
  },
  {
    name: 'ocx_create_task',
    description: 'Create a new Task (Activity) in Oracle CX Sales Cloud.',
    input_schema: {
      type: 'object',
      properties: {
        Subject: { type: 'string', description: 'Task subject (required)' },
        DueDate: { type: 'string', description: 'Due date (YYYY-MM-DD format)' },
        Status: { type: 'string', description: 'Task status' },
        Priority: { type: 'string', description: 'Task priority' },
        AccountId: { type: 'string', description: 'Related account ID' },
        ContactId: { type: 'string', description: 'Related contact ID' },
        OpportunityId: { type: 'string', description: 'Related opportunity ID' },
      },
      additionalProperties: true,
      required: ['Subject'],
    },
  },
  {
    name: 'ocx_describe_resource',
    description: 'Get metadata about an Oracle CX resource including available fields and their types.',
    input_schema: {
      type: 'object',
      properties: {
        resource: { type: 'string', description: 'The Oracle CX resource type (e.g., opportunities, accounts, contacts, leads)' },
      },
      required: ['resource'],
    },
  },
  {
    name: 'ocx_update_record',
    description: 'Update any Oracle CX record. CRITICAL: You MUST know the exact NEW VALUES before calling.',
    input_schema: {
      type: 'object',
      properties: {
        resource: { type: 'string', description: 'The Oracle CX resource type' },
        recordId: { type: 'string', description: 'The Oracle CX record ID' },
        fields: {
          type: 'object',
          description: 'Object containing field names and values to update',
          additionalProperties: true
        },
      },
      required: ['resource', 'recordId', 'fields'],
    },
  },
  {
    name: 'ocx_create_record',
    description: 'Create any Oracle CX record with specified fields.',
    input_schema: {
      type: 'object',
      properties: {
        resource: { type: 'string', description: 'The Oracle CX resource type' },
        fields: {
          type: 'object',
          description: 'Object containing field names and values for the new record',
          additionalProperties: true
        },
      },
      required: ['resource', 'fields'],
    },
  },
  // Include common tools from other modes
  {
    name: 'research_company',
    description: 'Research a company via web search. Get company overview, news, leadership, and financial info. Also checks CRM for existing records.',
    input_schema: {
      type: 'object',
      properties: {
        companyUrlOrName: { type: 'string', description: 'Company name or website URL to research' },
      },
      required: ['companyUrlOrName'],
    },
  },
  {
    name: 'web_search',
    description: 'Search the web for general information using Google Search.',
    input_schema: {
      type: 'object',
      properties: {
        query: { type: 'string', description: 'Search query' },
      },
      required: ['query'],
    },
  },
  {
    name: 'send_email',
    description: 'Send an email. Use this to send emails to contacts, leads, or any email address.',
    input_schema: {
      type: 'object',
      properties: {
        to: { type: 'array', items: { type: 'string' }, description: 'Recipient email addresses' },
        subject: { type: 'string', description: 'Email subject line' },
        body: { type: 'string', description: 'Email body content (plain text or HTML)' },
        cc: { type: 'array', items: { type: 'string' }, description: 'CC recipients (optional)' },
      },
      required: ['to', 'subject', 'body'],
    },
  },
  {
    name: 'schedule_meeting',
    description: 'Schedule a video meeting on Zoom, Microsoft Teams, or Google Meet.',
    input_schema: {
      type: 'object',
      properties: {
        title: { type: 'string', description: 'Meeting title' },
        startTime: { type: 'string', description: 'Start time in ISO 8601 format' },
        endTime: { type: 'string', description: 'End time in ISO 8601 format' },
        attendeeEmails: { type: 'array', items: { type: 'string' }, description: 'Email addresses of attendees' },
        platform: { type: 'string', enum: ['ZOOM', 'TEAMS', 'GOOGLE_MEET'], description: 'Video platform' },
        description: { type: 'string', description: 'Meeting description/agenda' },
      },
      required: ['title', 'startTime', 'endTime', 'platform'],
    },
  },
  {
    name: 'compute_analytics',
    description: 'Compute sales analytics and metrics from CRM data.',
    input_schema: {
      type: 'object',
      properties: {
        metricType: { type: 'string', description: 'Type of metric to compute: cycle_time, conversion_rate, win_rate, average_deal_size, pipeline_velocity, stage_distribution, activity_frequency, source_analysis' },
        records: { type: 'array', description: 'Array of CRM records to analyze' },
      },
      required: ['metricType', 'records'],
    },
  },
  // ==================== AI INSIGHTS & COACHING TOOLS (MVP #1 & #2) ====================
  {
    name: 'get_my_ai_insights',
    description: `Get AI-generated insights and recommendations for the current user. Use this when the user asks about:
- "What should I focus on today?"
- "Give me coaching tips"
- "What are my AI insights?"
- "What deals need attention?"
- "Any recommendations for me?"

Returns prioritized alerts from AI agents including deal health warnings, coaching recommendations, account intelligence, and next best actions.`,
    input_schema: {
      type: 'object',
      properties: {
        agentType: {
          type: 'string',
          description: 'Filter by agent type: DEAL_HEALTH, COACHING, ACCOUNT_INTELLIGENCE, PIPELINE_ACCELERATION, NEXT_BEST_ACTION',
          enum: ['DEAL_HEALTH', 'COACHING', 'ACCOUNT_INTELLIGENCE', 'PIPELINE_ACCELERATION', 'NEXT_BEST_ACTION'],
        },
        priority: {
          type: 'string',
          description: 'Filter by priority level',
          enum: ['URGENT', 'HIGH', 'MEDIUM', 'LOW'],
        },
        limit: { type: 'number', description: 'Maximum number of insights to return (default: 10)' },
      },
    },
  },
  {
    name: 'get_sales_coaching',
    description: `Get personalized AI sales coaching advice and performance analysis based on YOUR actual CRM data. ALWAYS use this tool when the user asks:
- "How am I doing?"
- "Give me sales tips"
- "Coach me on my deals"
- "What can I improve?"
- "Analyze my performance"
- "Help me close more deals"

This tool analyzes the user's real opportunities, win rates, and pipeline to provide personalized coaching tips.`,
    input_schema: {
      type: 'object',
      properties: {
        focusArea: {
          type: 'string',
          description: 'Optional focus area for coaching',
          enum: ['discovery', 'negotiation', 'closing', 'prospecting', 'pipeline_management', 'general'],
        },
      },
    },
  },
  {
    name: 'get_account_intelligence',
    description: `Get AI-generated intelligence and health score for a specific account. Use this when user asks:
- "How is [account name] doing?"
- "What's the health of my account?"
- "Any risks with [company]?"
- "Tell me about [account] engagement"

Returns account health score, engagement metrics, risk indicators, and recommended actions.`,
    input_schema: {
      type: 'object',
      properties: {
        accountId: { type: 'string', description: 'The account ID to analyze' },
        accountName: { type: 'string', description: 'Account name to search for (if ID not provided)' },
      },
    },
  },
  {
    name: 'get_deal_health',
    description: `Get AI analysis of deal health and risk factors for opportunities. Use this when user asks:
- "Which deals are at risk?"
- "What's the health of my pipeline?"
- "Any stalled deals?"
- "Which opportunities need attention?"

Returns deal health scores, risk factors, and recommended next steps.`,
    input_schema: {
      type: 'object',
      properties: {
        opportunityId: { type: 'string', description: 'Specific opportunity ID to analyze (optional)' },
        riskLevel: {
          type: 'string',
          description: 'Filter by risk level',
          enum: ['high_risk', 'medium_risk', 'healthy'],
        },
        limit: { type: 'number', description: 'Maximum number of deals to return (default: 10)' },
      },
    },
  },
  {
    name: 'acknowledge_ai_insight',
    description: 'Acknowledge an AI insight/alert to mark it as seen. Use when user says "got it", "thanks", "acknowledged" after seeing an insight.',
    input_schema: {
      type: 'object',
      properties: {
        alertId: { type: 'string', description: 'The ID of the alert to acknowledge' },
      },
      required: ['alertId'],
    },
  },
  {
    name: 'dismiss_ai_insight',
    description: 'Dismiss an AI insight/alert as not relevant. Use when user says "dismiss this", "not relevant", "ignore this".',
    input_schema: {
      type: 'object',
      properties: {
        alertId: { type: 'string', description: 'The ID of the alert to dismiss' },
        reason: { type: 'string', description: 'Optional reason for dismissing' },
      },
      required: ['alertId'],
    },
  },
  // Video Coaching Tools (MVP #2 Enhancement)
  {
    name: 'list_coaching_sessions',
    description: `List the user's video coaching practice sessions. Use when user asks:
- "Show my coaching sessions"
- "What practice recordings do I have?"
- "My coaching history"

Returns a list of coaching sessions with scores and status.`,
    input_schema: {
      type: 'object',
      properties: {
        scenario: {
          type: 'string',
          description: 'Filter by scenario type',
          enum: ['ELEVATOR_PITCH', 'DISCOVERY_CALL', 'DEMO_PRESENTATION', 'OBJECTION_HANDLING', 'NEGOTIATION', 'CLOSING', 'COLD_CALL', 'FOLLOW_UP', 'GENERAL_PRACTICE'],
        },
        status: {
          type: 'string',
          description: 'Filter by status',
          enum: ['RECORDING', 'UPLOADING', 'TRANSCRIBING', 'ANALYZING', 'COMPLETED', 'FAILED'],
        },
        limit: { type: 'number', description: 'Maximum number of sessions to return (default: 10)' },
      },
    },
  },
  {
    name: 'get_coaching_session',
    description: `Get details of a specific video coaching session including AI feedback.`,
    input_schema: {
      type: 'object',
      properties: {
        sessionId: { type: 'string', description: 'The coaching session ID to retrieve' },
      },
      required: ['sessionId'],
    },
  },
  {
    name: 'get_coaching_progress',
    description: `Get the user's overall coaching progress and improvement trends.`,
    input_schema: {
      type: 'object',
      properties: {},
    },
  },
  {
    name: 'get_coaching_scenarios',
    description: `Get available coaching scenarios for video practice.`,
    input_schema: {
      type: 'object',
      properties: {},
    },
  },
];

// Minimal system prompt for simple CRM queries (reduces tokens by ~80%)
// Uses few-shot examples for better tool calling accuracy (research-backed approach)
const ORACLE_CX_MINIMAL_PROMPT = `You are a CRM assistant. Call tools to get data, then describe the results.

## FOR LISTING (top N, show N, list):
Call ocx_query with the requested limit. Briefly confirm "Here are the top N leads/opportunities."

## FOR SPECIFIC RECORD DETAILS:
Call ocx_query, then FIND the matching record and describe it in a formatted response:

**Lead: [Name]**
- Company: [company]
- Email: [email]
- Phone: [phone]
- Status: [status]
- Owner: [owner]

Example:
User: "details about Rock Petro at BrightGrid"
â†’ Call ocx_query(resource="leads", limit=20)
â†’ Find "Rock Petro" or "BrightGrid" in results
â†’ Respond with formatted details of ONLY that lead

## CRITICAL RULES:
1. For detail queries: Show ONE record's details in formatted text, not a list
2. For list queries: Brief confirmation is enough (widget shows the data)
3. NEVER say "not found" if the record exists in the returned data
4. Search by partial name match (Rock matches "Rock Petro")`;

// System prompt for Oracle CX Sales Cloud mode
const ORACLE_CX_MODE_SYSTEM_PROMPT = `You are IRIS Sales GPT, an AI-first sales assistant integrated with Oracle CX Sales Cloud.

CURRENT DATE: {{CURRENT_DATE_TIME}}

**LOGGED-IN USER CONTEXT (SALES AGENT):**
- Name: {{USER_NAME}}
- Email: {{USER_EMAIL}}
- Title: {{USER_TITLE}}

**EMAIL SIGNATURE INSTRUCTIONS (CRITICAL):**
When composing, drafting, or sending any emails:
1. ALWAYS use the logged-in user's ACTUAL name ({{USER_NAME}}) and email ({{USER_EMAIL}}) in signatures
2. NEVER use placeholder text like "[Your Name]", "[Your Position]", "[Your Email]", or similar
3. Use a professional signature format like:
   Best regards,
   {{USER_NAME}}
   {{USER_TITLE}}
   {{USER_EMAIL}}

**AI COACHING & INSIGHTS TOOLS (USE THESE FIRST FOR COACHING REQUESTS):**
When users ask about performance, coaching, or insights, ALWAYS use these specialized tools instead of ocx_query:

- "How am I doing?" / "Analyze my performance" / "Give me coaching tips" â†’ **get_sales_coaching** (provides personalized analysis)
- "What deals are at risk?" / "Pipeline health" / "Stalled deals" â†’ **get_deal_health** (analyzes deal health scores)
- "How is [account] doing?" / "Account health" â†’ **get_account_intelligence** (account health analysis)
- "What should I focus on?" / "AI insights" / "Recommendations" â†’ **get_my_ai_insights** (prioritized alerts)

These tools analyze LOCAL data and provide intelligent coaching - DO NOT use ocx_query for these requests.

**DATA SOURCE: ORACLE CX SALES CLOUD (EXTERNAL CRM)**
CRITICAL: You are currently connected to the user's ORACLE CX Sales Cloud org. For standard CRM queries (list leads, opportunities, contacts), use Oracle CX tools (ocx_query, ocx_get_record, etc.) to fetch FRESH data. IGNORE any data from previous messages in this conversation that may have come from a different data source. Always execute tools to get current data.

ANTI-HALLUCINATION RULES (CRITICAL - NEVER VIOLATE):
1. ONLY reference data that was ACTUALLY returned by tool calls. NEVER invent record names, amounts, dates, or any other data.
2. If tool returns 5 opportunities, only mention those exact 5 - never fabricate additional ones.
3. If you don't have data from a tool result, say "I don't have that information" - NEVER guess or make up data.
4. Opportunity names, Lead names, Account names must be COPIED EXACTLY from tool results - never paraphrased or invented.

SPEED RULES:
1. NO preamble. NO "Let me search". Just execute tools immediately.
2. Keep responses concise - focus on insights and recommendations.
3. Execute multiple tools in PARALLEL when possible.

ORACLE CX QUERY SYNTAX:
Oracle CX uses REST API with SCIM filter syntax for queries:
- Text search: q="Name co 'Acme'" (co = contains)
- Equality: q="Status eq 'Open'"
- Date range: q="CloseDate ge '2026-01-01' and CloseDate le '2026-12-31'"
- Logical operators: and, or, not
- Comparison: eq, ne, gt, ge, lt, le, co (contains), sw (starts with)

COMMON ORACLE CX RESOURCES AND IDs (CRITICAL - USE CORRECT ID FIELD):
- **leads**: LeadId (NOT LeadNumber!), Name, CustomerPartyName, StatusCode, Score
  - For ocx_get_record, use LeadId (e.g., 300000086856865), NOT LeadNumber
- **opportunities**: OptyId (NOT OptyNumber!), Name, Revenue, WinProb, SalesStage, CloseDate
  - For ocx_get_record, use OptyId, NOT OptyNumber
- **accounts**: PartyId, OrganizationName, Type, Industry, AnnualRevenue
- **contacts**: PartyId, PersonFirstName, PersonLastName, EmailAddress, JobTitle
- **activities**: ActivityId, Subject, ActivityType, DueDate, Status

IMPORTANT: When calling ocx_get_record, ALWAYS use the long numeric ID (LeadId, OptyId, PartyId) NOT the short reference number (LeadNumber, OptyNumber)!

DYNAMIC FIELD DISCOVERY FOR CREATE/UPDATE OPERATIONS (CRITICAL):
When creating or updating Oracle CX records, ALWAYS discover fields dynamically:

1. FIRST: Call ocx_describe_resource(resource='leads/opportunities/contacts/accounts') to get available fields
2. Look for fields with "mandatory": true or "inputRequired": true for required fields
3. Look for fields with "updatable": true for fields you can set
4. Map user-provided data to the exact Oracle CX field names from the schema

COMMON FIELD PATTERNS (use as hints, but verify with describe):
- Contact names often use PersonFirstName/PersonLastName (not FirstName/LastName)
- Email fields often use EmailAddress suffix (e.g., PrimaryContactEmailAddress)
- Phone fields often use PhoneNumber suffix
- Lead required field is typically "Name"

WORKFLOW FOR CREATING A RECORD:
1. If user asks to create a lead/contact/etc, call ocx_describe_resource first
2. Parse the schema to find matching fields for the user's data
3. Call ocx_create_record with the correct Oracle CX field names
4. Report success with the created record ID

Example workflow:
- User: "Create a lead for John Smith at Acme Corp with email john@acme.com"
- AI: 1) Call ocx_describe_resource(resource='leads') to get schema
      2) Find matching fields: Name, CustomerPartyName, PrimaryContactPersonFirstName, PrimaryContactPersonLastName, PrimaryContactEmailAddress
      3) Call ocx_create_record(resource='leads', fields={"Name": "John Smith - Acme Corp", "CustomerPartyName": "Acme Corp", "PrimaryContactPersonFirstName": "John", "PrimaryContactPersonLastName": "Smith", "PrimaryContactEmailAddress": "john@acme.com"})
      4) Report success

CRITICAL - EXTRACT NUMERIC LIMITS FROM USER QUERIES:
When users specify a number in their query, ALWAYS extract and pass it as the limit parameter:
- "top 3 leads" â†’ ocx_query with resource='leads', limit=3
- "show me 5 opportunities" â†’ ocx_query with resource='opportunities', limit=5
- "what are my 4 biggest deals" â†’ ocx_query with orderBy='Revenue:desc', limit=4
NEVER ignore the user's requested count - if they ask for 3, return exactly 3 (not 5 or 10).

SHORT FOLLOW-UP QUERY HANDLING (CRITICAL):
When user sends a short message referencing previous results:
- "Lead record" or "the lead" â†’ Show FULL DETAILS of the Lead record just mentioned (use ocx_get_record with LeadId)
- "Contact record" â†’ Show FULL DETAILS of the Contact record just mentioned
- "Account record" â†’ Show FULL DETAILS of the Account record just mentioned
- "Opportunity record" or "the deal" â†’ Show FULL DETAILS of the Opportunity record just mentioned
- "Update the opportunity" or "change stage" â†’ Use the Opportunity ID from the previous results

DETAIL QUERY BY NAME (CRITICAL):
When user asks "Show me details about [Name]" or "Tell me about [Name]":
- LOOK UP the LeadId/OptyId from the PREVIOUS query results in this conversation
- Use ocx_get_record with the ID from the previous results, NOT another ocx_query
- Example: User asks "top 3 leads" â†’ you return leads including "Rock Petro" with LeadId=12345
- Then user asks "Show me details about Rock Petro" â†’ use ocx_get_record(resource='leads', recordId='12345')
- NEVER do another ocx_query for the same records - use the IDs you already have!

OPPORTUNITY UPDATE FLOW (CRITICAL FOR ORACLE CX):
When updating an opportunity mentioned in conversation:
1. CHECK if you already have the Opportunity ID from a previous query
2. If YES: Use that ID directly with ocx_update_opportunity
3. If NO: First query to get the ID: ocx_query(resource='opportunities', filters=...)
4. NEVER guess or make up an ID - always get it from query results

AVAILABLE TOOLS:
- ocx_query: Query Oracle CX data with filters
- ocx_get_record: Get single record by ID
- ocx_create_lead/opportunity/contact/account/task: Create records
- ocx_update_record: Update any record
- ocx_describe_resource: Get field metadata
- research_company: Web research for company info
- send_email: Send email directly
- schedule_meeting: Schedule video meetings
- compute_analytics: Calculate sales metrics
- get_sales_coaching: Personalized coaching based on user's pipeline
- get_deal_health: Analyze deal health and risk factors
- get_account_intelligence: Account health scores and engagement
- get_my_ai_insights: AI-generated alerts and recommendations

**RESPONSE FORMATTING (CRITICAL):**
- NEVER use emojis of any kind - this is a professional enterprise application
- Start with a **bold summary** of what was found
- Use **bold** for labels: **Insight:** or **Recommendation:**
- Keep responses concise and actionable

**CRITICAL BEHAVIOR RULES:**
1. ALWAYS USE TOOLS - Never make up CRM data. Always call the appropriate tool.
2. TAKE ACTION - When user asks you to do something, DO IT. Don't say "I can't" unless the tool genuinely fails.
3. CONFIRM ACTIONS - After doing something, confirm briefly: "Done! Lead created" or "Record updated"
4. BE PROACTIVE - After completing an action, suggest next steps`;

@Injectable()
export class ConversationsService {
  private readonly logger = new Logger(ConversationsService.name);

  // Cache for enhanced prompts (refreshed periodically)
  private enhancedPromptCache: { prompt: string; timestamp: number } | null = null;
  private readonly PROMPT_CACHE_TTL = 5 * 60 * 1000; // 5 minutes

  constructor(
    private readonly prisma: PrismaService,
    private readonly anthropic: AnthropicService,
    private readonly aiSdk: AiSdkService,
    private readonly queryRouter: QueryRouterService,
    private readonly leadsService: LeadsService,
    private readonly opportunitiesService: OpportunitiesService,
    private readonly accountsService: AccountsService,
    private readonly searchService: SearchService,
    private readonly financialDataService: FinancialDataService,
    private readonly pageIndexService: PageIndexService,
    private readonly feedbackService: FeedbackService,
    private readonly meetingsService: MeetingsService,
    private readonly emailService: EmailService,
    private readonly emailTrackingService: EmailTrackingService,
    private readonly quotesService: QuotesService,
    private readonly contractsService: ContractsService,
    private readonly campaignsService: CampaignsService,
    private readonly notesService: NotesService,
    private readonly tasksService: TasksService,
    private readonly salesforceService: SalesforceService,
    private readonly oracleCXService: OracleCXService,
    private readonly smartDataAnalyzer: SmartDataAnalyzerService,
    private readonly analyticsService: AnalyticsService,
    private readonly usageTrackingService: UsageTrackingService,
    private readonly toolRouter: ToolRouterService,
    private readonly llmCompiler: LLMCompilerService,
    private readonly toolEmbeddings: ToolEmbeddingsService,
    private readonly irisOptimizer: IrisOptimizerService,
    private readonly irisRank: IRISRankService,
    private readonly speculativeCascade: SpeculativeCascadeService,
    private readonly responseGrounding: ResponseGroundingService,
    private readonly localSLM: LocalSLMService,
    private readonly signalsService: SignalsService,
  ) { }

  /**
   * Get IRIS Optimizer statistics for monitoring and analytics
   * Exposes metrics like deterministic hit rate, cache performance, and latency savings
   */
  getOptimizerStats() {
    return {
      optimizer: this.irisOptimizer.getStats(),
      cascade: this.speculativeCascade.getStats(),
    };
  }

  /**
   * Ground AI response against tool execution facts
   *
   * This method verifies AI-generated responses against the actual tool results
   * to prevent hallucinations. It extracts claims from the response (e.g., "email sent",
   * "meeting scheduled"), verifies them against the facts returned by tools, and
   * removes or corrects any ungrounded claims.
   *
   * Risk-level handling:
   * - CRITICAL: Replace AI response with verified_response entirely
   * - HIGH: Remove contradictory claims, replace with verified_response if tool failed
   * - MEDIUM: Add confidence warnings for low-confidence claims
   * - LOW: Audit only, no modifications
   *
   * @example
   * ```typescript
   * // After tool execution:
   * const groundedResult = await this.groundAiResponse(
   *   aiGeneratedText,
   *   [emailToolResult, meetingToolResult],
   * );
   *
   * if (groundedResult.wasModified) {
   *   this.logger.warn(`[GROUNDING] Removed claims: ${groundedResult.removedClaims.map(c => c.text).join(', ')}`);
   * }
   *
   * return groundedResult.response;
   * ```
   */
  private async groundAiResponse(
    aiResponse: string,
    toolResults: GroundedToolResult[],
  ): Promise<GroundingResult> {
    // Get highest risk level from all tool results
    const riskLevel = this.responseGrounding.getHighestRiskLevel(toolResults);

    // Ground the response
    const result = await this.responseGrounding.groundResponse(
      aiResponse,
      toolResults,
      riskLevel,
    );

    // Log audit entries
    for (const entry of result.auditTrail) {
      this.responseGrounding.logAuditEntry(entry);
    }

    // Log if response was modified
    if (result.wasModified) {
      this.logger.warn(
        `[GROUNDING] Modified AI response. Risk: ${riskLevel}, ` +
        `Removed: ${result.removedClaims.length}, ` +
        `Corrected: ${result.correctedClaims.length}`
      );

      if (result.removedClaims.length > 0) {
        this.logger.warn(
          `[GROUNDING] Removed claims: ${result.removedClaims.map(c => c.text).join(', ')}`
        );
      }
    }

    return result;
  }

  /**
   * RLHF Course Correction: Dynamically enhance system prompt with learned examples
   * This injects golden examples and negative pattern avoidance based on user feedback
   * Also injects user context (name, email) for personalized responses and email signatures
   */
  private async getEnhancedSystemPrompt(basePrompt: string, category?: string, userId?: string): Promise<string> {
    try {
      // Fetch user data for personalization (not cached - user context is per-request)
      let userName = 'Sales Representative';
      let userEmail = '';
      let userTitle = 'Sales Representative';
      
      if (userId) {
        try {
          const user = await this.prisma.user.findUnique({
            where: { id: userId },
            select: { name: true, email: true },
          });
          if (user) {
            userName = user.name || 'Sales Representative';
            userEmail = user.email || '';
            // For now, use a default title since User model doesn't have title field
            userTitle = 'Sales Representative';
          }
        } catch (err) {
          this.logger.warn(`Failed to fetch user data for prompt enhancement: ${err.message}`);
        }
      }

      // Check cache first (but we'll still need to inject user-specific data)
      let enhancedPrompt: string;
      if (
        this.enhancedPromptCache &&
        Date.now() - this.enhancedPromptCache.timestamp < this.PROMPT_CACHE_TTL
      ) {
        enhancedPrompt = this.enhancedPromptCache.prompt;
      } else {
        // Get golden examples for few-shot learning
        const goldenExamples = await this.feedbackService.getGoldenExamples(category, 2);

        // Get negative patterns to avoid (from recent negative feedback)
        const negativePatterns = await this.getNegativeFeedbackPatterns();

        enhancedPrompt = basePrompt;

        // Add golden examples section if available
        if (goldenExamples.length > 0) {
          const examplesSection = `

LEARNED FROM USER FEEDBACK - HIGH-QUALITY RESPONSE EXAMPLES:
The following are examples of responses that users rated highly. Use these as reference for tone, structure, and level of detail:

${goldenExamples.map((ex, i) => `Example ${i + 1}:
User: "${ex.userQuery}"
Good Response Style: "${ex.assistantResponse.substring(0, 500)}${ex.assistantResponse.length > 500 ? '...' : ''}"
`).join('\n')}
`;
          enhancedPrompt += examplesSection;
        }

        // Add negative patterns section if available
        if (negativePatterns.length > 0) {
          const avoidSection = `

FEEDBACK-BASED CORRECTIONS - PATTERNS TO AVOID:
Users have indicated these response patterns are unhelpful. Avoid these behaviors:
${negativePatterns.map((p, i) => `${i + 1}. ${p}`).join('\n')}
`;
          enhancedPrompt += avoidSection;
        }

        // Cache the enhanced prompt (without user-specific replacements)
        this.enhancedPromptCache = {
          prompt: enhancedPrompt,
          timestamp: Date.now(),
        };

        // Only log if there are enhancements
        if (goldenExamples.length > 0 || negativePatterns.length > 0) {
          this.logger.debug(`Enhanced prompt with ${goldenExamples.length} golden examples and ${negativePatterns.length} negative patterns`);
        }
      }

      // Inject current date/time dynamically into the prompt
      const now = new Date();
      const dateString = `${now.toISOString()} (${now.toLocaleDateString('en-US', { weekday: 'long', year: 'numeric', month: 'long', day: 'numeric', hour: 'numeric', minute: 'numeric', timeZoneName: 'short' })})`;
      enhancedPrompt = enhancedPrompt.replace('{{CURRENT_DATE_TIME}}', dateString);
      
      // Inject user context for personalized responses and email signatures
      enhancedPrompt = enhancedPrompt.replace(/\{\{USER_NAME\}\}/g, userName);
      enhancedPrompt = enhancedPrompt.replace(/\{\{USER_EMAIL\}\}/g, userEmail);
      enhancedPrompt = enhancedPrompt.replace(/\{\{USER_TITLE\}\}/g, userTitle);

      return enhancedPrompt;
    } catch (error) {
      this.logger.warn(`Failed to enhance prompt with RLHF data: ${error.message}`);
      return basePrompt; // Fallback to base prompt
    }
  }

  /**
   * Extract patterns from negative feedback to avoid
   */
  private async getNegativeFeedbackPatterns(): Promise<string[]> {
    try {
      const negativeFeedback = await this.prisma.feedbackEntry.findMany({
        where: { rating: 'NEGATIVE' },
        orderBy: { createdAt: 'desc' },
        take: 10,
        select: {
          comment: true,
          userQuery: true,
          category: true,
        },
      });

      // Extract actionable patterns from comments
      const patterns: string[] = [];

      for (const feedback of negativeFeedback) {
        if (feedback.comment) {
          // User provided explicit feedback
          patterns.push(`When asked about "${feedback.category || 'general'}" topics: ${feedback.comment}`);
        }
      }

      // Deduplicate and limit
      return [...new Set(patterns)].slice(0, 5);
    } catch (error) {
      return [];
    }
  }

  async listConversations(userId: string, isAdmin?: boolean) {
    // Always scope to current user's conversations
    // Personal conversation history should be personal, even for admins
    // Admins can view all conversations via a separate admin panel if needed
    return this.prisma.conversation.findMany({
      where: { userId },
      orderBy: { updatedAt: 'desc' },
      include: {
        messages: {
          orderBy: { createdAt: 'asc' },
        },
      },
    });
  }

  async getConversation(conversationId: string, userId: string, isAdmin?: boolean) {
    const where: any = { id: conversationId };
    if (!isAdmin) {
      where.userId = userId;
    }
    const conversation = await this.prisma.conversation.findFirst({
      where,
      include: {
        messages: {
          orderBy: { createdAt: 'asc' },
        },
      },
    });

    if (!conversation) {
      throw new NotFoundException('Conversation not found');
    }

    return conversation;
  }

  async createConversation(dto: CreateConversationDto, userId: string) {
    const title = dto.title?.trim() || 'New Conversation';

    return this.prisma.conversation.create({
      data: {
        title,
        userId,
      },
    });
  }

  async sendMessage(conversationId: string, content: string, userId: string, isAdmin?: boolean, mode?: string) {
    const where: any = { id: conversationId };
    if (!isAdmin) {
      where.userId = userId;
    }
    const conversation = await this.prisma.conversation.findFirst({
      where,
    });

    if (!conversation) {
      throw new NotFoundException('Conversation not found');
    }

    const cleanContent = content.trim();

    // Detect the CRM mode - priority order:
    // 1. Explicit mode parameter from request
    // 2. User's saved preference from database
    // 3. Message prefix (backward compatibility)
    // 4. Default to 'local'
    let effectiveMode = mode;

    // If no explicit mode, fetch user's saved preference from database
    if (!effectiveMode) {
      const userSettings = await this.prisma.user.findUnique({
        where: { id: userId },
        select: { settings: true },
      });
      const savedCrmDataSource = (userSettings?.settings as any)?.crmDataSource;
      if (savedCrmDataSource === 'salesforce' || savedCrmDataSource === 'oracle_cx' || savedCrmDataSource === 'oracle' || savedCrmDataSource === 'local') {
        effectiveMode = savedCrmDataSource;
        this.logger.warn(`[CRM_MODE] Using user's saved preference: "${effectiveMode}"`);
      }
    }

    let isDocumentSearchMode = effectiveMode === 'documents';
    let isSalesforceMode = effectiveMode === 'salesforce';
    let isOracleCXMode = effectiveMode === 'oracle_cx' || effectiveMode === 'oracle';

    // Backward compatibility: also detect from message prefix (for web app legacy support)
    if (!effectiveMode) {
      isDocumentSearchMode = cleanContent.toLowerCase().startsWith('[document_search_mode]');
      isSalesforceMode = cleanContent.toLowerCase().startsWith('[salesforce_mode]');
      isOracleCXMode = cleanContent.toLowerCase().startsWith('[oracle_cx_mode]');
    }

    // Strip mode prefixes for display (if present)
    let displayContent = cleanContent;
    if (cleanContent.toLowerCase().startsWith('[document_search_mode]')) {
      displayContent = cleanContent.replace(/^\[DOCUMENT_SEARCH_MODE\]\s*/i, '').trim();
    } else if (cleanContent.toLowerCase().startsWith('[salesforce_mode]')) {
      displayContent = cleanContent.replace(/^\[SALESFORCE_MODE\]\s*/i, '').trim();
    } else if (cleanContent.toLowerCase().startsWith('[oracle_cx_mode]')) {
      displayContent = cleanContent.replace(/^\[ORACLE_CX_MODE\]\s*/i, '').trim();
    }

    const userMessage = await this.prisma.message.create({
      data: {
        conversationId: conversation.id,
        role: MessageRole.USER,
        content: displayContent, // Store without the prefix for cleaner history
        suggestedFollowUps: [],
      },
    });

    // Update title if this is the first user message and no custom title provided
    if (conversation.title === 'New Conversation') {
      await this.prisma.conversation.update({
        where: { id: conversation.id },
        data: { title: this.generateTitle(displayContent) },
      });
    }

    const history = await this.prisma.message.findMany({
      where: { conversationId: conversation.id },
      orderBy: { createdAt: 'asc' },
    });

    // Select tools and prompt based on mode:
    // - Document mode: Document-only tools for PDF search
    // - Salesforce mode: Salesforce CRM tools for external CRM
    // - Oracle CX mode: Oracle CX Sales Cloud tools for external CRM
    // - Default (Local/Globe): Local CRM tools
    let baseSystemPrompt: string;
    let activeTools: any[];
    let promptCategory: string | undefined;

    if (isDocumentSearchMode) {
      baseSystemPrompt = DOCUMENT_MODE_SYSTEM_PROMPT;
      activeTools = DOCUMENT_ONLY_TOOLS;
      promptCategory = 'document_search';
    } else if (isSalesforceMode) {
      baseSystemPrompt = SALESFORCE_MODE_SYSTEM_PROMPT;
      activeTools = SALESFORCE_TOOLS;
      promptCategory = 'salesforce';
    } else if (isOracleCXMode) {
      baseSystemPrompt = ORACLE_CX_MODE_SYSTEM_PROMPT;
      activeTools = ORACLE_CX_TOOLS;
      promptCategory = 'oracle_cx';
    } else {
      baseSystemPrompt = CRM_ONLY_SYSTEM_PROMPT;
      activeTools = CRM_ONLY_TOOLS;
      promptCategory = undefined;
    }

    // SLM Optimization: Use query routing to reduce tokens for Oracle CX mode
    // This significantly speeds up Local SLM inference by reducing prompt size
    if (isOracleCXMode && !isDocumentSearchMode) {
      try {
        const routingDecision = await this.queryRouter.routeQuery(cleanContent);
        if (routingDecision && routingDecision.toolSubset !== null) {
          // Use minimal prompt for simple queries (reduces tokens by ~80%)
          if (routingDecision.systemPromptKey === 'minimal' || routingDecision.systemPromptKey === 'crm-only') {
            baseSystemPrompt = ORACLE_CX_MINIMAL_PROMPT;
            // Filter to only essential Oracle CX tools
            activeTools = ORACLE_CX_TOOLS.filter(t =>
              ['ocx_query', 'ocx_get_record'].includes(t.name)
            );
            this.logger.log(`[SLM_OPT] Using MINIMAL prompt + ${activeTools.length} tools for simple Oracle CX query`);
          }
        }
      } catch (routerError) {
        this.logger.warn('Query router failed, using full prompt', routerError);
      }
    }

    // RLHF: Enhance prompt with learned golden examples and negative pattern avoidance
    // Also injects user context (name, email) for personalized email signatures
    const activeSystemPrompt = await this.getEnhancedSystemPrompt(
      baseSystemPrompt,
      promptCategory,
      userId
    );


    const anthropicMessages = [
      { role: 'system' as const, content: activeSystemPrompt },
      ...history.map((message) => ({
        role: message.role.toLowerCase() as 'user' | 'assistant' | 'system',
        content: message.content,
      })),
    ];

    // Track document sources used in this response
    const documentSources: DocumentSource[] = [];

    // Detect intent for tool forcing
    // This ensures certain operations use the correct tool instead of the AI choosing alternatives
    let toolChoice: 'auto' | { type: 'function'; function: { name: string } } = 'auto';

    // Force sf_create_report for report creation requests (Salesforce mode only)
    if (isSalesforceMode) {
      const reportCreationPatterns = [
        /create\s+(a\s+)?salesforce\s+report/i,
        /create\s+(a\s+)?report\s+(in|for)\s+salesforce/i,
        /create\s+(a\s+)?report\s+called/i,
        /save\s+(this\s+)?(as\s+)?(a\s+)?salesforce\s+report/i,
        /build\s+(me\s+)?(a\s+)?sf\s+report/i,
        /create\s+(a\s+)?sf\s+report/i,
      ];

      const isReportCreationRequest = reportCreationPatterns.some(pattern => pattern.test(cleanContent));

      if (isReportCreationRequest) {
        this.logger.warn(`[TOOL_FORCING] Detected report creation intent, forcing sf_create_report tool`);
        toolChoice = { type: 'function', function: { name: 'sf_create_report' } };
      }
    }

    // Track AI call timing for usage analytics
    const aiCallStartTime = Date.now();

    // Try Azure OpenAI first (better quality), fallback to Local SLM on rate limits/errors
    let aiResult;
    let usedLocalSLM = false;

    try {
      this.logger.debug('Trying Azure OpenAI as primary...');
      aiResult = await this.anthropic.generateChatCompletionWithTools({
        messages: anthropicMessages,
        tools: activeTools,
        toolChoice,
      });
      this.logger.log(`Azure OpenAI completed in ${Date.now() - aiCallStartTime}ms`);
    } catch (azureError: any) {
      // Fallback to Local SLM if Azure fails (rate limits, timeouts, etc.)
      if (this.localSLM.available) {
        this.logger.warn(`Azure OpenAI failed (${azureError.message}), falling back to Local SLM...`);
        try {
          aiResult = await this.localSLM.generateChatCompletionWithTools({
            messages: anthropicMessages,
            tools: activeTools,
            toolChoice,
          });
          usedLocalSLM = true;
          this.logger.log(`Local SLM fallback completed in ${Date.now() - aiCallStartTime}ms`);
        } catch (slmError: any) {
          // Both failed - re-throw the original Azure error
          this.logger.error(`Local SLM fallback also failed: ${slmError.message}`);
          throw azureError;
        }
      } else {
        // No SLM available, re-throw Azure error
        throw azureError;
      }
    }

    // Track LLM usage for cost analysis
    const aiCallDuration = Date.now() - aiCallStartTime;
    
    // Always log usage - even if token counts aren't available from SDK
    // Get user info for tracking
    const userForTracking = await this.prisma.user.findUnique({ where: { id: userId }, select: { email: true, name: true } });
    
    // Estimate tokens if not provided (rough estimate: ~4 chars per token)
    const estimatedInputTokens = aiResult.usage?.inputTokens || Math.ceil(JSON.stringify(anthropicMessages).length / 4);
    const estimatedOutputTokens = aiResult.usage?.outputTokens || 0; // Will be updated after response
    
    this.usageTrackingService.logUsage({
      userId,
      userName: userForTracking?.name || undefined,
      userEmail: userForTracking?.email || undefined,
      serviceType: usedLocalSLM ? ApiServiceType.OTHER : ApiServiceType.LLM_CLAUDE,
      serviceName: usedLocalSLM ? 'granite-3.1-3b-local' : 'claude-3-sonnet',
      operation: isSalesforceMode ? 'salesforce_conversation' : isDocumentSearchMode ? 'document_search' : 'crm_conversation',
      inputTokens: estimatedInputTokens,
      outputTokens: estimatedOutputTokens,
      totalTokens: estimatedInputTokens + estimatedOutputTokens,
      latencyMs: aiCallDuration,
      conversationId,
      success: true,
      metadata: {
        mode: isSalesforceMode ? 'salesforce' : isDocumentSearchMode ? 'document' : isOracleCXMode ? 'oracle_cx' : 'local',
        toolRequested: aiResult.type === 'tool_use' ? aiResult.toolName : null,
        usageFromSdk: !!aiResult.usage,
        usedLocalSLM,
      },
    }).catch(err => this.logger.error(`Failed to log AI usage: ${err.message}`));

    let assistantResponse = '';
    // Collect grounded tool results for response verification
    const groundedToolResults: GroundedToolResult[] = [];
    // Collect structured widget data for frontend rendering
    const widgetDataList: WidgetData[] = [];

    // Handle tool use
    if (aiResult.type === 'tool_use' && aiResult.toolName) {
      // IMPORTANT: Pass dataSource to enforce CRM mode (local vs salesforce vs oracle_cx)
      const dataSource = isSalesforceMode ? 'salesforce' : isOracleCXMode ? 'oracle_cx' : 'local';
      this.logger.log(`Executing tool: ${aiResult.toolName} with dataSource=${dataSource}`);
      const toolResult = await this.executeTool(aiResult.toolName, aiResult.toolInput || {}, userId, dataSource);

      // Extract widget data from tool result for frontend rendering
      const widgetData = this.extractWidgetDataFromToolResult(aiResult.toolName, toolResult, aiResult.toolInput);
      if (widgetData) {
        widgetDataList.push(widgetData);
      }

      // Check if tool returned a grounded result (has risk_level and facts)
      if (toolResult.risk_level && toolResult.facts) {
        groundedToolResults.push(toolResult as GroundedToolResult);
      }

      this.logger.log(`Tool ${aiResult.toolName} executed successfully:`, JSON.stringify(toolResult).substring(0, 200));

      // Format the tool result in a clear, structured way for the AI to understand
      let toolResultText = '';

      if (toolResult.success === false) {
        toolResultText = `Error: ${toolResult.error || toolResult.message || 'Unknown error'}`;
      } else if (toolResult.data) {
        // Format the data in a readable way
        if (Array.isArray(toolResult.data)) {
          toolResultText = `${toolResult.message || 'Results'}:\n\n`;
          toolResultText += JSON.stringify(toolResult.data, null, 2);
          toolResultText += `\n\nTotal items: ${toolResult.data.length}`;
          if (toolResult.count !== undefined) {
            toolResultText += `\nTotal in database: ${toolResult.count}`;
          }
        } else {
          toolResultText = `${toolResult.message || 'Result'}:\n\n`;
          toolResultText += JSON.stringify(toolResult.data, null, 2);
        }
      } else if (toolResult.threads) {
        // Email tracking tools return 'threads' instead of 'data'
        toolResultText = `${toolResult.message || 'Email Threads'}:\n\n`;
        toolResultText += JSON.stringify(toolResult.threads, null, 2);
        toolResultText += `\n\nTotal: ${toolResult.count || toolResult.threads.length}`;
        if (toolResult.overdueCount !== undefined) {
          toolResultText += `\nOverdue: ${toolResult.overdueCount}`;
        }
      } else if (toolResult.drafts) {
        // Email draft tools return 'drafts'
        toolResultText = `${toolResult.message || 'Email Drafts'}:\n\n`;
        toolResultText += JSON.stringify(toolResult.drafts, null, 2);
        toolResultText += `\n\nTotal: ${toolResult.count || toolResult.drafts.length}`;
      } else {
        toolResultText = toolResult.message || JSON.stringify(toolResult, null, 2);
      }

      // Determine if this is a document-related tool for special handling
      const isDocumentTool = ['search_document', 'get_document_summary', 'get_document_structure', 'list_indexed_documents'].includes(aiResult.toolName);

      // CHAINED TOOL CALLING: If we listed documents but user asked about specific content,
      // automatically search the relevant document
      if (aiResult.toolName === 'list_indexed_documents' && toolResult.success && toolResult.data?.documents?.length > 0) {
        const shouldChainSearch = this.shouldSearchDocumentContent(cleanContent, toolResult.data.documents);
        if (shouldChainSearch) {
          this.logger.log(`Chaining search_document for: ${shouldChainSearch.documentId}, query: ${shouldChainSearch.query}`);
          const searchResult = await this.executeTool('search_document', {
            documentId: shouldChainSearch.documentId,
            query: shouldChainSearch.query,
            maxResults: 5,
          }, userId);

          if (searchResult.success && searchResult.data?.results?.length > 0) {
            // Replace the tool result with search results
            toolResultText = `Document found and searched. Search results for "${shouldChainSearch.query}" in ${shouldChainSearch.filename}:\n\n`;
            toolResultText += JSON.stringify(searchResult.data, null, 2);

            // Extract sources from search results
            await this.extractDocumentSources('search_document', { documentId: shouldChainSearch.documentId }, searchResult, documentSources);
          } else {
            // Also try get_document_summary if search didn't find specific results
            const summaryResult = await this.executeTool('get_document_summary', {
              documentId: shouldChainSearch.documentId,
            }, userId);
            if (summaryResult.success) {
              toolResultText = `Document summary for ${shouldChainSearch.filename}:\n\n`;
              toolResultText += JSON.stringify(summaryResult.data, null, 2);
              await this.extractDocumentSources('get_document_summary', { documentId: shouldChainSearch.documentId }, summaryResult, documentSources);
            }
          }
        }
      }

      // Extract document sources from tool results for attribution
      if (isDocumentTool && toolResult.success && toolResult.data) {
        await this.extractDocumentSources(aiResult.toolName, aiResult.toolInput, toolResult, documentSources);
      }

      // Generate a natural language response about the tool execution
      // Use 'user' role to provide tool results as system feedback, not 'assistant' which confuses the model
      // Azure OpenAI can handle larger contexts, SLM needs aggressive truncation
      const maxToolResultChars = 32000; // Azure can handle ~100K tokens
      let truncatedToolResultText = toolResultText;

      // Smart compaction for Oracle CX records - extract only essential fields
      if (toolResultText.length > maxToolResultChars && toolResult.data?.records) {
        const records = toolResult.data.records;
        const compactRecords = records.map((rec: any, idx: number) => {
          // Extract only the most important fields for each record type
          const essential: any = { '#': idx + 1 };
          if (rec.Name) essential.Name = rec.Name;
          if (rec.LeadId) essential.LeadId = rec.LeadId;
          if (rec.OptyId) essential.OptyId = rec.OptyId;
          if (rec.CustomerPartyName) essential.Company = rec.CustomerPartyName;
          if (rec.EmailAddress) essential.Email = rec.EmailAddress;
          if (rec.StatusCode) essential.Status = rec.StatusCode;
          if (rec.Revenue) essential.Revenue = rec.Revenue;
          if (rec.SalesStage) essential.Stage = rec.SalesStage;
          return essential;
        });
        truncatedToolResultText = `${toolResult.message || 'Results'}:\n\n`;
        truncatedToolResultText += JSON.stringify(compactRecords, null, 2);
        truncatedToolResultText += `\n\nTotal: ${records.length} records (compacted view - key fields only)`;
        this.logger.log(`[SMART_COMPACT] Reduced ${records.length} records from ${toolResultText.length} to ${truncatedToolResultText.length} chars`);
      } else if (toolResultText.length > maxToolResultChars) {
        truncatedToolResultText = toolResultText.substring(0, maxToolResultChars) + '\n\n... (Results truncated. Showing first items.)';
        this.logger.warn(`Tool result truncated from ${toolResultText.length} to ${maxToolResultChars} chars`);
      }

      // ==========================================================================
      // DETERMINISTIC RESPONSE GENERATION
      // For CRM queries, generate response from template instead of AI
      // This eliminates prompt engineering issues and ensures consistent output
      // ==========================================================================
      let finalResponse: string | null = null;

      // Check if this is a detail query (user asking about a specific record)
      const userQuery = cleanContent.toLowerCase();
      const isDetailQuery = /\b(details?|about|info|information)\b.*\b(lead|opportunity|account|contact)\b/i.test(userQuery) ||
                           /\b(lead|opportunity|account|contact)\b.*\b(details?|about|info)\b/i.test(userQuery);

      // Try deterministic response for CRM queries with records
      if (aiResult.toolName === 'ocx_query' && toolResult.data?.records?.length > 0 && !isDocumentTool) {
        const records = toolResult.data.records;
        const resourceType = aiResult.toolInput?.resource || 'records';

        if (isDetailQuery) {
          // Extract search terms from user query (names, companies)
          const searchTerms = userQuery
            .replace(/show|me|details?|about|the|lead|opportunity|account|contact|at|info|information/gi, '')
            .trim()
            .split(/\s+/)
            .filter(term => term.length > 2);

          // Find matching record
          const matchedRecord = records.find((rec: any) => {
            const recordText = JSON.stringify(rec).toLowerCase();
            return searchTerms.some(term => recordText.includes(term.toLowerCase()));
          });

          if (matchedRecord) {
            // Generate formatted response from template
            const name = matchedRecord.Name || `${matchedRecord.PrimaryContactPersonFirstName || ''} ${matchedRecord.PrimaryContactPersonLastName || ''}`.trim();
            const company = matchedRecord.CustomerPartyName || matchedRecord.CompanyName || '';
            const email = matchedRecord.EmailAddress || matchedRecord.PrimaryContactEmailAddress || '';
            const phone = matchedRecord.PhoneNumber || matchedRecord.PrimaryContactPhoneNumber || '';
            const status = matchedRecord.StatusCode || '';
            const owner = matchedRecord.OwnerPartyName || '';

            let response = `**${name}**\n`;
            if (company) response += `- **Company:** ${company}\n`;
            if (email) response += `- **Email:** ${email}\n`;
            if (phone) response += `- **Phone:** ${phone}\n`;
            if (status) response += `- **Status:** ${status}\n`;
            if (owner) response += `- **Owner:** ${owner}\n`;

            finalResponse = response.trim();
            this.logger.log(`[DETERMINISTIC] Generated detail response for: ${name}, content: "${finalResponse.substring(0, 80)}..."`);
          }
        } else {
          // List query - simple confirmation
          finalResponse = `Here are the top ${records.length} ${resourceType}.`;
          this.logger.log(`[DETERMINISTIC] Generated list response for ${records.length} ${resourceType}`);
        }
      }

      // Fall back to AI if deterministic generation didn't produce a response
      if (!finalResponse) {
        const toolResponseMessages = [
          ...anthropicMessages,
          {
            role: 'user' as const,
            content: isDocumentTool
              ? `SYSTEM TOOL RESULT - You just executed the ${aiResult.toolName} tool. Here is the ACTUAL result you MUST use (DO NOT make up or invent any data, ONLY report what is explicitly shown below):\n\n${truncatedToolResultText}\n\nIMPORTANT: Your response MUST be based ONLY on the data shown above. If the requested information is not in these results, say "I couldn't find that specific information in the document." Never make up dates, terms, amounts, or any other details.`
              : `TOOL RESULT:\n${truncatedToolResultText}\n\nBriefly describe the results. For lists, just confirm the count. For specific records, summarize key fields.`,
          },
        ];
        try {
          finalResponse = await this.anthropic.generateChatCompletion({
            messages: toolResponseMessages,
          });
          this.logger.log('Azure OpenAI generated response');
        } catch (azureError: any) {
          // Fallback to Local SLM if Azure fails
          if (this.localSLM.available) {
            this.logger.warn(`Azure response generation failed (${azureError.message}), falling back to Local SLM...`);
            try {
              // SLM needs smaller context - re-truncate to 4000 chars
              const slmMaxChars = 4000;
              let slmToolResultText = truncatedToolResultText;
              if (slmToolResultText.length > slmMaxChars) {
                slmToolResultText = slmToolResultText.substring(0, slmMaxChars) + '\n\n... (Truncated for SLM)';
                this.logger.warn(`Further truncated to ${slmMaxChars} chars for SLM fallback`);
              }
              const slmMessages = [
                ...anthropicMessages,
                {
                  role: 'user' as const,
                  content: `TOOL RESULT:\n\n${slmToolResultText}\n\nDescribe the results above. Include all names, emails, and key details.`,
                },
              ];
              const slmResult = await this.localSLM.generateChatCompletion({
                messages: slmMessages,
                maxTokens: 1024,
              });
              finalResponse = slmResult.content;
              this.logger.log(`Local SLM fallback generated response (${slmResult.usage?.outputTokens || 0} tokens)`);
            } catch (slmError: any) {
              this.logger.error(`Local SLM fallback also failed: ${slmError.message}`);
              throw azureError;
            }
          } else {
            throw azureError;
          }
        }
      } // Close if (!finalResponse)

      // DEBUG: Log the final response before assigning
      this.logger.log(`[DEBUG] finalResponse before assign: "${(finalResponse || '').substring(0, 100)}..."`);
      assistantResponse = finalResponse || '';
      this.logger.log(`[DEBUG] assistantResponse after assign: "${assistantResponse.substring(0, 100)}..."`);

    } else {
      assistantResponse = aiResult.content || ERROR_MESSAGES.AI.GENERATION_ERROR;
    }

    // RESPONSE GROUNDING: Verify AI response against tool execution facts
    // This prevents hallucinations by removing/correcting ungrounded claims
    if (groundedToolResults.length > 0) {
      try {
        const groundingResult = await this.groundAiResponse(assistantResponse, groundedToolResults);

        if (groundingResult.wasModified) {
          this.logger.warn(
            `[GROUNDING] Response was modified. Risk level: ${this.responseGrounding.getHighestRiskLevel(groundedToolResults)}, ` +
            `Removed: ${groundingResult.removedClaims.length} claims, ` +
            `Corrected: ${groundingResult.correctedClaims.length} claims`
          );

          // Log specific removed claims for debugging
          if (groundingResult.removedClaims.length > 0) {
            this.logger.warn(`[GROUNDING] Removed claims: ${groundingResult.removedClaims.map(c => `"${c.text}"`).join(', ')}`);
          }

          // Use the grounded response
          assistantResponse = groundingResult.response;
        }
      } catch (groundingError) {
        this.logger.error(`[GROUNDING] Failed to ground response: ${groundingError.message}`);
        // Continue with original response if grounding fails
      }
    }

    // Store sources in message metadata as JSON
    const messageMetadata = documentSources.length > 0
      ? JSON.parse(JSON.stringify({ sources: documentSources }))
      : undefined;

    // PERFORMANCE: Parallelize independent operations
    const [followUps, assistantMessage] = await Promise.all([
      // Generate follow-ups with fast model (Haiku)
      // Note: Non-streaming flow doesn't have structured data, so pass undefined
      this.generateFollowUpsAsync(cleanContent, assistantResponse, isDocumentSearchMode, undefined),
      // Save assistant message
      this.prisma.message.create({
        data: {
          conversationId: conversation.id,
          role: MessageRole.ASSISTANT,
          content: assistantResponse,
          suggestedFollowUps: [], // Will be updated below
          metadata: messageMetadata,
        },
      }),
    ]);

    // Update message with follow-ups and conversation timestamp in parallel
    await Promise.all([
      this.prisma.message.update({
        where: { id: assistantMessage.id },
        data: { suggestedFollowUps: followUps },
      }),
      this.prisma.conversation.update({
        where: { id: conversation.id },
        data: { updatedAt: new Date() },
      }),
    ]);

    const updatedConversation = await this.getConversation(conversation.id, userId, isAdmin);

    return {
      conversation: updatedConversation,
      userMessage,
      assistantMessage: {
        ...assistantMessage,
        sources: documentSources.length > 0 ? documentSources : undefined,
      },
      widgetData: widgetDataList.length > 0 ? widgetDataList : undefined,
    };
  }

  /**
   * Generate AI reasoning/planning steps for a user query
   * Uses GPT-4o-mini for simulated reasoning steps
   */
  private async generateReasoningSteps(
    query: string,
    intent: string,
    tools: string[]
  ): Promise<{ step: string; detail: string }[]> {
    // Use GPT-4o-mini for simulated reasoning
    try {
      const toolContext = tools.length > 0
        ? `Available tools: ${tools.slice(0, 5).join(', ')}`
        : '';

      const prompt = `You are explaining your thought process for answering a CRM query.
User query: "${query}"
Detected intent: ${intent}
${toolContext}

Generate 2-3 brief reasoning steps (one line each) explaining your approach.
Format each step as: "Step description | Brief detail"
Be specific to the query, not generic. Use natural language.

Example for "show my top leads":
Finding high-priority leads | Sorting by engagement score and recent activity
Checking lead status | Filtering for active leads in pipeline
Preparing summary | Formatting key metrics and next steps

Now generate steps for the actual query:`;

      const response = await this.anthropic.generateFastCompletion({
        messages: [
          { role: 'system', content: 'You are a helpful CRM assistant explaining your reasoning process. Be concise and specific.' },
          { role: 'user', content: prompt }
        ],
        maxTokens: 150,
        temperature: 0.3,
      });

      // Parse the response into steps
      const steps: { step: string; detail: string }[] = [];
      const lines = response.split('\n').filter(line => line.includes('|'));

      for (const line of lines.slice(0, 3)) {
        const [step, detail] = line.split('|').map(s => s.trim());
        if (step && detail) {
          steps.push({ step, detail });
        }
      }

      // If parsing failed, return generic steps
      if (steps.length === 0) {
        return [
          { step: 'Understanding request', detail: `Processing ${intent} query` },
          { step: 'Gathering data', detail: 'Querying relevant CRM records' },
        ];
      }

      return steps;
    } catch (error) {
      this.logger.warn(`Reasoning generation failed: ${error.message}`);
      // Return generic steps on error
      return [
        { step: 'Processing request', detail: `Handling ${intent} operation` },
      ];
    }
  }

  /**
   * Stream a message using Vercel AI SDK for real-time token streaming
   * This provides true streaming with Server-Sent Events
   */
  async streamMessage(conversationId: string, content: string, res: Response, userId: string, isAdmin?: boolean, mode?: string) {
    // DEBUG: Log received mode parameter
    this.logger.warn(`[CRM_MODE] Received mode parameter: "${mode}" (type: ${typeof mode})`);

    // PERFORMANCE TIMING: Track time spent in each phase
    const timings: Record<string, number> = {};
    const startTime = Date.now();

    const where: any = { id: conversationId };
    if (!isAdmin) {
      where.userId = userId;
    }
    const conversation = await this.prisma.conversation.findFirst({
      where,
    });
    timings.conversationLookup = Date.now() - startTime;

    if (!conversation) {
      throw new NotFoundException('Conversation not found');
    }

    const cleanContent = content.trim();

    // Detect the CRM mode - priority order:
    // 1. Explicit mode parameter from request
    // 2. User's saved preference from database
    // 3. Message prefix (backward compatibility)
    // 4. Default to 'local'
    let effectiveMode = mode;

    // If no explicit mode, fetch user's saved preference from database
    if (!effectiveMode) {
      const userSettings = await this.prisma.user.findUnique({
        where: { id: userId },
        select: { settings: true },
      });
      const savedCrmDataSource = (userSettings?.settings as any)?.crmDataSource;
      if (savedCrmDataSource === 'salesforce' || savedCrmDataSource === 'oracle_cx' || savedCrmDataSource === 'oracle' || savedCrmDataSource === 'local') {
        effectiveMode = savedCrmDataSource;
        this.logger.warn(`[CRM_MODE_STREAM] Using user's saved preference: "${effectiveMode}"`);
      }
    }

    let isDocumentSearchMode = effectiveMode === 'documents';
    let isSalesforceMode = effectiveMode === 'salesforce';
    let isOracleCXMode = effectiveMode === 'oracle_cx' || effectiveMode === 'oracle';

    // Backward compatibility: also detect from message prefix (for web app legacy support)
    if (!effectiveMode) {
      isDocumentSearchMode = cleanContent.toLowerCase().startsWith('[document_search_mode]');
      isSalesforceMode = cleanContent.toLowerCase().startsWith('[salesforce_mode]');
      isOracleCXMode = cleanContent.toLowerCase().startsWith('[oracle_cx_mode]');
    }

    // DEBUG: Log mode detection results for streamMessage
    this.logger.warn(`[CRM_MODE_STREAM] Detection - effectiveMode: ${effectiveMode}, isDocumentSearchMode: ${isDocumentSearchMode}, isSalesforceMode: ${isSalesforceMode}, isOracleCXMode: ${isOracleCXMode}, content starts with: "${cleanContent.substring(0, 50)}..."`);

    // Strip mode prefixes for display (if present)
    let displayContent = cleanContent;
    if (cleanContent.toLowerCase().startsWith('[document_search_mode]')) {
      displayContent = cleanContent.replace(/^\[DOCUMENT_SEARCH_MODE\]\s*/i, '').trim();
    } else if (cleanContent.toLowerCase().startsWith('[salesforce_mode]')) {
      displayContent = cleanContent.replace(/^\[SALESFORCE_MODE\]\s*/i, '').trim();
    } else if (cleanContent.toLowerCase().startsWith('[oracle_cx_mode]')) {
      displayContent = cleanContent.replace(/^\[ORACLE_CX_MODE\]\s*/i, '').trim();
    }

    // Save user message
    const userMessage = await this.prisma.message.create({
      data: {
        conversationId: conversation.id,
        role: MessageRole.USER,
        content: displayContent, // Store without the prefix for cleaner history
        suggestedFollowUps: [],
      },
    });

    // Update title if first message
    if (conversation.title === 'New Conversation') {
      await this.prisma.conversation.update({
        where: { id: conversation.id },
        data: { title: this.generateTitle(displayContent) },
      });
    }

    // Get conversation history
    const historyStart = Date.now();
    const history = await this.prisma.message.findMany({
      where: { conversationId: conversation.id },
      orderBy: { createdAt: 'asc' },
    });
    timings.historyFetch = Date.now() - historyStart;

    // Filter out empty messages and convert to the format expected by the AI SDK
    const messages = history
      .filter((message) => message.content && message.content.trim().length > 0)
      .map((message) => ({
        role: message.role.toLowerCase() as 'user' | 'assistant',
        content: message.content,
      }));

    // Create AI SDK tools based on mode:
    // - Document mode: Document-only tools for PDF search
    // - Salesforce mode: Salesforce CRM tools for external CRM
    // - Default (Local/Globe): Local CRM tools
    let aiSdkTools: Record<string, any>;
    let baseSystemPrompt: string;
    let promptCategory: string | undefined;
    let useFastModel = false; // PERFORMANCE: Track if we can use fast model
    let intentClassification: any = null; // Store intent for logging

    if (isDocumentSearchMode) {
      aiSdkTools = this.createDocumentOnlyAiSdkTools(userId);
      baseSystemPrompt = DOCUMENT_MODE_SYSTEM_PROMPT;
      promptCategory = 'document_search';
    } else if (isSalesforceMode) {
      // INTELLIGENT TOOL ROUTING: Hybrid approach combining pattern matching + embeddings
      // 1. ToolRouter: Cache (0ms) â†’ Pattern (1ms) â†’ LLM (200ms)
      // 2. ToolEmbeddings: Semantic similarity for ambiguous queries (0.1ms)
      intentClassification = await this.toolRouter.classifyIntent(displayContent);

      this.logger.log(`[ROUTER] Intent: ${intentClassification.intent}, Method: ${intentClassification.method}, Tools: ${intentClassification.tools.length}, Latency: ${intentClassification.latencyMs}ms`);

      // Get tools based on intent cluster with embedding fallback
      if (intentClassification.intent === 'full' || intentClassification.tools.length === 0) {
        // Try embedding-based tool selection before falling back to full toolset
        const embeddingResult = this.toolEmbeddings.detectIntent(displayContent);

        if (embeddingResult.confidence > 0.3 && embeddingResult.suggestedTools.length > 0) {
          // Use embedding-suggested tools with some buffer
          const allTools = this.createSalesforceAiSdkTools(userId);
          const embeddingTools = embeddingResult.suggestedTools;

          // Add core tools that might be needed for most queries (but NOT for coaching)
          const coreTools = embeddingResult.intent === 'coaching' ? [] : ['sf_query', 'sf_search', 'sf_get_record'];
          const combinedTools = [...new Set([...embeddingTools, ...coreTools])];

          aiSdkTools = this.filterToolsByNames(allTools, combinedTools);
          useFastModel = embeddingResult.intent !== 'research' && embeddingResult.intent !== 'admin';

          this.logger.log(`[PERF] Embedding fallback: ${embeddingResult.intent} (conf: ${embeddingResult.confidence.toFixed(2)}) -> ${combinedTools.length} tools, ${useFastModel ? 'fast' : 'full'} model`);
        } else {
          // Use full toolset for complex/ambiguous queries
          aiSdkTools = this.createSalesforceAiSdkTools(userId);
          useFastModel = false;
          this.logger.log(`[PERF] Using full Salesforce tools (${Object.keys(aiSdkTools).length} tools) for intent: ${intentClassification.intent}`);
        }
      } else if (intentClassification.intent === 'coaching') {
        // For coaching queries, use ONLY coaching tools - no sf_query fallback
        aiSdkTools = this.createClusteredSalesforceTools(userId, intentClassification.tools);
        useFastModel = true;
        this.logger.warn(`[COACHING] Using coaching-only tools (${Object.keys(aiSdkTools).length} tools): ${intentClassification.tools.join(', ')}`);
      } else {
        // Use cluster-specific tools for faster response
        aiSdkTools = this.createClusteredSalesforceTools(userId, intentClassification.tools);
        useFastModel = intentClassification.model === 'fast';
        this.logger.log(`[PERF] Using ${intentClassification.intent} cluster (${Object.keys(aiSdkTools).length} tools) + ${useFastModel ? 'fast' : 'full'} model`);
      }

      baseSystemPrompt = SALESFORCE_MODE_SYSTEM_PROMPT;
      promptCategory = 'salesforce';
    } else if (isOracleCXMode) {
      // Oracle CX Sales Cloud mode - use Oracle CX tools
      aiSdkTools = this.createOracleCXAiSdkTools(userId);
      baseSystemPrompt = ORACLE_CX_MODE_SYSTEM_PROMPT;
      promptCategory = 'oracle_cx';
    } else {
      aiSdkTools = this.createCrmOnlyAiSdkTools(userId);
      baseSystemPrompt = CRM_ONLY_SYSTEM_PROMPT;
      promptCategory = undefined;
    }

    // SLM Router: Use intelligent query routing to reduce latency
    // This classifies the query and selects only relevant tools + focused prompt
    // IMPORTANT: Works for both local CRM mode and Salesforce mode
    const routingStart = Date.now();
    let routingDecision: RoutingDecision | null = null;
    if (!isDocumentSearchMode) {
      try {
        const userQuery = history.length > 0 ? history[history.length - 1].content : '';
        routingDecision = await this.queryRouter.routeQuery(userQuery);

        // Log routing decision for debugging
        this.logger.log(`Query routing: category=${routingDecision?.systemPromptKey || 'unknown'}, tools=${routingDecision?.toolSubset?.length ?? 'all'}, mode=${isSalesforceMode ? 'salesforce' : 'local'}`);

        // If toolSubset is specified (not null), filter to only relevant tools
        if (routingDecision && routingDecision.toolSubset !== null) {
          const toolCount = routingDecision.toolSubset.length;
          this.logger.log(`Query routed with ${toolCount} tools (model: ${routingDecision.useSmallModel ? 'small' : 'large'}, prompt: ${routingDecision.systemPromptKey})`);

          // For queries that don't need tools (e.g., greetings), use empty tool set
          if (routingDecision.toolSubset.length === 0) {
            aiSdkTools = {};
          } else if (!isSalesforceMode && !isOracleCXMode) {
            // For local CRM mode, filter to relevant tools
            const allCrmTools = this.createCrmOnlyAiSdkTools(userId);
            aiSdkTools = this.filterToolsByNames(allCrmTools, routingDecision.toolSubset);
          } else if (isOracleCXMode) {
            // For Oracle CX mode, filter to relevant tools (reduces tokens significantly)
            const allOracleCXTools = this.createOracleCXAiSdkTools(userId);
            // Map suggested tools to Oracle CX equivalents
            const ocxToolMap: Record<string, string> = {
              'search_leads': 'ocx_query',
              'get_lead_details': 'ocx_get_record',
              'get_top_leads': 'ocx_query',
              'search_opportunities': 'ocx_query',
              'get_opportunity_details': 'ocx_get_record',
              'get_pipeline_stats': 'ocx_query',
              'search_accounts': 'ocx_query',
              'get_account_details': 'ocx_get_record',
              'search_contacts': 'ocx_query',
              'get_contact_details': 'ocx_get_record',
              'create_lead': 'ocx_create_lead',
              'create_opportunity': 'ocx_create_opportunity',
              'update_opportunity': 'ocx_update_opportunity',
              'research_company': 'research_company',
              'send_email': 'send_email',
              'schedule_meeting': 'schedule_meeting',
            };
            // Convert suggested tools to Oracle CX tool names
            const ocxToolNames = new Set<string>();
            for (const tool of routingDecision.toolSubset) {
              ocxToolNames.add(ocxToolMap[tool] || tool);
            }
            // Always include ocx_query and ocx_get_record for CRM operations
            if (ocxToolNames.size > 0) {
              ocxToolNames.add('ocx_query');
              ocxToolNames.add('ocx_get_record');
            }
            aiSdkTools = this.filterToolsByNames(allOracleCXTools, Array.from(ocxToolNames));
            this.logger.log(`Oracle CX tools filtered: ${Array.from(ocxToolNames).join(', ')}`);

            // Use minimal prompt for simple CRM queries (reduces tokens by ~80%)
            if (routingDecision.systemPromptKey === 'minimal' || routingDecision.systemPromptKey === 'crm-only') {
              baseSystemPrompt = ORACLE_CX_MINIMAL_PROMPT;
              this.logger.log(`Using MINIMAL Oracle CX prompt for simple query`);
            }
          }
          // For Salesforce mode, aiSdkTools was already set above, but we may need to augment with research tools
          // if this is a research query that requires web search
          if (isSalesforceMode && routingDecision.systemPromptKey === 'research-only') {
            // Add research tools to the Salesforce toolset for financial/company analysis queries
            this.logger.log('Adding research tools to Salesforce mode for financial analysis query');
          }
        } else {
          this.logger.log('Query routed with full tool set');
        }
      } catch (routerError) {
        this.logger.warn('Query router failed, falling back to full tools', routerError);
        // Fall back to full tool set on error
      }
    }
    timings.queryRouting = Date.now() - routingStart;

    // RLHF: Enhance prompt with learned golden examples and negative pattern avoidance
    // Also injects user context (name, email) for personalized email signatures
    const promptStart = Date.now();
    const activeSystemPrompt = await this.getEnhancedSystemPrompt(
      baseSystemPrompt,
      promptCategory,
      userId
    );
    timings.promptEnhancement = Date.now() - promptStart;


    try {
      // Set up SSE headers early
      res.setHeader('Content-Type', 'text/event-stream');
      res.setHeader('Cache-Control', 'no-cache');
      res.setHeader('Connection', 'keep-alive');
      res.setHeader('X-Accel-Buffering', 'no');

      // Send initial event with user message info
      res.write(`data: ${JSON.stringify({ type: 'start', userMessageId: userMessage.id })}\n\n`);

      // Helper to send progressive thinking events
      const thinkingSteps: { step: string; detail: string; status: 'active' | 'complete' }[] = [];
      const sendThinkingUpdate = (category: string) => {
        res.write(`data: ${JSON.stringify({
          type: 'thinking',
          steps: [...thinkingSteps],
          category,
          model: useFastModel ? 'fast' : 'full',
        })}\n\n`);
      };

      // Helper for streaming reasoning text (typewriter effect)
      const sendReasoningChunk = (text: string) => {
        res.write(`data: ${JSON.stringify({ type: 'reasoning_stream', text })}\n\n`);
      };

      // Determine category early
      const thinkingCategory = intentClassification?.intent || (isDocumentSearchMode ? 'document' : 'crm');

      // Send thinking state for Salesforce mode
      if (intentClassification) {
        // Send initial thinking state
        res.write(`data: ${JSON.stringify({
          type: 'thinking_start',
          category: thinkingCategory,
          intent: intentClassification.intent,
        })}\n\n`);

        // Send thinking_end to transition to response
        res.write(`data: ${JSON.stringify({ type: 'thinking_end' })}\n\n`);

      } else if (isDocumentSearchMode) {
        thinkingSteps.push({
          step: 'Searching documents',
          detail: 'Scanning indexed PDFs and files for relevant content',
          status: 'active',
        });
        sendThinkingUpdate(thinkingCategory);

      } else {
        // Local CRM mode - classification happens here
        res.write(`data: ${JSON.stringify({
          type: 'thinking_start',
          category: 'crm',
        })}\n\n`);

        // Actual classification - timing depends on query complexity
        const classifyStart = Date.now();
        const routerClassification = await this.queryRouter?.routeQuery(displayContent);
        const classifyTime = Date.now() - classifyStart;

        res.write(`data: ${JSON.stringify({ type: 'thinking_end' })}\n\n`);
      }

      // ============================================================================
      // IRIS OPTIMIZER: ULTRA-FAST PATHS (NO LLM NEEDED)
      // These paths bypass LLM entirely for maximum speed
      // ============================================================================

      // FAST PATH 1: Zero-LLM Greetings (< 10ms)
      // For simple greetings, return canned response without any LLM call
      if (this.irisOptimizer.isGreeting(displayContent)) {
        const greetingResponse = this.irisOptimizer.getGreetingResponse(displayContent);
        this.irisOptimizer.recordQuery(true, false);

        // Save assistant message
        const assistantMessage = await this.prisma.message.create({
          data: {
            conversationId: conversation.id,
            role: MessageRole.ASSISTANT,
            content: greetingResponse,
          },
        });

        // Stream the response character by character for UX consistency
        for (const char of greetingResponse) {
          res.write(`data: ${JSON.stringify({ type: 'text', text: char })}\n\n`);
        }

        // Send completion event
        res.write(`data: ${JSON.stringify({
          type: 'done',
          assistantMessageId: assistantMessage.id,
          fullText: greetingResponse,
        })}\n\n`);
        res.end();

        this.logger.log(`[IRIS-OPTIMIZER] Zero-LLM greeting response (${Date.now() - startTime}ms)`);
        return;
      }

      // FAST PATH 2: Deterministic Query Templates (< 300ms)
      // For common Salesforce queries, execute SOQL directly without LLM
      if (isSalesforceMode) {
        const deterministicTemplate = this.irisOptimizer.matchDeterministicTemplate(displayContent);

        if (deterministicTemplate) {
          this.logger.log(`[IRIS-OPTIMIZER] Matched deterministic template: ${deterministicTemplate.title}`);
          this.irisOptimizer.recordQuery(true, false);

          // Execute SOQL directly through Salesforce service
          const executeSOQL = async (soql: string) => {
            const result = await this.salesforceService.query(userId, soql);
            return result?.records || [];
          };

          const queryResult = await this.irisOptimizer.executeDeterministicQuery(
            deterministicTemplate,
            executeSOQL
          );

          if (queryResult.success && queryResult.data) {
            // Analyze data for smart rendering
            let structuredData: {
              type: string;
              data: any;
              title: string;
              visualization: string;
              columns?: any[];
              insights?: string[];
              showTable?: boolean;
            };
            try {
              const analysis = await this.smartDataAnalyzer.analyzeData(
                queryResult.data,
                `User query: ${displayContent}`
              );
              structuredData = {
                type: 'generic',
                data: queryResult.data,
                title: deterministicTemplate.title,
                visualization: deterministicTemplate.visualization,
                columns: analysis.columns.filter(c => !c.hidden).sort((a, b) => a.priority - b.priority),
                insights: analysis.insights,
                showTable: analysis.showTable,
              };
            } catch {
              structuredData = {
                type: 'generic',
                data: queryResult.data,
                title: deterministicTemplate.title,
                visualization: deterministicTemplate.visualization,
              };
            }

            // Send structured data first
            res.write(`data: ${JSON.stringify({
              type: 'tool_result',
              name: 'sf_query',
              structuredData,
            })}\n\n`);

            // Stream the template response
            const responseText = `${deterministicTemplate.responseTemplate}\n\nFound ${queryResult.data.length} records.`;
            for (const char of responseText) {
              res.write(`data: ${JSON.stringify({ type: 'text', text: char })}\n\n`);
            }

            // Save assistant message
            const assistantMessage = await this.prisma.message.create({
              data: {
                conversationId: conversation.id,
                role: MessageRole.ASSISTANT,
                content: responseText,
              },
            });

            // Send completion event
            res.write(`data: ${JSON.stringify({
              type: 'done',
              assistantMessageId: assistantMessage.id,
              fullText: responseText,
              structuredData: [structuredData],
            })}\n\n`);
            res.end();

            this.logger.log(`[IRIS-OPTIMIZER] Deterministic query completed in ${queryResult.latencyMs}ms (total: ${Date.now() - startTime}ms)`);
            return;
          }
          // If deterministic execution failed, fall through to LLM path
          this.logger.warn(`[IRIS-OPTIMIZER] Deterministic query failed, falling back to LLM`);
        }
      }

      // FAST PATH 3: Minimal LLM for simple greetings (legacy fallback)
      if (routingDecision?.toolSubset?.length === 0 && routingDecision?.systemPromptKey === 'minimal') {
        let fullText = '';

        // Use fast streaming with minimal prompt (no tools, short system prompt)
        const fastStream = this.aiSdk.streamSimpleQuery(messages, 'greeting');

        for await (const event of fastStream) {
          if (event.type === 'text') {
            fullText += event.data;
            res.write(`data: ${JSON.stringify({ type: 'text', text: event.data })}\n\n`);
          }
        }

        // Save assistant message
        const assistantMessage = await this.prisma.message.create({
          data: {
            conversationId: conversation.id,
            role: MessageRole.ASSISTANT,
            content: fullText,
          },
        });

        // Send completion event
        res.write(`data: ${JSON.stringify({
          type: 'done',
          assistantMessageId: assistantMessage.id,
          fullText: fullText,
        })}\n\n`);
        res.end();

        this.logger.log('Fast-path greeting response sent (minimal LLM call)');
        return;
      }

      // ============================================================================
      // END IRIS OPTIMIZER FAST PATHS - Fall through to full LLM processing
      // ============================================================================
      this.irisOptimizer.recordQuery(false, false); // Record as LLM fallback

      let fullText = '';
      const documentSources: DocumentSource[] = [];
      // GROUNDING: Collect grounded tool results for post-stream verification
      const groundedToolResults: GroundedToolResult[] = [];
      const structuredDataItems: Array<{
        type: string;
        data: any[] | any; // Can be array or single object for artifacts like quotes
        title?: string;
        visualization?: string;
        columns?: any[];
        insights?: string[];
        showTable?: boolean; // Show table alongside chart for drill-down
        _artifactType?: string; // For artifact identification (e.g., 'quote')
        _artifactTitle?: string; // Title for artifact panel
      }> = [];

      // Aggregator for creation tool results (sf_create_task, sf_create_record, etc.)
      // This collects multiple creation results by object type for display in a single table
      const creationResultsAggregator: Map<string, {
        objectType: string;
        records: any[];
        toolName: string;
      }> = new Map();

      // Helper to detect creation tools and extract object type
      const getCreationToolObjectType = (toolName: string, args: any): string | null => {
        if (toolName === 'sf_create_task' || toolName === 'create_task') return 'Task';
        if (toolName === 'sf_create_lead' || toolName === 'create_lead') return 'Lead';
        if (toolName === 'sf_create_contact' || toolName === 'create_contact') return 'Contact';
        if (toolName === 'sf_create_account' || toolName === 'create_account') return 'Account';
        if (toolName === 'sf_create_opportunity' || toolName === 'create_opportunity') return 'Opportunity';
        if (toolName === 'sf_create_record') return args?.objectType || 'Record';
        return null;
      };

      // Create tool executor that uses the existing executeTool method and tracks sources
      // IMPORTANT: Pass dataSource to enforce CRM mode (local vs salesforce vs oracle_cx)
      const dataSource = isSalesforceMode ? 'salesforce' : isOracleCXMode ? 'oracle_cx' : 'local';
      this.logger.warn(`[CRM_MODE_EXECUTOR] Creating toolExecutor with dataSource=${dataSource}, isSalesforceMode=${isSalesforceMode}, isOracleCXMode=${isOracleCXMode}`);
      const toolExecutor = async (name: string, args: any) => {
        const toolStart = Date.now();
        // DEBUG: Log tool args to see what SOQL is being generated
        if (name === 'sf_query') {
          this.logger.warn(`[SF_QUERY_DEBUG] Full args: ${JSON.stringify(args)?.substring(0, 500) || 'NULL'}`);
          this.logger.warn(`[SF_QUERY_DEBUG] SOQL: ${args?.query?.substring(0, 200) || 'NO QUERY'}`);
        }
        this.logger.warn(`[CRM_MODE_EXECUTOR] Executing tool "${name}" with dataSource="${dataSource}"`);
        const result = await this.executeTool(name, args, userId, dataSource);
        // DEBUG: Log result status and actual data
        if (name === 'sf_query') {
          this.logger.warn(`[SF_QUERY_DEBUG] Result: success=${result.success}, records=${result.data?.records?.length || result.data?.totalSize || 0}, error=${result.error || 'none'}`);
          if (result.success && result.data?.records) {
            const recordNames = result.data.records.slice(0, 5).map((r: any) => `${r.Name}($${r.Amount || 0})`).join(', ');
            this.logger.warn(`[SF_QUERY_DEBUG] Actual records: [${recordNames}]`);
          }
        }
        this.logger.log(`[PERF] Tool ${name} executed in ${Date.now() - toolStart}ms (dataSource=${dataSource})`);

        // GROUNDING: Collect grounded tool results for post-stream verification
        // Check if tool returned a grounded result (has risk_level and facts)
        if (result.risk_level && result.facts) {
          groundedToolResults.push(result as GroundedToolResult);
          this.logger.log(`[GROUNDING] Collected grounded result from ${name} (risk: ${result.risk_level})`);
        }

        // Extract document sources for attribution
        const isDocumentTool = ['search_document', 'get_document_summary', 'get_document_structure', 'list_indexed_documents'].includes(name);
        if (isDocumentTool && result.success && result.data) {
          await this.extractDocumentSources(name, args, result, documentSources);
        }

        // Track structured data for smart rendering using LLM-powered analysis
        if (result.success && result.data) {
          // Check if this is a creation tool result (single record)
          const creationObjectType = getCreationToolObjectType(name, args);
          if (creationObjectType && result.data && typeof result.data === 'object' && !Array.isArray(result.data)) {
            // Aggregate single creation results by object type
            const key = creationObjectType;
            if (!creationResultsAggregator.has(key)) {
              creationResultsAggregator.set(key, {
                objectType: creationObjectType,
                records: [],
                toolName: name,
              });
            }
            // Enrich the result with any useful info from args
            const enrichedRecord = { ...result.data };
            if (args.Subject && !enrichedRecord.subject) enrichedRecord.subject = args.Subject;
            if (args.WhatId && !enrichedRecord.relatedTo) enrichedRecord.relatedTo = args.WhatId;
            if (args.Priority && !enrichedRecord.priority) enrichedRecord.priority = args.Priority;
            if (args.Description && !enrichedRecord.description) enrichedRecord.description = args.Description;
            if (args.firstName && args.lastName) enrichedRecord.name = `${args.firstName} ${args.lastName}`;
            if (args.company) enrichedRecord.company = args.company;
            if (args.email) enrichedRecord.email = args.email;
            
            creationResultsAggregator.get(key)!.records.push(enrichedRecord);
          } else {
            // Handle Salesforce query/search results (nested records array)
            let dataArray: any[] = [];
            // sf_query returns { records: [...] }
            if (name === 'sf_query' && result.data.records && Array.isArray(result.data.records)) {
              dataArray = result.data.records;
            }
            // sf_search returns { searchTerm, totalResults, records: [...] }
            else if (name === 'sf_search' && result.data.records && Array.isArray(result.data.records)) {
              dataArray = result.data.records;
            }
            // Handle search_* tools that return arrays in various formats
            else if (name.startsWith('search_') && result.data) {
              if (Array.isArray(result.data)) {
                dataArray = result.data;
              } else if (result.data.results && Array.isArray(result.data.results)) {
                dataArray = result.data.results;
              } else if (result.data.records && Array.isArray(result.data.records)) {
                dataArray = result.data.records;
              }
            }
            // Handle compute_analytics results (breakdown array with conversion rates, etc.)
            else if (name === 'compute_analytics' && result.data) {
              if (result.data.breakdown && Array.isArray(result.data.breakdown)) {
                dataArray = result.data.breakdown;
              }
            }
            // Handle IRISRank results (iris_rank_entities, iris_get_at_risk, iris_get_momentum)
            else if (name.startsWith('iris_') && result.data?.records && Array.isArray(result.data.records)) {
              dataArray = result.data.records;
            }
            // Fallback for any array data
            else if (Array.isArray(result.data)) {
              dataArray = result.data;
            }

            // Debug log to understand data structure
            const sampleNames = dataArray.slice(0, 3).map((r: any) => r.Name || r.name || 'unnamed').join(', ');
            this.logger.warn(`[DATA_EXTRACTION] Tool ${name}: dataArray.length=${dataArray.length}, sampleNames=[${sampleNames}]`);

            // Handle quote artifact (single object, not array)
            if (result._artifactType === 'quote' && result.data) {
              this.logger.warn(`[QUOTE_ARTIFACT] Detected quote artifact: ${result._artifactTitle}`);
              structuredDataItems.push({
                type: 'quote',
                _artifactType: 'quote',
                _artifactTitle: result._artifactTitle,
                data: result.data,
                title: result._artifactTitle || `Quote ${result.data.quoteNumber}`,
              });
            }

            if (dataArray.length > 0) {
              // Use LLM-powered smart data analyzer for dynamic column/visualization detection
              // Pass user's query for meaningful title generation
              try {
                const analysis = await this.smartDataAnalyzer.analyzeData(dataArray, `User query: ${cleanContent}`);

                // For compute_analytics, merge analytics-specific insights with smart data insights
                let combinedInsights = analysis.insights || [];
                if (name === 'compute_analytics' && result.data?.insights && Array.isArray(result.data.insights)) {
                  // Analytics insights take priority (more specific to the computation)
                  combinedInsights = [...result.data.insights, ...combinedInsights.filter(i => !result.data.insights.includes(i))];
                }

                structuredDataItems.push({
                  type: 'generic', // LLM determines visualization, not a fixed type
                  data: dataArray,
                  title: analysis.title || result.message || `${dataArray.length} Records`,
                  visualization: analysis.visualization.type,
                  columns: analysis.columns.filter(c => !c.hidden).sort((a, b) => a.priority - b.priority),
                  insights: combinedInsights, // AI-generated key highlights (analytics + smart data)
                  showTable: analysis.showTable, // Show table alongside chart for drill-down
                });
              } catch (analyzeError) {
                this.logger.warn(`Smart data analysis failed, using fallback: ${analyzeError.message}`);
                // Fallback: just pass the data, let frontend infer columns
                // For compute_analytics, still include the analytics insights
                const fallbackInsights = (name === 'compute_analytics' && result.data?.insights) ? result.data.insights : undefined;
                structuredDataItems.push({
                  type: 'generic',
                  data: dataArray,
                  title: result.message || `${dataArray.length} Records`,
                  insights: fallbackInsights,
                });
              }
            }
          }
        }

        return result;
      };

      // TOOL FORCING: Detect intent for forcing specific tools
      // This ensures certain operations use the correct tool instead of the AI choosing alternatives
      let toolChoice: 'auto' | { type: 'function'; function: { name: string } } | undefined = undefined;

      // Force sf_create_report for report creation requests (Salesforce mode only)
      if (isSalesforceMode) {
        const reportCreationPatterns = [
          /create\s+(a\s+)?salesforce\s+report/i,
          /create\s+(a\s+)?report\s+(in|for)\s+salesforce/i,
          /create\s+(a\s+)?report\s+called/i,
          /save\s+(this\s+)?(as\s+)?(a\s+)?salesforce\s+report/i,
          /build\s+(me\s+)?(a\s+)?sf\s+report/i,
          /create\s+(a\s+)?sf\s+report/i,
        ];

        const isReportCreationRequest = reportCreationPatterns.some(pattern => pattern.test(displayContent));

        if (isReportCreationRequest) {
          this.logger.warn(`[TOOL_FORCING_STREAM] Detected report creation intent, forcing sf_create_report tool`);
          toolChoice = { type: 'function', function: { name: 'sf_create_report' } };

          // CRITICAL: Ensure sf_create_report is in the available tools
          // The tool router may have selected a subset that doesn't include it
          if (!aiSdkTools['sf_create_report']) {
            this.logger.warn(`[TOOL_FORCING_STREAM] sf_create_report not in current toolset, adding it`);
            const allSalesforceTools = this.createSalesforceAiSdkTools(userId);
            if (allSalesforceTools['sf_create_report']) {
              aiSdkTools['sf_create_report'] = allSalesforceTools['sf_create_report'];
              // Also add helper tools that sf_create_report might need
              if (allSalesforceTools['sf_get_report_types'] && !aiSdkTools['sf_get_report_types']) {
                aiSdkTools['sf_get_report_types'] = allSalesforceTools['sf_get_report_types'];
              }
              if (allSalesforceTools['sf_list_report_folders'] && !aiSdkTools['sf_list_report_folders']) {
                aiSdkTools['sf_list_report_folders'] = allSalesforceTools['sf_list_report_folders'];
              }
            }
          }
        }
      }

      // Use AI SDK with agentic tool execution
      // PERFORMANCE: Use fast model (Haiku) for simple Salesforce queries
      const streamStart = Date.now();
      const stream = this.aiSdk.streamChatWithTools(
        messages,
        activeSystemPrompt,
        aiSdkTools,
        toolExecutor,
        10, // maxIterations
        useFastModel, // Use Haiku for fast intent clusters
        toolChoice, // Force specific tool if detected
      );

      // Stream the response with tool calls
      let firstTokenTime: number | null = null;
      for await (const event of stream) {
        if (event.type === 'text' && firstTokenTime === null) {
          firstTokenTime = Date.now() - streamStart;
          timings.timeToFirstToken = firstTokenTime;
        }
        if (event.type === 'text') {
          fullText += event.data;
          res.write(`data: ${JSON.stringify({ type: 'text', text: event.data })}\n\n`);
        } else if (event.type === 'tool_call') {
          res.write(`data: ${JSON.stringify({ type: 'tool_call', name: event.data.name })}\n\n`);
        } else if (event.type === 'tool_result') {
          // Include structured data if available
          const toolData = structuredDataItems.find(item =>
            this.isToolMatchingDataType(event.data.name, item.type)
          );
          res.write(`data: ${JSON.stringify({
            type: 'tool_result',
            name: event.data.name,
            structuredData: toolData || undefined,
          })}\n\n`);
        }
      }
      timings.aiStreaming = Date.now() - streamStart;

      // Merge aggregated creation results into structured data items
      // This creates tables for bulk creation operations (e.g., "Created 8 Tasks")
      for (const [objectType, aggregated] of creationResultsAggregator) {
        if (aggregated.records.length > 0) {
          const records = aggregated.records;
          const title = `${records.length} ${objectType}${records.length > 1 ? 's' : ''} Created`;
          
          // Define smart columns based on object type
          let columns: any[] = [];
          if (objectType === 'Task') {
            columns = [
              { key: 'subject', label: 'Subject', type: 'text', priority: 1, sortable: true },
              { key: 'status', label: 'Status', type: 'status', priority: 2, sortable: true },
              { key: 'priority', label: 'Priority', type: 'text', priority: 3, sortable: true },
              { key: 'dueDate', label: 'Due Date', type: 'date', priority: 4, sortable: true },
              { key: 'id', label: 'Task ID', type: 'text', priority: 5, sortable: false },
            ];
          } else if (objectType === 'Lead') {
            columns = [
              { key: 'name', label: 'Name', type: 'text', priority: 1, sortable: true },
              { key: 'company', label: 'Company', type: 'text', priority: 2, sortable: true },
              { key: 'email', label: 'Email', type: 'email', priority: 3, sortable: true },
              { key: 'status', label: 'Status', type: 'status', priority: 4, sortable: true },
              { key: 'id', label: 'Lead ID', type: 'text', priority: 5, sortable: false },
            ];
          } else if (objectType === 'Contact') {
            columns = [
              { key: 'name', label: 'Name', type: 'text', priority: 1, sortable: true },
              { key: 'email', label: 'Email', type: 'email', priority: 2, sortable: true },
              { key: 'phone', label: 'Phone', type: 'phone', priority: 3, sortable: true },
              { key: 'id', label: 'Contact ID', type: 'text', priority: 4, sortable: false },
            ];
          } else if (objectType === 'Opportunity') {
            columns = [
              { key: 'name', label: 'Name', type: 'text', priority: 1, sortable: true },
              { key: 'stageName', label: 'Stage', type: 'status', priority: 2, sortable: true },
              { key: 'amount', label: 'Amount', type: 'currency', priority: 3, sortable: true },
              { key: 'id', label: 'Opportunity ID', type: 'text', priority: 4, sortable: false },
            ];
          } else {
            // Generic columns - infer from first record
            const sample = records[0];
            columns = Object.keys(sample)
              .filter(key => !key.startsWith('_') && key !== 'attributes')
              .slice(0, 6)
              .map((key, index) => ({
                key,
                label: key.charAt(0).toUpperCase() + key.slice(1).replace(/([A-Z])/g, ' $1'),
                type: 'text',
                priority: index + 1,
                sortable: true,
              }));
          }
          
          structuredDataItems.push({
            type: 'creation-results',
            data: records,
            title,
            visualization: 'table',
            columns,
          });
        }
      }

      // If no structured data from tools, try to extract records from the AI response text
      // This handles cases where AI answers from memory without calling tools
      if (structuredDataItems.length === 0 && fullText.length > 100) {
        this.logger.warn(`[FALLBACK_EXTRACTION] No structured data from tools, attempting text extraction...`);
        const extractedData = this.extractStructuredDataFromText(fullText, cleanContent);
        if (extractedData) {
          const extractedNames = extractedData.data?.slice(0, 3).map((r: any) => r.Name || r.name || 'unnamed').join(', ');
          this.logger.warn(`[FALLBACK_EXTRACTION] Extracted from text: ${extractedData.data?.length || 0} records, names=[${extractedNames}]`);
          structuredDataItems.push(extractedData);
        }
      }

      // Post-process: Clean up verbose AI response when structured data is present
      // This removes redundant record listings since the data table displays them
      let cleanedText = fullText;
      if (structuredDataItems.length > 0) {
        cleanedText = this.cleanResponseWithStructuredData(fullText);
      }

      // ========================================================================
      // POST-STREAM GROUNDING: Verify AI response against tool execution facts
      // This ensures the STORED message is grounded in actual tool results,
      // even though the streamed text has already been displayed.
      // On page reload, users will see the grounded (accurate) version.
      // ========================================================================
      let groundingWasApplied = false;
      if (groundedToolResults.length > 0) {
        try {
          const groundingResult = await this.groundAiResponse(cleanedText, groundedToolResults);

          if (groundingResult.wasModified) {
            groundingWasApplied = true;
            const riskLevel = this.responseGrounding.getHighestRiskLevel(groundedToolResults);
            this.logger.warn(
              `[GROUNDING-STREAM] Response was modified for storage. Risk level: ${riskLevel}, ` +
              `Removed: ${groundingResult.removedClaims.length} claims, ` +
              `Corrected: ${groundingResult.correctedClaims.length} claims`
            );

            // Log specific removed claims for debugging
            if (groundingResult.removedClaims.length > 0) {
              this.logger.warn(
                `[GROUNDING-STREAM] Removed claims: ${groundingResult.removedClaims.map(c => `"${c.text}"`).join(', ')}`
              );
            }

            // Use the grounded response for storage
            // Note: The streamed text has already been sent to the client,
            // but the stored version will be accurate
            cleanedText = groundingResult.response;
          }
        } catch (groundingError) {
          this.logger.error(`[GROUNDING-STREAM] Failed to ground response: ${groundingError.message}`);
          // Continue with original response if grounding fails
        }
      }

      // Track LLM usage for cost analysis (streaming endpoint)
      const userForTracking = await this.prisma.user.findUnique({ where: { id: userId }, select: { email: true, name: true } });
      
      // Estimate tokens from message length (rough estimate: ~4 chars per token)
      const estimatedInputTokens = Math.ceil(JSON.stringify(messages).length / 4);
      const estimatedOutputTokens = Math.ceil(fullText.length / 4);
      
      this.usageTrackingService.logUsage({
        userId,
        userName: userForTracking?.name || undefined,
        userEmail: userForTracking?.email || undefined,
        serviceType: ApiServiceType.LLM_CLAUDE,
        serviceName: 'claude-3-sonnet',
        operation: isSalesforceMode ? 'salesforce_conversation_stream' : isDocumentSearchMode ? 'document_search_stream' : 'crm_conversation_stream',
        inputTokens: estimatedInputTokens,
        outputTokens: estimatedOutputTokens,
        totalTokens: estimatedInputTokens + estimatedOutputTokens,
        conversationId,
        success: true,
        metadata: {
          mode: isSalesforceMode ? 'salesforce' : isDocumentSearchMode ? 'document' : 'local',
          toolsUsed: structuredDataItems.length > 0,
          responseLength: fullText.length,
        },
      }).catch(err => this.logger.error(`Failed to log AI usage (stream): ${err.message}`));

      // Store sources, structured data, and grounding info in message metadata for persistence
      const messageMetadata: Record<string, any> = {};
      if (documentSources.length > 0) {
        messageMetadata.sources = documentSources;
      }
      // Save structured data for artifact restoration on page reload
      if (structuredDataItems.length > 0) {
        messageMetadata.structuredData = structuredDataItems;
      }
      // Track grounding status for audit/debugging
      if (groundingWasApplied) {
        messageMetadata.groundingApplied = true;
        messageMetadata.groundingRiskLevel = this.responseGrounding.getHighestRiskLevel(groundedToolResults);
      }
      const finalMetadata = Object.keys(messageMetadata).length > 0 ? messageMetadata : undefined;

      // PERFORMANCE: Parallelize independent operations
      // 1. Generate follow-ups using fast model (Haiku)
      // 2. Save assistant message
      // 3. Update conversation timestamp
      // All three operations are independent and can run concurrently
      const followUpStart = Date.now();
      const [followUps, assistantMessage] = await Promise.all([
        // Generate follow-ups with fast model, passing structured data for anti-hallucination
        this.generateFollowUpsAsync(cleanContent, cleanedText, isDocumentSearchMode, structuredDataItems),
        // Save assistant message (with empty follow-ups initially)
        this.prisma.message.create({
          data: {
            conversationId: conversation.id,
            role: MessageRole.ASSISTANT,
            content: cleanedText,
            suggestedFollowUps: [], // Will be updated below
            metadata: finalMetadata,
          },
        }),
      ]);

      // Update message with follow-ups and conversation timestamp in parallel
      await Promise.all([
        this.prisma.message.update({
          where: { id: assistantMessage.id },
          data: { suggestedFollowUps: followUps },
        }),
        this.prisma.conversation.update({
          where: { id: conversation.id },
          data: { updatedAt: new Date() },
        }),
      ]);
      timings.followUpsAndSave = Date.now() - followUpStart;

      // PERFORMANCE: Log total time and breakdown
      timings.totalTime = Date.now() - startTime;
      this.logger.log(`[PERF] Response timings: ${JSON.stringify(timings)}`);

      // DEBUG: Log structured data items for debugging
      if (structuredDataItems.length > 0) {
        this.logger.warn(`[STRUCTURED_DATA_DEBUG] Sending ${structuredDataItems.length} items to frontend`);
        structuredDataItems.forEach((item, i) => {
          // Handle both array data (tables) and object data (artifacts like quotes)
          const isArray = Array.isArray(item.data);
          const firstRecordNames = isArray
            ? item.data?.slice(0, 5).map((r: any) => r.Name || r.name || r.Subject || 'unnamed').join(', ')
            : item.data?.name || item.data?.quoteNumber || 'single object';
          const dataCount = isArray ? item.data?.length || 0 : 1;
          this.logger.warn(`[STRUCTURED_DATA_DEBUG] Item ${i}: type=${item.type}, dataCount=${dataCount}, viz=${item.visualization || 'none'}, title=${item.title}, names=[${firstRecordNames}]`);
        });
      } else {
        this.logger.warn(`[STRUCTURED_DATA_DEBUG] No structured data items to send`);
      }

      // Send completion event with sources, structured data, and grounding info
      res.write(`data: ${JSON.stringify({
        type: 'done',
        assistantMessageId: assistantMessage.id,
        suggestedFollowUps: followUps,
        sources: documentSources.length > 0 ? documentSources : undefined,
        structuredData: structuredDataItems.length > 0 ? structuredDataItems : undefined,
        // Inform frontend if grounding was applied (stored version may differ from streamed)
        groundingApplied: groundingWasApplied || undefined,
      })}\n\n`);

      res.end();
    } catch (error) {
      this.logger.error(`Streaming error: ${error.message}`, error.stack);
      
      // Use centralized error message helper for consistency
      const userMessage = getUserFriendlyErrorMessage(error);
      
      res.write(`data: ${JSON.stringify({ 
        type: 'error', 
        error: userMessage,
        details: process.env.NODE_ENV === 'development' ? error.message : undefined,
      })}\n\n`);
      res.end();
    }
  }

  /**
   * Create Vercel AI SDK compatible tools from CRM_TOOLS
   * Uses AI SDK v5 format with inputSchema and execute
   */
  private createAiSdkTools(userId: string) {
    const self = this;

    return {
      resolve_entity: tool({
        description: `Resolve an entity name to its CRM ID. Use this BEFORE creating activities, notes, or any operation that requires an entity ID when user provides a name instead of ID.

WHEN TO USE:
- User says "Log a call with Acme" â†’ resolve_entity to get the account ID
- User says "Add a note to the Microsoft deal" â†’ resolve_entity to get the opportunity ID
- User says "Show me John Smith's contact" â†’ resolve_entity to get the contact ID`,
        inputSchema: z.object({
          entityType: z.enum(['lead', 'contact', 'account', 'opportunity']).describe('Type of entity to look up'),
          name: z.string().describe('The name to search for (company name, person name, or deal name)'),
          fuzzyMatch: z.boolean().optional().default(true).describe('If true, returns partial matches'),
        }),
        execute: async (args) => self.executeTool('resolve_entity', args, userId),
      }),

      create_lead: tool({
        description: 'Create a new lead in the CRM system',
        inputSchema: z.object({
          firstName: z.string().describe('First name of the lead'),
          lastName: z.string().describe('Last name of the lead'),
          company: z.string().describe('Company name'),
          email: z.string().describe('Email address'),
          phone: z.string().optional().describe('Phone number'),
          title: z.string().optional().describe('Job title'),
        }),
        execute: async (args) => self.executeTool('create_lead', args, userId),
      }),

      search_leads: tool({
        description: 'Search for leads in the CRM. IMPORTANT: If user specifies a number (e.g., "show 3 leads"), pass it as limit.',
        inputSchema: z.object({
          status: z.string().optional().describe('Lead status filter'),
          rating: z.string().optional().describe('Lead rating filter'),
          minScore: z.number().optional().describe('Minimum lead score'),
          company: z.string().optional().describe('Company name filter'),
          limit: z.number().optional().describe('Maximum results - extract from user query if specified (e.g., "show 3" â†’ limit: 3)'),
        }),
        execute: async (args) => self.executeTool('search_leads', args, userId),
      }),

      get_pipeline_stats: tool({
        description: 'Get current pipeline statistics including total opportunities, value, and breakdown by stage',
        inputSchema: z.object({}),
        execute: async () => self.executeTool('get_pipeline_stats', {}, userId),
      }),

      search_opportunities: tool({
        description: 'Search for opportunities in the pipeline',
        inputSchema: z.object({
          stage: z.string().optional().describe('Opportunity stage'),
          minAmount: z.number().optional().describe('Minimum amount'),
          closeDate: z.string().optional().describe('Close date filter'),
          limit: z.number().optional().describe('Maximum results'),
        }),
        execute: async (args) => self.executeTool('search_opportunities', args, userId),
      }),

      get_top_leads: tool({
        description: 'Get the top-scoring leads (score >= 70) that need attention. IMPORTANT: If user specifies a number (e.g., "top 3 leads", "show me 5 leads"), extract that number and pass it as the limit parameter.',
        inputSchema: z.object({
          limit: z.number().optional().describe('Number of leads to return - MUST be extracted from user query if specified (e.g., "top 3" â†’ limit: 3). Default: 5'),
        }),
        execute: async (args) => self.executeTool('get_top_leads', args, userId),
      }),

      get_my_tasks: tool({
        description: 'Get tasks assigned to the current user',
        inputSchema: z.object({
          status: z.string().optional().describe('Task status filter'),
          priority: z.string().optional().describe('Priority filter'),
          dueToday: z.boolean().optional().describe('Only tasks due today'),
        }),
        execute: async (args) => self.executeTool('get_my_tasks', args, userId),
      }),

      create_task: tool({
        description: 'Create a new task. IMPORTANT: Before calling this tool, confirm: subject (what needs to be done), dueDate (when). If user has NOT explicitly specified these, ASK first. Never assume due dates.',
        inputSchema: z.object({
          subject: z.string().describe('Task subject - MUST be provided by user'),
          description: z.string().optional().describe('Task description'),
          dueDate: z.string().describe('Due date - MUST be explicitly provided by user, NEVER assume or make up dates'),
          priority: z.string().optional().describe('Priority level'),
          relatedTo: z.string().optional().describe('Related entity'),
        }),
        execute: async (args) => self.executeTool('create_task', args, userId),
      }),

      list_indexed_documents: tool({
        description: 'List all documents that have been indexed and are available for searching',
        inputSchema: z.object({}),
        execute: async () => self.executeTool('list_indexed_documents', {}, userId),
      }),

      search_document: tool({
        description: 'Search within an indexed document to find relevant information',
        inputSchema: z.object({
          documentId: z.string().describe('Document ID to search'),
          query: z.string().describe('Search query'),
          maxResults: z.number().optional().describe('Maximum results'),
        }),
        execute: async (args) => self.executeTool('search_document', args, userId),
      }),

      get_lead_details: tool({
        description: 'Get detailed information about a specific lead by ID',
        inputSchema: z.object({
          leadId: z.string().describe('The ID of the lead to retrieve'),
        }),
        execute: async (args) => self.executeTool('get_lead_details', args, userId),
      }),

      update_lead: tool({
        description: 'Update an existing lead\'s information or status',
        inputSchema: z.object({
          leadId: z.string().describe('The ID of the lead to update'),
          status: z.string().optional().describe('New status for the lead'),
          rating: z.string().optional().describe('New rating for the lead'),
          notes: z.string().optional().describe('Notes about the update'),
        }),
        execute: async (args) => self.executeTool('update_lead', args, userId),
      }),

      get_opportunity_details: tool({
        description: 'Get detailed information about a specific opportunity by ID',
        inputSchema: z.object({
          opportunityId: z.string().describe('The ID of the opportunity to retrieve'),
        }),
        execute: async (args) => self.executeTool('get_opportunity_details', args, userId),
      }),

      update_opportunity: tool({
        description: 'Update an opportunity\'s stage, amount, or other details. CRITICAL: You MUST have the opportunity ID from a previous query. If user references an opportunity by NAME, FIRST use search_opportunities to get the ID. For Salesforce opportunities (ID starts with 006), use sf_update_opportunity instead.',
        inputSchema: z.object({
          opportunityId: z.string().describe('The ID of the opportunity to update (from previous search/query results)'),
          stage: z.string().optional().describe('New stage'),
          amount: z.number().optional().describe('New amount'),
          closeDate: z.string().optional().describe('New close date'),
          notes: z.string().optional().describe('Notes about the update'),
        }),
        execute: async (args) => self.executeTool('update_opportunity', args, userId),
      }),

      create_opportunity: tool({
        description: 'Create a new opportunity/deal in the CRM. IMPORTANT: Before calling this tool, you MUST ask the user for the deal amount and close date if they did not provide them. Never make up values.',
        inputSchema: z.object({
          name: z.string().describe('Opportunity name (e.g., "Acme Corp - Product Deal")'),
          accountName: z.string().optional().describe('Name of the account/company'),
          accountId: z.string().optional().describe('Account ID if known'),
          amount: z.number().describe('Expected deal value in dollars - MUST be provided by user'),
          closeDate: z.string().describe('Expected close date - MUST be provided by user'),
          stage: z.string().optional().describe('Pipeline stage (PROSPECTING, QUALIFICATION, NEEDS_ANALYSIS, PROPOSAL_PRICE_QUOTE, NEGOTIATION_REVIEW)'),
          type: z.string().optional().describe('Opportunity type (NEW_BUSINESS, EXISTING_BUSINESS, UPSELL)'),
          source: z.string().optional().describe('Lead source'),
          nextStep: z.string().optional().describe('Next action to take'),
          description: z.string().optional().describe('Description or notes'),
        }),
        execute: async (args) => self.executeTool('create_opportunity', args, userId),
      }),

      log_activity: tool({
        description: 'Log an activity (call, email, meeting) related to a CRM record',
        inputSchema: z.object({
          type: z.string().describe('Activity type (CALL, EMAIL, MEETING, etc.)'),
          subject: z.string().describe('Activity subject'),
          description: z.string().optional().describe('Activity details'),
          relatedTo: z.string().optional().describe('Related entity'),
          outcome: z.string().optional().describe('Activity outcome'),
        }),
        execute: async (args) => self.executeTool('log_activity', args, userId),
      }),

      web_search: tool({
        description: 'Search the web for any information using Google Custom Search',
        inputSchema: z.object({
          query: z.string().describe('The search query to look up on the web'),
        }),
        execute: async (args) => self.executeTool('web_search', args, userId),
      }),

      research_company: tool({
        description: 'Research a company by URL or name using WEB SEARCH. Gathers comprehensive information from the web including company overview, recent news, leadership team, financial data, stock info, earnings, revenue, and competitors. MUST USE this tool when user asks to: "research [company]", "analyze [company] financial performance", "[company] stock/revenue/earnings", or any company analysis beyond CRM data. CRM data does NOT contain financial information - this tool DOES.',
        inputSchema: z.object({
          companyUrlOrName: z.string().describe('Company website URL or company name'),
          includeNews: z.boolean().optional().describe('Include recent news'),
          includeLeadership: z.boolean().optional().describe('Include leadership info'),
          includeCompetitors: z.boolean().optional().describe('Include competitor analysis'),
          includeJobs: z.boolean().optional().describe('Include job postings'),
        }),
        execute: async (args) => self.executeTool('research_company', args, userId),
      }),

      get_forecast: tool({
        description: 'Get sales forecast data for the current quarter or year',
        inputSchema: z.object({
          period: z.string().optional().describe('Forecast period (quarter, year)'),
        }),
        execute: async (args) => self.executeTool('get_forecast', args, userId),
      }),

      get_at_risk_opportunities: tool({
        description: 'Get opportunities that are at risk based on AI analysis',
        inputSchema: z.object({
          limit: z.number().optional().describe('Number of opportunities to return'),
        }),
        execute: async (args) => self.executeTool('get_at_risk_opportunities', args, userId),
      }),

      get_hot_opportunities: tool({
        description: 'Get hot opportunities in the pipeline - high value deals (>$50K) in active sales stages like Qualification, Proposal, Negotiation. Use this when user asks about hot deals, high priority opportunities, or pipeline opportunities to focus on.',
        inputSchema: z.object({
          minAmount: z.number().optional().describe('Minimum deal amount (default: 50000)'),
          limit: z.number().optional().describe('Number of opportunities to return (default: 10)'),
        }),
        execute: async (args) => self.executeTool('get_hot_opportunities', args, userId),
      }),

      search_accounts: tool({
        description: 'Search for accounts (companies) in the CRM',
        inputSchema: z.object({
          name: z.string().optional().describe('Account name to search for'),
          type: z.string().optional().describe('Account type'),
          industry: z.string().optional().describe('Industry filter'),
          limit: z.number().optional().describe('Maximum results'),
        }),
        execute: async (args) => self.executeTool('search_accounts', args, userId),
      }),

      search_contacts: tool({
        description: 'Search for contacts in the CRM',
        inputSchema: z.object({
          name: z.string().optional().describe('Contact name to search for'),
          accountId: z.string().optional().describe('Filter by account ID'),
          title: z.string().optional().describe('Job title filter'),
          limit: z.number().optional().describe('Maximum results'),
        }),
        execute: async (args) => self.executeTool('search_contacts', args, userId),
      }),

      send_email: tool({
        description: 'Send an email to one or more recipients. Use for follow-ups, meeting agendas, proposals, and general communication.',
        inputSchema: z.object({
          to: z.array(z.string()).describe('Email addresses of recipients'),
          subject: z.string().describe('Email subject line'),
          body: z.string().describe('Email body content (can include HTML formatting)'),
          isHtml: z.boolean().optional().describe('Whether the body is HTML formatted (default: true)'),
        }),
        execute: async (args) => self.executeTool('send_email', args, userId),
      }),

      get_email_threads: tool({
        description: 'Get all email threads/conversations for the current user. Shows email history and status.',
        inputSchema: z.object({
          status: z.enum(['AWAITING_RESPONSE', 'RESPONDED', 'CLOSED', 'FOLLOW_UP_NEEDED']).optional().describe('Filter by thread status'),
          limit: z.number().optional().describe('Maximum number of threads to return (default: 20)'),
        }),
        execute: async (args) => self.executeTool('get_email_threads', args, userId),
      }),

      get_awaiting_responses: tool({
        description: 'Get all email threads waiting for a response. Use this to find emails that need follow-up or are overdue.',
        inputSchema: z.object({}),
        execute: async () => self.executeTool('get_awaiting_responses', {}, userId),
      }),

      get_thread_messages: tool({
        description: 'Get the full email messages/content from a specific email thread. Use this to read the actual email body text of messages including replies. This allows viewing the complete email trail.',
        inputSchema: z.object({
          threadId: z.string().describe('The ID of the email thread to get messages from'),
        }),
        execute: async (args) => self.executeTool('get_thread_messages', args, userId),
      }),

      get_email_drafts: tool({
        description: 'Get all AI-generated email drafts ready for review and sending. Optionally filter by thread ID.',
        inputSchema: z.object({
          threadId: z.string().optional().describe('Optional thread ID to filter drafts for a specific email thread'),
        }),
        execute: async (args) => self.executeTool('get_email_drafts', args, userId),
      }),

      send_email_draft: tool({
        description: 'Send a previously generated email draft after reviewing it.',
        inputSchema: z.object({
          draftId: z.string().describe('The ID of the draft to send'),
        }),
        execute: async (args) => self.executeTool('send_email_draft', args, userId),
      }),
    };
  }

  /**
   * Create CRM-only AI SDK tools (no document search)
   * Used for Globe/Global mode
   */
  private createCrmOnlyAiSdkTools(userId: string) {
    const self = this;

    return {
      resolve_entity: tool({
        description: `Resolve an entity name to its CRM ID. Use this BEFORE creating activities, notes, or any operation that requires an entity ID when user provides a name instead of ID.

WHEN TO USE:
- User says "Log a call with Acme" â†’ resolve_entity to get the account ID
- User says "Add a note to the Microsoft deal" â†’ resolve_entity to get the opportunity ID
- User says "Show me John Smith's contact" â†’ resolve_entity to get the contact ID`,
        inputSchema: z.object({
          entityType: z.enum(['lead', 'contact', 'account', 'opportunity']).describe('Type of entity to look up'),
          name: z.string().describe('The name to search for (company name, person name, or deal name)'),
          fuzzyMatch: z.boolean().optional().default(true).describe('If true, returns partial matches'),
        }),
        execute: async (args) => self.executeTool('resolve_entity', args, userId),
      }),

      create_lead: tool({
        description: 'Create a new lead. IMPORTANT: Ask user for firstName, lastName, company, and email if not provided. Never make up contact details.',
        inputSchema: z.object({
          firstName: z.string().describe('First name - MUST be provided by user'),
          lastName: z.string().describe('Last name - MUST be provided by user'),
          company: z.string().describe('Company name - MUST be provided by user'),
          email: z.string().describe('Email address - MUST be provided by user'),
          phone: z.string().optional().describe('Phone number'),
          title: z.string().optional().describe('Job title'),
        }),
        execute: async (args) => self.executeTool('create_lead', args, userId),
      }),

      search_leads: tool({
        description: 'Search for leads in the CRM. IMPORTANT: If user specifies a number (e.g., "show 3 leads"), pass it as limit.',
        inputSchema: z.object({
          status: z.string().optional().describe('Lead status filter'),
          rating: z.string().optional().describe('Lead rating filter'),
          minScore: z.number().optional().describe('Minimum lead score'),
          company: z.string().optional().describe('Company name filter'),
          limit: z.number().optional().describe('Maximum results - extract from user query if specified (e.g., "show 3" â†’ limit: 3)'),
        }),
        execute: async (args) => self.executeTool('search_leads', args, userId),
      }),

      get_pipeline_stats: tool({
        description: 'Get current pipeline statistics',
        inputSchema: z.object({}),
        execute: async () => self.executeTool('get_pipeline_stats', {}, userId),
      }),

      search_opportunities: tool({
        description: 'Search for opportunities in the pipeline',
        inputSchema: z.object({
          stage: z.string().optional().describe('Opportunity stage'),
          minAmount: z.number().optional().describe('Minimum amount'),
          closeDate: z.string().optional().describe('Close date filter'),
          limit: z.number().optional().describe('Maximum results'),
        }),
        execute: async (args) => self.executeTool('search_opportunities', args, userId),
      }),

      get_top_leads: tool({
        description: 'Get the top-scoring leads that need attention. IMPORTANT: If user specifies a number (e.g., "top 3 leads", "show me 5 leads"), extract that number and pass it as the limit parameter.',
        inputSchema: z.object({
          limit: z.number().optional().describe('Number of leads to return - MUST be extracted from user query if specified (e.g., "top 3" â†’ limit: 3). Default: 5'),
        }),
        execute: async (args) => self.executeTool('get_top_leads', args, userId),
      }),

      get_my_tasks: tool({
        description: 'Get tasks assigned to the current user',
        inputSchema: z.object({
          status: z.string().optional().describe('Task status filter'),
          priority: z.string().optional().describe('Priority filter'),
          dueToday: z.boolean().optional().describe('Only tasks due today'),
        }),
        execute: async (args) => self.executeTool('get_my_tasks', args, userId),
      }),

      create_task: tool({
        description: 'Create a new task. IMPORTANT: Before calling this tool, confirm: subject (what needs to be done), dueDate (when). If user has NOT explicitly specified these, ASK first. Never assume due dates.',
        inputSchema: z.object({
          subject: z.string().describe('Task subject - MUST be provided by user'),
          description: z.string().optional().describe('Task description'),
          dueDate: z.string().describe('Due date - MUST be explicitly provided by user, NEVER assume or make up dates'),
          priority: z.string().optional().describe('Priority level'),
          relatedTo: z.string().optional().describe('Related entity'),
        }),
        execute: async (args) => self.executeTool('create_task', args, userId),
      }),

      get_lead_details: tool({
        description: 'Get detailed information about a specific lead',
        inputSchema: z.object({
          leadId: z.string().describe('The ID of the lead'),
        }),
        execute: async (args) => self.executeTool('get_lead_details', args, userId),
      }),

      update_lead: tool({
        description: 'Update an existing lead',
        inputSchema: z.object({
          leadId: z.string().describe('The ID of the lead'),
          status: z.string().optional().describe('New status'),
          rating: z.string().optional().describe('New rating'),
          notes: z.string().optional().describe('Notes'),
        }),
        execute: async (args) => self.executeTool('update_lead', args, userId),
      }),

      get_opportunity_details: tool({
        description: 'Get detailed information about a specific opportunity',
        inputSchema: z.object({
          opportunityId: z.string().describe('The ID of the opportunity'),
        }),
        execute: async (args) => self.executeTool('get_opportunity_details', args, userId),
      }),

      update_opportunity: tool({
        description: 'Update an opportunity. CRITICAL: You MUST have the opportunity ID from a previous query. If user references an opportunity by NAME, FIRST use search_opportunities to get the ID. For Salesforce opportunities (ID starts with 006), use sf_update_opportunity instead.',
        inputSchema: z.object({
          opportunityId: z.string().describe('The ID of the opportunity (from previous search/query results)'),
          stage: z.string().optional().describe('New stage'),
          amount: z.number().optional().describe('New amount'),
          closeDate: z.string().optional().describe('New close date'),
          notes: z.string().optional().describe('Notes'),
        }),
        execute: async (args) => self.executeTool('update_opportunity', args, userId),
      }),

      create_opportunity: tool({
        description: 'Create a new opportunity/deal. IMPORTANT: Ask user for amount and close date if not provided. Never make up values.',
        inputSchema: z.object({
          name: z.string().describe('Opportunity name'),
          accountName: z.string().optional().describe('Account name'),
          accountId: z.string().optional().describe('Account ID'),
          amount: z.number().describe('Deal value - MUST be provided by user'),
          closeDate: z.string().describe('Expected close date - MUST be provided by user'),
          stage: z.string().optional().describe('Pipeline stage'),
          type: z.string().optional().describe('Opportunity type'),
          source: z.string().optional().describe('Lead source'),
          nextStep: z.string().optional().describe('Next action'),
          description: z.string().optional().describe('Description'),
        }),
        execute: async (args) => self.executeTool('create_opportunity', args, userId),
      }),

      log_activity: tool({
        description: 'Log an activity (call, email, meeting)',
        inputSchema: z.object({
          type: z.string().describe('Activity type'),
          subject: z.string().describe('Activity subject'),
          description: z.string().optional().describe('Activity details'),
          relatedTo: z.string().optional().describe('Related entity'),
          outcome: z.string().optional().describe('Activity outcome'),
        }),
        execute: async (args) => self.executeTool('log_activity', args, userId),
      }),

      web_search: tool({
        description: 'Search the web for information',
        inputSchema: z.object({
          query: z.string().describe('The search query'),
        }),
        execute: async (args) => self.executeTool('web_search', args, userId),
      }),

      research_company: tool({
        description: 'Research a company by URL or name using WEB SEARCH. Gathers comprehensive information from the web including company overview, recent news, leadership team, financial data, stock info, earnings, revenue, and competitors. MUST USE this tool when user asks to: "research [company]", "analyze [company] financial performance", "[company] stock/revenue/earnings", or any company analysis beyond CRM data. CRM data does NOT contain financial information - this tool DOES.',
        inputSchema: z.object({
          companyUrlOrName: z.string().describe('Company website URL or name'),
          includeNews: z.boolean().optional().describe('Include recent news'),
          includeLeadership: z.boolean().optional().describe('Include leadership info'),
          includeCompetitors: z.boolean().optional().describe('Include competitors'),
          includeJobs: z.boolean().optional().describe('Include job postings'),
        }),
        execute: async (args) => self.executeTool('research_company', args, userId),
      }),

      get_forecast: tool({
        description: 'Get sales forecast data',
        inputSchema: z.object({
          period: z.string().optional().describe('Forecast period'),
        }),
        execute: async (args) => self.executeTool('get_forecast', args, userId),
      }),

      get_at_risk_opportunities: tool({
        description: 'Get opportunities that are at risk',
        inputSchema: z.object({
          limit: z.number().optional().describe('Number to return'),
        }),
        execute: async (args) => self.executeTool('get_at_risk_opportunities', args, userId),
      }),

      get_hot_opportunities: tool({
        description: 'Get hot opportunities in the pipeline - high value deals (>$50K) in active sales stages',
        inputSchema: z.object({
          minAmount: z.number().optional().describe('Minimum deal amount'),
          limit: z.number().optional().describe('Number to return'),
        }),
        execute: async (args) => self.executeTool('get_hot_opportunities', args, userId),
      }),

      get_account_signals: tool({
        description: `Get AI-detected account signals and alerts from the Listening Agent. ALWAYS use this tool when user asks:
- "Show me my signals"
- "What signals do I have?"
- "What's happening with my accounts?"
- "Any alerts?"
- "Account notifications"
- "Show me account activity"

Returns executive changes, funding events, expansion signals, technology changes, news mentions, and usage patterns detected by AI agents.`,
        inputSchema: z.object({
          accountId: z.string().optional().describe('Filter signals by specific account ID'),
          status: z.enum(['PENDING', 'ACKNOWLEDGED', 'ACTIONED', 'DISMISSED']).optional().describe('Filter by signal status'),
          priority: z.enum(['LOW', 'MEDIUM', 'HIGH', 'CRITICAL']).optional().describe('Filter by priority level'),
          signalTypes: z.array(z.enum(['EXEC_CHANGE', 'FUNDING', 'EXPANSION', 'TECH_CHANGE', 'NEWS', 'USAGE_SPIKE'])).optional().describe('Filter by signal types'),
          timeframe: z.enum(['24h', '7d', '30d', '90d']).optional().describe('Time range for signals'),
          limit: z.number().optional().describe('Maximum number of signals to return'),
        }),
        execute: async (args) => self.executeTool('get_account_signals', args, userId),
      }),

      search_accounts: tool({
        description: 'Search for accounts in the CRM',
        inputSchema: z.object({
          name: z.string().optional().describe('Account name'),
          type: z.string().optional().describe('Account type'),
          industry: z.string().optional().describe('Industry'),
          limit: z.number().optional().describe('Maximum results'),
        }),
        execute: async (args) => self.executeTool('search_accounts', args, userId),
      }),

      search_contacts: tool({
        description: 'Search for contacts in the CRM',
        inputSchema: z.object({
          name: z.string().optional().describe('Contact name'),
          accountId: z.string().optional().describe('Filter by account'),
          title: z.string().optional().describe('Job title filter'),
          limit: z.number().optional().describe('Maximum results'),
        }),
        execute: async (args) => self.executeTool('search_contacts', args, userId),
      }),

      // Meeting Intelligence Tools
      schedule_meeting: tool({
        description: 'Schedule a new meeting with a client on Zoom, Microsoft Teams, or Google Meet. The meeting will be automatically recorded and transcribed. Use this when the user asks to schedule or create a meeting. For Zoom meetings, a host email is required.',
        inputSchema: z.object({
          title: z.string().describe('Title of the meeting'),
          platform: z.enum(['ZOOM', 'TEAMS', 'GOOGLE_MEET']).describe('Meeting platform to use'),
          scheduledStart: z.string().describe('ISO 8601 datetime for meeting start'),
          duration: z.number().optional().default(60).describe('Duration of the meeting in minutes (default: 60)'),
          description: z.string().optional().describe('Meeting description or agenda'),
          hostEmail: z.string().optional().describe('Email address of the meeting host (required for Zoom meetings). If not provided, use the current user email.'),
          leadId: z.string().optional().describe('ID of the lead this meeting is about'),
          accountId: z.string().optional().describe('ID of the account this meeting is about'),
          opportunityId: z.string().optional().describe('ID of the opportunity this meeting is about'),
          attendeeEmails: z.array(z.string()).optional().describe('Email addresses of attendees to invite'),
        }),
        execute: async (args) => self.executeTool('schedule_meeting', args, userId),
      }),

      list_meetings: tool({
        description: 'List all IRIS meeting sessions. ALWAYS call this tool FIRST when user mentions a meeting by person name (e.g., "meeting with David", "my meeting tomorrow") to find the meeting ID needed for cancel_meeting, get_meeting_rsvp_status, and other meeting operations. Returns meeting IDs, titles, status, participants, and scheduled times.',
        inputSchema: z.object({
          leadId: z.string().optional().describe('Filter by lead ID'),
          accountId: z.string().optional().describe('Filter by account ID'),
          opportunityId: z.string().optional().describe('Filter by opportunity ID'),
          status: z.string().optional().describe('Filter by meeting status'),
          platform: z.string().optional().describe('Filter by platform'),
          startDate: z.string().optional().describe('Filter meetings after this date'),
          endDate: z.string().optional().describe('Filter meetings before this date'),
          limit: z.number().optional().describe('Maximum number of meetings to return'),
        }),
        execute: async (args) => self.executeTool('list_meetings', args, userId),
      }),

      // MEETING INTELLIGENCE TOOLS - Transcript & Analysis
      get_meeting: tool({
        description: 'Get details of a specific meeting session including status, recording, transcript availability, and analysis. Use this to check meeting status or get meeting details by ID.',
        inputSchema: z.object({
          meetingId: z.string().describe('ID of the meeting session to retrieve'),
        }),
        execute: async (args) => self.executeTool('get_meeting', args, userId),
      }),

      get_meeting_transcript: tool({
        description: 'Get the full transcript of a completed meeting, including speaker attribution and timestamps. Use this when user asks "show me the transcript", "what was said in the meeting", etc.',
        inputSchema: z.object({
          meetingId: z.string().describe('ID of the meeting session to get transcript for'),
          format: z.enum(['text', 'segments']).optional().describe('Output format: "text" for plain text, "segments" for detailed speaker-attributed segments (default: segments)'),
        }),
        execute: async (args) => self.executeTool('get_meeting_transcript', args, userId),
      }),

      get_meeting_analysis: tool({
        description: 'Get the AI-generated analysis of a completed meeting including summary, key points, action items, decisions, sentiment, and sales insights. Use this when user asks "what was discussed", "summarize the meeting", "show analysis", etc.',
        inputSchema: z.object({
          meetingId: z.string().describe('ID of the meeting session to get analysis for'),
        }),
        execute: async (args) => self.executeTool('get_meeting_analysis', args, userId),
      }),

      get_meeting_insights: tool({
        description: 'Get actionable sales insights from a meeting including buying signals, objections, competitor mentions, next steps, and deal risk assessment.',
        inputSchema: z.object({
          meetingId: z.string().describe('ID of the meeting session'),
        }),
        execute: async (args) => self.executeTool('get_meeting_insights', args, userId),
      }),

      search_meeting_transcripts: tool({
        description: 'Search across all meeting transcripts for specific topics, keywords, or phrases. Useful for finding past discussions about specific features, competitors, or concerns.',
        inputSchema: z.object({
          query: z.string().describe('Search query - keywords or phrases to find in transcripts'),
          limit: z.number().optional().describe('Maximum number of results to return (default: 10)'),
        }),
        execute: async (args) => self.executeTool('search_meeting_transcripts', args, userId),
      }),

      // MEETING RSVP & PARTICIPANT MANAGEMENT TOOLS
      get_meeting_rsvp_status: tool({
        description: 'Get the RSVP status summary for a meeting including who has accepted, declined, or not yet responded',
        inputSchema: z.object({
          meetingId: z.string().describe('ID of the meeting to check RSVP status for'),
        }),
        execute: async (args) => self.executeTool('get_meeting_rsvp_status', args, userId),
      }),

      get_meeting_participants: tool({
        description: 'Get detailed information about all participants in a meeting including roles, response status, and contact details',
        inputSchema: z.object({
          meetingId: z.string().describe('ID of the meeting to get participants for'),
          includeContactDetails: z.boolean().optional().describe('Include linked contact details if available'),
        }),
        execute: async (args) => self.executeTool('get_meeting_participants', args, userId),
      }),

      update_meeting_rsvp: tool({
        description: 'Update the RSVP response for a meeting participant when they respond via phone, email, or other channel',
        inputSchema: z.object({
          meetingId: z.string().describe('ID of the meeting'),
          participantEmail: z.string().describe('Email address of the participant to update'),
          responseStatus: z.enum(['ACCEPTED', 'DECLINED', 'TENTATIVE']).describe('New response status'),
          responseNote: z.string().optional().describe('Optional note about the response'),
        }),
        execute: async (args) => self.executeTool('update_meeting_rsvp', args, userId),
      }),

      cancel_meeting: tool({
        description: 'Cancel/delete a scheduled meeting and send cancellation emails to all participants. Use this when user says "cancel meeting", "delete meeting", "remove meeting", or similar. First use list_meetings to find the meeting ID if user refers to meeting by person name.',
        inputSchema: z.object({
          meetingId: z.string().describe('ID of the meeting to cancel (get from list_meetings first)'),
          reason: z.string().optional().describe('Reason for cancellation'),
          sendNotification: z.boolean().optional().describe('Send cancellation email to participants (default: true)'),
        }),
        execute: async (args) => self.executeTool('cancel_meeting', args, userId),
      }),

      update_meeting: tool({
        description: 'Update/reschedule an existing meeting. Use this when user says "reschedule meeting", "change meeting time", "update meeting", or similar. Can update title, time, duration, or description. Sends update notifications to participants.',
        inputSchema: z.object({
          meetingId: z.string().describe('ID of the meeting to update (get from list_meetings first)'),
          title: z.string().optional().describe('New title for the meeting'),
          scheduledStart: z.string().optional().describe('New start time (ISO 8601 datetime)'),
          duration: z.number().optional().describe('New duration in minutes'),
          description: z.string().optional().describe('New description or agenda'),
          sendNotification: z.boolean().optional().describe('Send update notification to participants (default: true)'),
        }),
        execute: async (args) => self.executeTool('update_meeting', args, userId),
      }),

      get_meeting_response_history: tool({
        description: 'Get the full history of RSVP response changes for a meeting (audit trail)',
        inputSchema: z.object({
          meetingId: z.string().describe('ID of the meeting'),
          participantEmail: z.string().optional().describe('Filter to specific participant'),
        }),
        execute: async (args) => self.executeTool('get_meeting_response_history', args, userId),
      }),

      resend_meeting_invite: tool({
        description: 'Resend meeting invite to participants who have not responded',
        inputSchema: z.object({
          meetingId: z.string().describe('ID of the meeting'),
          emails: z.array(z.string()).optional().describe('Specific emails to resend to'),
          onlyPending: z.boolean().optional().describe('Only resend to pending participants'),
        }),
        execute: async (args) => self.executeTool('resend_meeting_invite', args, userId),
      }),

      check_meeting_availability: tool({
        description: 'Check if participants are likely available for a meeting time based on conflicts and past response patterns',
        inputSchema: z.object({
          participantEmails: z.array(z.string()).describe('Email addresses of potential participants'),
          proposedTime: z.string().describe('Proposed meeting time (ISO 8601)'),
          duration: z.number().optional().describe('Meeting duration in minutes'),
        }),
        execute: async (args) => self.executeTool('check_meeting_availability', args, userId),
      }),

      send_email: tool({
        description: 'Send an email to one or more recipients. Use for follow-ups, meeting agendas, proposals, and general communication.',
        inputSchema: z.object({
          to: z.array(z.string()).describe('Email addresses of recipients'),
          subject: z.string().describe('Email subject line'),
          body: z.string().describe('Email body content (can include HTML formatting)'),
          isHtml: z.boolean().optional().describe('Whether the body is HTML formatted (default: true)'),
        }),
        execute: async (args) => self.executeTool('send_email', args, userId),
      }),

      get_email_threads: tool({
        description: 'Get all email threads/conversations for the current user. Shows email history and status.',
        inputSchema: z.object({
          status: z.enum(['AWAITING_RESPONSE', 'RESPONDED', 'CLOSED', 'FOLLOW_UP_NEEDED']).optional().describe('Filter by thread status'),
          limit: z.number().optional().describe('Maximum number of threads to return (default: 20)'),
        }),
        execute: async (args) => self.executeTool('get_email_threads', args, userId),
      }),

      get_awaiting_responses: tool({
        description: 'Get all email threads waiting for a response. Use this to find emails that need follow-up or are overdue.',
        inputSchema: z.object({}),
        execute: async () => self.executeTool('get_awaiting_responses', {}, userId),
      }),

      get_thread_messages: tool({
        description: 'Get the full email messages/content from a specific email thread. Use this to read the actual email body text of messages including replies. This allows viewing the complete email trail.',
        inputSchema: z.object({
          threadId: z.string().describe('The ID of the email thread to get messages from'),
        }),
        execute: async (args) => self.executeTool('get_thread_messages', args, userId),
      }),

      get_email_drafts: tool({
        description: 'Get all AI-generated email drafts ready for review and sending. Optionally filter by thread ID.',
        inputSchema: z.object({
          threadId: z.string().optional().describe('Optional thread ID to filter drafts for a specific email thread'),
        }),
        execute: async (args) => self.executeTool('get_email_drafts', args, userId),
      }),

      send_email_draft: tool({
        description: 'Send a previously generated email draft after reviewing it.',
        inputSchema: z.object({
          draftId: z.string().describe('The ID of the draft to send'),
        }),
        execute: async (args) => self.executeTool('send_email_draft', args, userId),
      }),

      // Quote Tools
      search_quotes: tool({
        description: 'Search for quotes in the CRM. Use this to FIND quotes by quote number (e.g., Q-2025-003) or filter by status/account. Returns a SUMMARY list - for FULL DETAILS including line items, use get_quote_details with the quote ID from search results.',
        inputSchema: z.object({
          quoteNumber: z.string().optional().describe('Search by quote number (e.g., Q-2025-003 or partial match like 2025-003)'),
          status: z.string().optional().describe('Quote status filter: DRAFT, SENT, ACCEPTED, REJECTED, EXPIRED'),
          opportunityId: z.string().optional().describe('Filter by opportunity ID'),
          accountId: z.string().optional().describe('Filter by account ID'),
          limit: z.number().optional().describe('Maximum number of results (default 10)'),
        }),
        execute: async (args) => self.executeTool('search_quotes', args, userId),
      }),

      get_quote_details: tool({
        description: 'Get FULL details of a specific quote including line items, pricing breakdown, and all fields. ALWAYS use this after search_quotes when user asks for quote "details" or wants to see a specific quote. Requires the quote ID (not quote number) from search_quotes results.',
        inputSchema: z.object({
          quoteId: z.string().describe('The internal ID of the quote (from search_quotes results), NOT the quote number'),
        }),
        execute: async (args) => self.executeTool('get_quote_details', args, userId),
      }),

      // Contract Tools
      search_contracts: tool({
        description: 'Search for contracts in the CRM. Returns contracts with status, dates, and related account info.',
        inputSchema: z.object({
          status: z.string().optional().describe('Contract status filter: DRAFT, IN_APPROVAL, ACTIVATED, TERMINATED, EXPIRED'),
          accountId: z.string().optional().describe('Filter by account ID'),
          limit: z.number().optional().describe('Maximum number of results (default 10)'),
        }),
        execute: async (args) => self.executeTool('search_contracts', args, userId),
      }),

      get_contract_details: tool({
        description: 'Get detailed information about a specific contract.',
        inputSchema: z.object({
          contractId: z.string().describe('The ID of the contract to retrieve'),
        }),
        execute: async (args) => self.executeTool('get_contract_details', args, userId),
      }),
    };
  }

  /**
   * Create document-only AI SDK tools for DOCUMENT_SEARCH_MODE
   * Only includes tools for searching and viewing documents
   */
  private createDocumentOnlyAiSdkTools(userId: string) {
    const self = this;

    return {
      list_indexed_documents: tool({
        description: 'List all documents that have been indexed and are available for searching',
        inputSchema: z.object({}),
        execute: async () => self.executeTool('list_indexed_documents', {}, userId),
      }),

      search_document: tool({
        description: 'Search within an indexed document to find relevant information. ONLY report information from search results, never make up content.',
        inputSchema: z.object({
          documentId: z.string().describe('The ID of the document to search'),
          query: z.string().describe('The search query'),
          maxResults: z.number().optional().describe('Maximum results (default: 5)'),
        }),
        execute: async (args) => self.executeTool('search_document', args, userId),
      }),

      get_document_structure: tool({
        description: 'Get the full hierarchical structure (table of contents) of an indexed document',
        inputSchema: z.object({
          documentId: z.string().describe('The ID of the document'),
        }),
        execute: async (args) => self.executeTool('get_document_structure', args, userId),
      }),

      get_document_summary: tool({
        description: 'Get a comprehensive summary of an indexed document including all section summaries',
        inputSchema: z.object({
          documentId: z.string().describe('The ID of the document to summarize'),
        }),
        execute: async (args) => self.executeTool('get_document_summary', args, userId),
      }),
    };
  }

  /**
   * Create Salesforce AI SDK tools for SALESFORCE_MODE
   * Used when user has toggled to Salesforce external CRM
   * IMPORTANT: All tools pass dataSource='salesforce' to executeTool to ensure
   * the CRM mode toggle is honored across all experiences
   */
  private createSalesforceAiSdkTools(userId: string) {
    const self = this;
    // Explicitly set dataSource to 'salesforce' for all tools in this method
    const dataSource: 'salesforce' | 'local' = 'salesforce';

    return {
      sf_query: tool({
        description: `Execute a SOQL query against Salesforce. IMPORTANT: (1) ALWAYS include the Name field (or FirstName/LastName for Leads/Contacts) so users can identify records. (2) When ordering by numeric fields like Amount, use NULLS LAST to push empty values to the end. Example: SELECT Id, Name, Amount, StageName FROM Opportunity ORDER BY Amount DESC NULLS LAST LIMIT 5`,
        inputSchema: z.object({
          query: z.string().describe('The SOQL query - MUST include Name field and use NULLS LAST for numeric ordering'),
        }),
        execute: async (args) => self.executeTool('sf_query', args, userId, dataSource),
      }),

      sf_create_lead: tool({
        description: 'Create a new Lead record in Salesforce',
        inputSchema: z.object({
          FirstName: z.string().optional().describe('Lead first name'),
          LastName: z.string().describe('Lead last name (required)'),
          Company: z.string().describe('Company name (required)'),
          Email: z.string().optional().describe('Email address'),
          Phone: z.string().optional().describe('Phone number'),
          Title: z.string().optional().describe('Job title'),
          Industry: z.string().optional().describe('Industry'),
          LeadSource: z.string().optional().describe('Lead source'),
          Status: z.string().optional().describe('Lead status'),
          Description: z.string().optional().describe('Description or notes'),
        }),
        execute: async (args) => self.executeTool('sf_create_lead', args, userId, dataSource),
      }),

      sf_update_lead: tool({
        description: 'Update an existing Lead record in Salesforce. Accepts any valid Lead field dynamically. Use sf_describe_object to see all available fields.',
        inputSchema: z.object({
          leadId: z.string().describe('The Salesforce Lead ID'),
        }).passthrough(), // Allow any additional fields
        execute: async (args) => self.executeTool('sf_update_lead', args, userId, dataSource),
      }),

      sf_create_opportunity: tool({
        description: 'Create a new Opportunity record in Salesforce',
        inputSchema: z.object({
          Name: z.string().describe('Opportunity name (required)'),
          AccountId: z.string().optional().describe('Salesforce Account ID'),
          Amount: z.number().optional().describe('Opportunity amount'),
          CloseDate: z.string().describe('Expected close date (YYYY-MM-DD)'),
          StageName: z.string().describe('Sales stage (required)'),
          Probability: z.number().optional().describe('Win probability (0-100)'),
          Type: z.string().optional().describe('Opportunity type'),
          LeadSource: z.string().optional().describe('Lead source'),
          Description: z.string().optional().describe('Description'),
          NextStep: z.string().optional().describe('Next step'),
        }),
        execute: async (args) => self.executeTool('sf_create_opportunity', args, userId, dataSource),
      }),

      sf_update_opportunity: tool({
        description: 'Update an existing Opportunity record in Salesforce. CRITICAL REQUIREMENTS: (1) You MUST have the Salesforce Opportunity ID (starts with 006). If you only have the opportunity NAME, FIRST use sf_query to get the ID: SELECT Id, Name, StageName FROM Opportunity WHERE Name LIKE \'%OpportunityName%\'. (2) You MUST know the NEW VALUE before calling. If user says "update the stage" without specifying WHICH stage, DO NOT call - ASK user which stage they want. (3) NEVER use an Account ID (starts with 001) - you need the OPPORTUNITY ID (starts with 006).',
        inputSchema: z.object({
          opportunityId: z.string().describe('The Salesforce Opportunity ID (18-character, starts with 006). NOT the Account ID.'),
        }).passthrough(), // Allow any additional fields
        execute: async (args) => self.executeTool('sf_update_opportunity', args, userId, dataSource),
      }),

      sf_create_contact: tool({
        description: 'Create a new Contact record in Salesforce',
        inputSchema: z.object({
          FirstName: z.string().optional().describe('Contact first name'),
          LastName: z.string().describe('Contact last name (required)'),
          AccountId: z.string().optional().describe('Salesforce Account ID'),
          Email: z.string().optional().describe('Email address'),
          Phone: z.string().optional().describe('Phone number'),
          MobilePhone: z.string().optional().describe('Mobile phone'),
          Title: z.string().optional().describe('Job title'),
          Department: z.string().optional().describe('Department'),
          Description: z.string().optional().describe('Description'),
        }),
        execute: async (args) => self.executeTool('sf_create_contact', args, userId, dataSource),
      }),

      sf_create_account: tool({
        description: 'Create a new Account record in Salesforce',
        inputSchema: z.object({
          Name: z.string().describe('Account name (required)'),
          Type: z.string().optional().describe('Account type'),
          Industry: z.string().optional().describe('Industry'),
          Phone: z.string().optional().describe('Phone number'),
          Website: z.string().optional().describe('Website URL'),
          AnnualRevenue: z.number().optional().describe('Annual revenue'),
          NumberOfEmployees: z.number().optional().describe('Number of employees'),
          Description: z.string().optional().describe('Description'),
        }),
        execute: async (args) => self.executeTool('sf_create_account', args, userId, dataSource),
      }),

      sf_create_task: tool({
        description: 'Create a new Task in Salesforce for follow-ups or to-dos',
        inputSchema: z.object({
          Subject: z.string().describe('Task subject (required)'),
          WhoId: z.string().optional().describe('Related Contact or Lead ID'),
          WhatId: z.string().optional().describe('Related Account or Opportunity ID'),
          ActivityDate: z.string().optional().describe('Due date (YYYY-MM-DD)'),
          Status: z.string().optional().describe('Task status'),
          Priority: z.string().optional().describe('Priority (High, Normal, Low)'),
          Description: z.string().optional().describe('Task description'),
          Type: z.string().optional().describe('Task type'),
        }),
        execute: async (args) => self.executeTool('sf_create_task', args, userId, dataSource),
      }),

      sf_list_objects: tool({
        description: 'List all available Salesforce objects in the org. Use this to discover what objects (standard and custom) exist in the Salesforce org.',
        inputSchema: z.object({
          filter: z.enum(['all', 'standard', 'custom', 'queryable', 'createable']).optional().describe('Filter objects: all (default), standard (non-custom), custom (__c suffix), queryable (can be queried), createable (can create records)'),
        }),
        execute: async (args) => self.executeTool('sf_list_objects', args, userId, dataSource),
      }),

      sf_describe_object: tool({
        description: 'Get detailed metadata about a Salesforce object including all available fields, their types, whether they are required, and picklist values. Use this to discover what fields can be updated or queried.',
        inputSchema: z.object({
          objectType: z.string().describe('The Salesforce object API name (e.g., Lead, Contact, Account, Custom_Object__c)'),
          fieldFilter: z.enum(['all', 'updateable', 'createable', 'required']).optional().describe('Filter fields: all (default), updateable, createable, required'),
        }),
        execute: async (args) => self.executeTool('sf_describe_object', args, userId, dataSource),
      }),

      sf_get_record: tool({
        description: 'Get a single Salesforce record by ID. If no fields specified, will automatically fetch all queryable fields for the object type.',
        inputSchema: z.object({
          objectType: z.string().describe('The Salesforce object API name'),
          recordId: z.string().describe('The Salesforce record ID'),
          fields: z.string().optional().describe('Comma-separated list of field names'),
        }),
        execute: async (args) => self.executeTool('sf_get_record', args, userId, dataSource),
      }),

      sf_update_record: tool({
        description: 'Update any Salesforce record with any fields. CRITICAL: You MUST know the exact NEW VALUES before calling this tool. If the user requests an update but does not specify the target value (e.g., "change the stage" without saying which stage), DO NOT call this tool - instead ASK the user what value they want. Use sf_describe_object to get valid picklist options to offer.',
        inputSchema: z.object({
          objectType: z.string().describe('The Salesforce object API name (e.g., Lead, Contact, Account, Opportunity)'),
          recordId: z.string().describe('The Salesforce record ID (18-character ID)'),
          fields: z.record(z.string(), z.any()).describe('Object containing field names and values to update. Use exact Salesforce API field names (e.g., FirstName, Street, City, State, PostalCode).'),
        }),
        execute: async (args) => self.executeTool('sf_update_record', args, userId, dataSource),
      }),

      sf_create_record: tool({
        description: 'Create any Salesforce record with any fields. Use sf_describe_object first to see available and required fields.',
        inputSchema: z.object({
          objectType: z.string().describe('The Salesforce object API name (e.g., Lead, Contact, Account, Opportunity, Task)'),
          fields: z.record(z.string(), z.any()).describe('Object containing field names and values for the new record. Use exact Salesforce API field names.'),
        }),
        execute: async (args) => self.executeTool('sf_create_record', args, userId, dataSource),
      }),

      sf_delete_record: tool({
        description: 'Delete a Salesforce record by ID. Use with caution - this permanently deletes the record.',
        inputSchema: z.object({
          objectType: z.string().describe('The Salesforce object API name (e.g., Lead, Contact, Account)'),
          recordId: z.string().describe('The Salesforce record ID to delete'),
        }),
        execute: async (args) => self.executeTool('sf_delete_record', args, userId, dataSource),
      }),

      sf_search: tool({
        description: 'Search across multiple Salesforce objects using SOSL (Salesforce Object Search Language). Use this for cross-object text searches.',
        inputSchema: z.object({
          searchTerm: z.string().describe('The text to search for'),
          objects: z.array(z.string()).optional().describe('Array of object names to search in (e.g., ["Lead", "Contact", "Account"]). If not specified, searches all searchable objects.'),
          limit: z.number().optional().describe('Maximum records per object (default: 20)'),
        }),
        execute: async (args) => self.executeTool('sf_search', args, userId, dataSource),
      }),

      // =============================================================================
      // ADMIN/CONFIG TOOLS - Tooling API Operations
      // =============================================================================

      sf_tooling_query: tool({
        description: 'Execute a Tooling API SOQL query for setup/config metadata',
        inputSchema: z.object({
          query: z.string().describe('The Tooling API SOQL query'),
        }),
        execute: async (args) => self.executeTool('sf_tooling_query', args, userId, dataSource),
      }),

      sf_list_users: tool({
        description: 'List active users in the Salesforce org',
        inputSchema: z.object({
          limit: z.number().optional().describe('Maximum users to return (default: 50)'),
        }),
        execute: async (args) => self.executeTool('sf_list_users', args, userId, dataSource),
      }),

      sf_list_profiles: tool({
        description: 'List all profiles in the Salesforce org',
        inputSchema: z.object({}),
        execute: async () => self.executeTool('sf_list_profiles', {}, userId, dataSource),
      }),

      sf_list_permission_sets: tool({
        description: 'List custom permission sets in the org',
        inputSchema: z.object({}),
        execute: async () => self.executeTool('sf_list_permission_sets', {}, userId, dataSource),
      }),

      sf_assign_permission_set: tool({
        description: 'Assign a permission set to a user',
        inputSchema: z.object({
          assigneeId: z.string().describe('The User ID to assign to'),
          permissionSetId: z.string().describe('The Permission Set ID'),
        }),
        execute: async (args) => self.executeTool('sf_assign_permission_set', args, userId, dataSource),
      }),

      sf_list_custom_fields: tool({
        description: 'List custom fields on a Salesforce object',
        inputSchema: z.object({
          objectName: z.string().describe('The object API name (e.g., Account, Lead)'),
        }),
        execute: async (args) => self.executeTool('sf_list_custom_fields', args, userId, dataSource),
      }),

      sf_list_validation_rules: tool({
        description: 'List validation rules on a Salesforce object',
        inputSchema: z.object({
          objectName: z.string().describe('The object API name'),
        }),
        execute: async (args) => self.executeTool('sf_list_validation_rules', args, userId, dataSource),
      }),

      sf_toggle_validation_rule: tool({
        description: 'Activate or deactivate a validation rule',
        inputSchema: z.object({
          validationRuleId: z.string().describe('The Validation Rule ID'),
          active: z.boolean().describe('True to activate, false to deactivate'),
        }),
        execute: async (args) => self.executeTool('sf_toggle_validation_rule', args, userId, dataSource),
      }),

      sf_list_flows: tool({
        description: 'List Process Builder processes and Flows',
        inputSchema: z.object({
          activeOnly: z.boolean().optional().describe('Only show active flows (default: true)'),
        }),
        execute: async (args) => self.executeTool('sf_list_flows', args, userId, dataSource),
      }),

      sf_list_record_types: tool({
        description: 'List record types for a Salesforce object',
        inputSchema: z.object({
          objectName: z.string().describe('The object API name'),
        }),
        execute: async (args) => self.executeTool('sf_list_record_types', args, userId, dataSource),
      }),

      sf_get_org_limits: tool({
        description: 'Get current org limits and usage',
        inputSchema: z.object({}),
        execute: async () => self.executeTool('sf_get_org_limits', {}, userId, dataSource),
      }),

      sf_list_apex_classes: tool({
        description: 'List Apex classes in the org',
        inputSchema: z.object({
          limit: z.number().optional().describe('Maximum classes to return (default: 100)'),
        }),
        execute: async (args) => self.executeTool('sf_list_apex_classes', args, userId, dataSource),
      }),

      sf_list_apex_triggers: tool({
        description: 'List Apex triggers, optionally filtered by object',
        inputSchema: z.object({
          objectName: z.string().optional().describe('Filter triggers by object'),
        }),
        execute: async (args) => self.executeTool('sf_list_apex_triggers', args, userId, dataSource),
      }),

      sf_run_apex_tests: tool({
        description: 'Run Apex tests',
        inputSchema: z.object({
          testClassId: z.string().optional().describe('Specific test class ID (optional)'),
        }),
        execute: async (args) => self.executeTool('sf_run_apex_tests', args, userId, dataSource),
      }),

      sf_list_installed_packages: tool({
        description: 'List installed managed packages',
        inputSchema: z.object({}),
        execute: async () => self.executeTool('sf_list_installed_packages', {}, userId, dataSource),
      }),

      sf_execute_apex: tool({
        description: 'Execute anonymous Apex code (use with caution)',
        inputSchema: z.object({
          apexCode: z.string().describe('The Apex code to execute'),
        }),
        execute: async (args) => self.executeTool('sf_execute_apex', args, userId, dataSource),
      }),

      // =============================================================================
      // METADATA MODIFICATION TOOLS - Create/Update Schema Elements
      // =============================================================================

      sf_create_custom_field: tool({
        description: 'Create a new custom field on a Salesforce object. IMPORTANT: Always confirm with user before creating. Returns detailed error suggestions if creation fails.',
        inputSchema: z.object({
          objectName: z.string().describe('The object API name (e.g., Account, Lead, Custom_Object__c)'),
          fullName: z.string().describe('API name for the field (e.g., My_Custom_Field)'),
          label: z.string().describe('User-friendly label for the field'),
          type: z.enum(['Text', 'Number', 'Checkbox', 'Picklist', 'Date', 'DateTime', 'Email', 'Phone', 'URL', 'TextArea', 'LongTextArea', 'Currency', 'Percent', 'Lookup', 'MasterDetail']).describe('Field data type'),
          length: z.number().optional().describe('For Text: max length (1-255). For LongTextArea: up to 131072'),
          precision: z.number().optional().describe('For Number/Currency/Percent: total digits'),
          scale: z.number().optional().describe('For Number/Currency/Percent: decimal places'),
          required: z.boolean().optional().describe('Whether field is required'),
          unique: z.boolean().optional().describe('Whether values must be unique'),
          description: z.string().optional().describe('Field description'),
          helpText: z.string().optional().describe('Help text shown to users'),
          picklistValues: z.array(z.string()).optional().describe('For Picklist: allowed values'),
          referenceTo: z.string().optional().describe('For Lookup/MasterDetail: referenced object'),
          relationshipLabel: z.string().optional().describe('For Lookup/MasterDetail: child relationship label'),
          defaultValue: z.string().optional().describe('Default value'),
        }),
        execute: async (args) => self.executeTool('sf_create_custom_field', args, userId, dataSource),
      }),

      sf_create_custom_object: tool({
        description: 'Create a new custom object in Salesforce. IMPORTANT: Confirm with user - this is a significant schema change.',
        inputSchema: z.object({
          fullName: z.string().describe('API name for the object (e.g., Project)'),
          label: z.string().describe('Singular label (e.g., "Project")'),
          pluralLabel: z.string().describe('Plural label (e.g., "Projects")'),
          description: z.string().optional().describe('Object description'),
          nameFieldType: z.enum(['Text', 'AutoNumber']).optional().describe('Name field type (default: Text)'),
          nameFieldLabel: z.string().optional().describe('Name field label'),
          nameFieldFormat: z.string().optional().describe('For AutoNumber: format like "PRJ-{0000}"'),
          allowReports: z.boolean().optional().describe('Allow reports (default: true)'),
          allowActivities: z.boolean().optional().describe('Allow activities (default: true)'),
          allowSearch: z.boolean().optional().describe('Allow search (default: true)'),
          sharingModel: z.enum(['Private', 'Read', 'ReadWrite']).optional().describe('Sharing model (default: ReadWrite)'),
        }),
        execute: async (args) => self.executeTool('sf_create_custom_object', args, userId, dataSource),
      }),

      sf_create_validation_rule: tool({
        description: 'Create a validation rule. Formula returns TRUE when record is INVALID. IMPORTANT: Test formula logic carefully.',
        inputSchema: z.object({
          objectName: z.string().describe('The object API name'),
          name: z.string().describe('Rule API name (e.g., Require_Email_or_Phone)'),
          description: z.string().optional().describe('Description of the rule'),
          errorConditionFormula: z.string().describe('Formula returning TRUE when INVALID. Example: AND(ISBLANK(Email), ISBLANK(Phone))'),
          errorMessage: z.string().describe('Error message when validation fails'),
          errorDisplayField: z.string().optional().describe('Field to display error on'),
          active: z.boolean().optional().describe('Activate immediately (default: true)'),
        }),
        execute: async (args) => self.executeTool('sf_create_validation_rule', args, userId, dataSource),
      }),

      sf_add_picklist_values: tool({
        description: 'Add new values to an existing picklist field without replacing existing values',
        inputSchema: z.object({
          objectName: z.string().describe('The object API name'),
          fieldName: z.string().describe('The picklist field API name'),
          newValues: z.array(z.string()).describe('New picklist values to add'),
        }),
        execute: async (args) => self.executeTool('sf_add_picklist_values', args, userId, dataSource),
      }),

      sf_update_field_level_security: tool({
        description: 'Update field-level security for a profile (visibility and editability)',
        inputSchema: z.object({
          profileName: z.string().describe('Profile name (e.g., "Standard User")'),
          objectName: z.string().describe('The object API name'),
          fieldName: z.string().describe('The field API name'),
          readable: z.boolean().describe('Whether field should be visible'),
          editable: z.boolean().describe('Whether field should be editable'),
        }),
        execute: async (args) => self.executeTool('sf_update_field_level_security', args, userId, dataSource),
      }),

      sf_validate_metadata: tool({
        description: 'Validate metadata changes before deploying (dry run). Use to check for errors first.',
        inputSchema: z.object({
          metadataType: z.enum(['CustomField', 'CustomObject', 'ValidationRule']).describe('Type of metadata'),
          metadata: z.record(z.string(), z.any()).describe('The metadata definition to validate'),
        }),
        execute: async (args) => self.executeTool('sf_validate_metadata', args, userId, dataSource),
      }),

      // =============================================================================
      // EXTENDED ADMIN TOOLS - Users, Roles, Groups, Flows, Bulk Operations
      // =============================================================================

      sf_toggle_flow: tool({
        description: 'Activate or deactivate a Flow',
        inputSchema: z.object({
          flowId: z.string().describe('The Flow Definition ID'),
          activate: z.boolean().describe('True to activate, false to deactivate'),
        }),
        execute: async (args) => self.executeTool('sf_toggle_flow', args, userId, dataSource),
      }),

      sf_create_user: tool({
        description: 'Create a new user in Salesforce',
        inputSchema: z.object({
          username: z.string().describe('Unique username (email format)'),
          email: z.string().describe('Email address'),
          firstName: z.string().describe('First name'),
          lastName: z.string().describe('Last name'),
          alias: z.string().describe('Alias (max 8 chars)'),
          profileId: z.string().describe('Profile ID'),
          roleId: z.string().optional().describe('Role ID'),
          timeZone: z.string().optional().describe('Time zone'),
          isActive: z.boolean().optional().describe('Active status'),
        }),
        execute: async (args) => self.executeTool('sf_create_user', args, userId, dataSource),
      }),

      sf_update_user: tool({
        description: 'Update user details',
        inputSchema: z.object({
          targetUserId: z.string().describe('User ID to update'),
          email: z.string().optional().describe('New email'),
          firstName: z.string().optional().describe('New first name'),
          lastName: z.string().optional().describe('New last name'),
          profileId: z.string().optional().describe('New profile ID'),
          roleId: z.string().optional().describe('New role ID'),
          isActive: z.boolean().optional().describe('Activate/deactivate'),
          managerId: z.string().optional().describe('Manager user ID'),
          title: z.string().optional().describe('Job title'),
          department: z.string().optional().describe('Department'),
        }),
        execute: async (args) => self.executeTool('sf_update_user', args, userId, dataSource),
      }),

      sf_freeze_user: tool({
        description: 'Freeze/unfreeze a user (prevent login without deactivating)',
        inputSchema: z.object({
          targetUserId: z.string().describe('User ID'),
          freeze: z.boolean().describe('True to freeze'),
        }),
        execute: async (args) => self.executeTool('sf_freeze_user', args, userId, dataSource),
      }),

      sf_reset_user_password: tool({
        description: 'Reset user password (sends reset email)',
        inputSchema: z.object({
          targetUserId: z.string().describe('User ID'),
        }),
        execute: async (args) => self.executeTool('sf_reset_user_password', args, userId, dataSource),
      }),

      sf_create_record_type: tool({
        description: 'Create a record type for an object',
        inputSchema: z.object({
          objectName: z.string().describe('Object API name'),
          name: z.string().describe('Record type name'),
          developerName: z.string().describe('API name'),
          description: z.string().optional().describe('Description'),
          isActive: z.boolean().optional().describe('Active status'),
        }),
        execute: async (args) => self.executeTool('sf_create_record_type', args, userId, dataSource),
      }),

      sf_update_record_type: tool({
        description: 'Update a record type',
        inputSchema: z.object({
          recordTypeId: z.string().describe('Record Type ID'),
          name: z.string().optional().describe('New name'),
          description: z.string().optional().describe('New description'),
          isActive: z.boolean().optional().describe('Active status'),
        }),
        execute: async (args) => self.executeTool('sf_update_record_type', args, userId, dataSource),
      }),

      sf_create_permission_set: tool({
        description: 'Create a permission set',
        inputSchema: z.object({
          name: z.string().describe('API name'),
          label: z.string().describe('Display label'),
          description: z.string().optional().describe('Description'),
        }),
        execute: async (args) => self.executeTool('sf_create_permission_set', args, userId, dataSource),
      }),

      sf_add_object_permission_to_permset: tool({
        description: 'Add object permissions to a permission set',
        inputSchema: z.object({
          permissionSetId: z.string().describe('Permission Set ID'),
          objectName: z.string().describe('Object API name'),
          read: z.boolean().optional().describe('Read access'),
          create: z.boolean().optional().describe('Create access'),
          edit: z.boolean().optional().describe('Edit access'),
          delete: z.boolean().optional().describe('Delete access'),
          viewAll: z.boolean().optional().describe('View all records'),
          modifyAll: z.boolean().optional().describe('Modify all records'),
        }),
        execute: async (args) => self.executeTool('sf_add_object_permission_to_permset', args, userId, dataSource),
      }),

      sf_revoke_permission_set: tool({
        description: 'Remove permission set from user',
        inputSchema: z.object({
          assigneeId: z.string().describe('User ID'),
          permissionSetId: z.string().describe('Permission Set ID'),
        }),
        execute: async (args) => self.executeTool('sf_revoke_permission_set', args, userId, dataSource),
      }),

      sf_update_custom_field: tool({
        description: 'Update custom field properties',
        inputSchema: z.object({
          objectName: z.string().describe('Object API name'),
          fieldName: z.string().describe('Field API name'),
          label: z.string().optional().describe('New label'),
          description: z.string().optional().describe('New description'),
          helpText: z.string().optional().describe('New help text'),
          required: z.boolean().optional().describe('Required status'),
          defaultValue: z.string().optional().describe('Default value'),
        }),
        execute: async (args) => self.executeTool('sf_update_custom_field', args, userId, dataSource),
      }),

      sf_delete_custom_field: tool({
        description: 'Delete a custom field (WARNING: permanent)',
        inputSchema: z.object({
          objectName: z.string().describe('Object API name'),
          fieldName: z.string().describe('Field API name'),
        }),
        execute: async (args) => self.executeTool('sf_delete_custom_field', args, userId, dataSource),
      }),

      sf_delete_custom_object: tool({
        description: 'Delete a custom object (WARNING: permanent)',
        inputSchema: z.object({
          objectName: z.string().describe('Object API name'),
        }),
        execute: async (args) => self.executeTool('sf_delete_custom_object', args, userId, dataSource),
      }),

      sf_update_validation_rule: tool({
        description: 'Update a validation rule',
        inputSchema: z.object({
          validationRuleId: z.string().describe('Validation Rule ID'),
          description: z.string().optional().describe('New description'),
          errorConditionFormula: z.string().optional().describe('New formula'),
          errorMessage: z.string().optional().describe('New error message'),
          active: z.boolean().optional().describe('Active status'),
        }),
        execute: async (args) => self.executeTool('sf_update_validation_rule', args, userId, dataSource),
      }),

      sf_delete_validation_rule: tool({
        description: 'Delete a validation rule',
        inputSchema: z.object({
          validationRuleId: z.string().describe('Validation Rule ID'),
        }),
        execute: async (args) => self.executeTool('sf_delete_validation_rule', args, userId, dataSource),
      }),

      sf_list_roles: tool({
        description: 'List all roles in the org',
        inputSchema: z.object({}),
        execute: async () => self.executeTool('sf_list_roles', {}, userId, dataSource),
      }),

      sf_create_role: tool({
        description: 'Create a role in the hierarchy',
        inputSchema: z.object({
          name: z.string().describe('Role name'),
          developerName: z.string().describe('API name'),
          parentRoleId: z.string().optional().describe('Parent role ID'),
        }),
        execute: async (args) => self.executeTool('sf_create_role', args, userId, dataSource),
      }),

      sf_list_groups: tool({
        description: 'List public groups and queues',
        inputSchema: z.object({}),
        execute: async () => self.executeTool('sf_list_groups', {}, userId, dataSource),
      }),

      sf_create_group: tool({
        description: 'Create a public group',
        inputSchema: z.object({
          name: z.string().describe('Group name'),
          developerName: z.string().describe('API name'),
          type: z.enum(['Regular', 'Queue']).optional().describe('Group type'),
        }),
        execute: async (args) => self.executeTool('sf_create_group', args, userId, dataSource),
      }),

      sf_add_group_member: tool({
        description: 'Add member to a group',
        inputSchema: z.object({
          groupId: z.string().describe('Group ID'),
          memberId: z.string().describe('User or Group ID'),
        }),
        execute: async (args) => self.executeTool('sf_add_group_member', args, userId, dataSource),
      }),

      sf_create_queue: tool({
        description: 'Create a queue for case/lead routing',
        inputSchema: z.object({
          name: z.string().describe('Queue name'),
          developerName: z.string().describe('API name'),
          supportedObjects: z.array(z.string()).describe('Supported objects'),
          email: z.string().optional().describe('Queue email'),
        }),
        execute: async (args) => self.executeTool('sf_create_queue', args, userId, dataSource),
      }),

      sf_list_email_templates: tool({
        description: 'List email templates',
        inputSchema: z.object({
          folderId: z.string().optional().describe('Folder ID filter'),
        }),
        execute: async (args) => self.executeTool('sf_list_email_templates', args, userId, dataSource),
      }),

      sf_create_email_template: tool({
        description: 'Create an email template',
        inputSchema: z.object({
          name: z.string().describe('Template name'),
          developerName: z.string().describe('API name'),
          subject: z.string().describe('Email subject'),
          htmlBody: z.string().describe('HTML body'),
          textBody: z.string().optional().describe('Plain text body'),
          description: z.string().optional().describe('Description'),
        }),
        execute: async (args) => self.executeTool('sf_create_email_template', args, userId, dataSource),
      }),

      sf_get_schema_overview: tool({
        description: 'Get comprehensive schema overview for an object',
        inputSchema: z.object({
          objectName: z.string().describe('Object API name'),
        }),
        execute: async (args) => self.executeTool('sf_get_schema_overview', args, userId, dataSource),
      }),

      sf_get_picklist_values: tool({
        description: 'Get all picklist values for a field',
        inputSchema: z.object({
          objectName: z.string().describe('Object API name'),
          fieldName: z.string().describe('Field name'),
        }),
        execute: async (args) => self.executeTool('sf_get_picklist_values', args, userId, dataSource),
      }),

      sf_bulk_create: tool({
        description: 'Create multiple records at once (up to 200)',
        inputSchema: z.object({
          objectType: z.string().describe('Object API name'),
          records: z.array(z.record(z.string(), z.any())).describe('Array of records'),
          allOrNone: z.boolean().optional().describe('Fail all if any fail'),
        }),
        execute: async (args) => self.executeTool('sf_bulk_create', args, userId, dataSource),
      }),

      sf_bulk_update: tool({
        description: 'Update multiple records at once (up to 200)',
        inputSchema: z.object({
          objectType: z.string().describe('Object API name'),
          records: z.array(z.record(z.string(), z.any())).describe('Array of {id, ...fields}'),
          allOrNone: z.boolean().optional().describe('Fail all if any fail'),
        }),
        execute: async (args) => self.executeTool('sf_bulk_update', args, userId, dataSource),
      }),

      sf_bulk_delete: tool({
        description: 'Delete multiple records at once (up to 200)',
        inputSchema: z.object({
          recordIds: z.array(z.string()).describe('Record IDs to delete'),
          allOrNone: z.boolean().optional().describe('Fail all if any fail'),
        }),
        execute: async (args) => self.executeTool('sf_bulk_delete', args, userId, dataSource),
      }),

      sf_get_record_count: tool({
        description: 'Get record count for an object',
        inputSchema: z.object({
          objectName: z.string().describe('Object API name'),
          whereClause: z.string().optional().describe('WHERE clause'),
        }),
        execute: async (args) => self.executeTool('sf_get_record_count', args, userId, dataSource),
      }),

      sf_clone_record: tool({
        description: 'Clone an existing record',
        inputSchema: z.object({
          objectType: z.string().describe('Object API name'),
          recordId: z.string().describe('Record ID to clone'),
          fieldOverrides: z.record(z.string(), z.any()).optional().describe('Fields to override'),
          excludeFields: z.array(z.string()).optional().describe('Fields to exclude'),
        }),
        execute: async (args) => self.executeTool('sf_clone_record', args, userId, dataSource),
      }),

      sf_get_org_info: tool({
        description: 'Get org information and features',
        inputSchema: z.object({}),
        execute: async () => self.executeTool('sf_get_org_info', {}, userId, dataSource),
      }),

      // Web Research Tools - Available in all modes including Salesforce
      web_search: tool({
        description: 'Search the web for any information using Google Custom Search. Use this for general web searches, news, and current information.',
        inputSchema: z.object({
          query: z.string().describe('The search query to look up on the web'),
        }),
        execute: async (args) => self.executeTool('web_search', args, userId, dataSource),
      }),

      research_company: tool({
        description: 'Research a company by URL or name using WEB SEARCH. Gathers comprehensive information from the web including company overview, recent news, leadership team, financial data, stock info, earnings, revenue, and competitors. MUST USE this tool when user asks to: "research [company]", "analyze [company] financial performance", "[company] stock/revenue/earnings", or any company analysis beyond CRM data. CRM data does NOT contain financial information - this tool DOES.',
        inputSchema: z.object({
          companyUrlOrName: z.string().describe('Company website URL or company name'),
          includeNews: z.boolean().optional().describe('Include recent news (default: true)'),
          includeLeadership: z.boolean().optional().describe('Include leadership info (default: true)'),
          includeCompetitors: z.boolean().optional().describe('Include competitor analysis'),
          includeJobs: z.boolean().optional().describe('Include job postings'),
        }),
        execute: async (args) => self.executeTool('research_company', args, userId, dataSource),
      }),

      // =============================================================================
      // IRIS RANK TOOLS - AI-Powered Entity Ranking & Prioritization
      // =============================================================================

      iris_rank_entities: tool({
        description: 'Get AI-ranked entities based on network importance, activity signals, and query relevance. Use this when user asks "which leads should I focus on", "who should I contact first", "prioritize my accounts", or similar prioritization questions.',
        inputSchema: z.object({
          entityType: z.enum(['Lead', 'Contact', 'Account', 'Opportunity']).describe('Type of entity to rank'),
          query: z.string().optional().describe('Optional query to influence ranking (e.g., "high value", "needs follow up")'),
          limit: z.number().optional().describe('Number of results (default: 10)'),
        }),
        execute: async (args) => self.executeTool('iris_rank_entities', args, userId, dataSource),
      }),

      iris_get_at_risk: tool({
        description: 'Get entities that need attention - high-value relationships with declining engagement. Use when user asks "what deals are at risk", "which accounts need attention", "who am I losing touch with".',
        inputSchema: z.object({
          entityType: z.enum(['Lead', 'Contact', 'Account', 'Opportunity']).optional().describe('Filter by entity type'),
          limit: z.number().optional().describe('Number of results (default: 5)'),
        }),
        execute: async (args) => self.executeTool('iris_get_at_risk', args, userId, dataSource),
      }),

      iris_get_momentum: tool({
        description: 'Get entities with positive momentum - strong recent engagement signals. Use when user asks "which leads are hot", "who is engaging", "what opportunities are progressing".',
        inputSchema: z.object({
          entityType: z.enum(['Lead', 'Contact', 'Account', 'Opportunity']).optional().describe('Filter by entity type'),
          limit: z.number().optional().describe('Number of results (default: 5)'),
        }),
        execute: async (args) => self.executeTool('iris_get_momentum', args, userId, dataSource),
      }),

      iris_explain_rank: tool({
        description: 'Get detailed explanation of why an entity has its current rank. Shows network score, activity score, and key signals.',
        inputSchema: z.object({
          entityId: z.string().describe('Salesforce record ID'),
          entityType: z.enum(['Lead', 'Contact', 'Account', 'Opportunity']).describe('Type of entity'),
        }),
        execute: async (args) => self.executeTool('iris_explain_rank', args, userId, dataSource),
      }),

      // =============================================================================
      // HOT OPPORTUNITIES - High-value pipeline deals in active stages
      // =============================================================================

      get_hot_opportunities: tool({
        description: 'Get HOT OPPORTUNITIES in the pipeline - high-value deals (>$50K) in active sales stages like Prospecting, Qualification, Proposal, Negotiation. ALWAYS use this when user asks about "hot opportunities", "hot deals", "pipeline opportunities to focus on", "show me hot opportunities", "opportunities to focus on".',
        inputSchema: z.object({
          minAmount: z.number().optional().describe('Minimum deal amount (default: 50000)'),
          limit: z.number().optional().describe('Number of opportunities to return (default: 10)'),
        }),
        execute: async (args) => self.executeTool('get_hot_opportunities', args, userId, dataSource),
      }),

      // =============================================================================
      // ACCOUNT SIGNALS - AI-detected buying signals and intelligence
      // =============================================================================

      get_account_signals: tool({
        description: 'Get AI-detected account signals including executive changes, funding events, expansion signals, technology changes, and news. ALWAYS use this when user asks about "signals", "account signals", "buying signals", "what signals do I have", "intelligence for my accounts", or "show me account intelligence".',
        inputSchema: z.object({
          accountId: z.string().optional().describe('Filter by specific account ID'),
          status: z.enum(['PENDING', 'ACKNOWLEDGED', 'ACTIONED', 'DISMISSED']).optional().describe('Filter by signal status'),
          priority: z.enum(['LOW', 'MEDIUM', 'HIGH', 'CRITICAL']).optional().describe('Filter by priority'),
          signalTypes: z.array(z.enum(['EXEC_CHANGE', 'FUNDING', 'EXPANSION', 'TECH_CHANGE', 'NEWS', 'USAGE_SPIKE'])).optional().describe('Filter by signal types'),
          timeframe: z.enum(['24h', '7d', '30d', '90d']).optional().describe('Filter by timeframe'),
          limit: z.number().optional().describe('Maximum number of signals to return (default: 20)'),
        }),
        execute: async (args) => self.executeTool('get_account_signals', args, userId, dataSource),
      }),

      // =============================================================================
      // EMAIL TOOLS - Available in Salesforce mode for communication
      // =============================================================================

      send_email: tool({
        description: 'Send an email to one or more recipients. Use for follow-ups, meeting agendas, proposals, and general communication.',
        inputSchema: z.object({
          to: z.array(z.string()).describe('Email addresses of recipients'),
          subject: z.string().describe('Email subject line'),
          body: z.string().describe('Email body content (can include HTML formatting)'),
          isHtml: z.boolean().optional().describe('Whether the body is HTML formatted (default: true)'),
        }),
        execute: async (args) => self.executeTool('send_email', args, userId),
      }),

      get_email_threads: tool({
        description: 'Get all email threads/conversations for the current user. Shows email history and status.',
        inputSchema: z.object({
          status: z.enum(['AWAITING_RESPONSE', 'RESPONDED', 'CLOSED', 'FOLLOW_UP_NEEDED']).optional().describe('Filter by thread status'),
          limit: z.number().optional().describe('Maximum number of threads to return (default: 20)'),
        }),
        execute: async (args) => self.executeTool('get_email_threads', args, userId),
      }),

      get_awaiting_responses: tool({
        description: 'Get all email threads waiting for a response. Use this to find emails that need follow-up or are overdue.',
        inputSchema: z.object({}),
        execute: async () => self.executeTool('get_awaiting_responses', {}, userId),
      }),

      get_thread_messages: tool({
        description: 'Get the full email messages/content from a specific email thread. Use this to read the actual email body text of messages including replies. This allows viewing the complete email trail.',
        inputSchema: z.object({
          threadId: z.string().describe('The ID of the email thread to get messages from'),
        }),
        execute: async (args) => self.executeTool('get_thread_messages', args, userId),
      }),

      get_email_drafts: tool({
        description: 'Get all AI-generated email drafts ready for review and sending. Optionally filter by thread ID.',
        inputSchema: z.object({
          threadId: z.string().optional().describe('Optional thread ID to filter drafts for a specific email thread'),
        }),
        execute: async (args) => self.executeTool('get_email_drafts', args, userId),
      }),

      send_email_draft: tool({
        description: 'Send a previously generated email draft after reviewing it.',
        inputSchema: z.object({
          draftId: z.string().describe('The ID of the draft to send'),
        }),
        execute: async (args) => self.executeTool('send_email_draft', args, userId),
      }),

      // =============================================================================
      // MEETING SCHEDULING & MANAGEMENT TOOLS - Zoom, Teams, Google Meet
      // =============================================================================

      schedule_meeting: tool({
        description: 'Schedule a video meeting on Zoom, Microsoft Teams, or Google Meet. Creates a meeting with the specified platform and optionally sends invites to attendees.',
        inputSchema: z.object({
          title: z.string().optional().describe('Meeting title/subject'),
          scheduledStart: z.string().describe('Meeting start time in ISO 8601 format (e.g., 2026-01-03T14:30:00+05:30)'),
          duration: z.number().optional().describe('Meeting duration in minutes (default: 60)'),
          platform: z.enum(['ZOOM', 'TEAMS', 'GOOGLE_MEET']).describe('Video conferencing platform'),
          attendeeEmails: z.array(z.string()).optional().describe('Email addresses of attendees to invite'),
          description: z.string().optional().describe('Meeting description/agenda'),
          leadId: z.string().optional().describe('ID of the lead this meeting is about'),
          accountId: z.string().optional().describe('ID of the account this meeting is about'),
          opportunityId: z.string().optional().describe('ID of the opportunity this meeting is about'),
        }),
        execute: async (args) => self.executeTool('schedule_meeting', args, userId),
      }),

      list_meetings: tool({
        description: 'List all IRIS meeting sessions. ALWAYS call this tool FIRST when user mentions a meeting by person name (e.g., "meeting with David", "delete my meeting") to find the meeting ID needed for cancel_meeting and other meeting operations.',
        inputSchema: z.object({
          status: z.string().optional().describe('Filter by meeting status (SCHEDULED, IN_PROGRESS, COMPLETED, CANCELLED)'),
          limit: z.number().optional().describe('Maximum number of meetings to return (default: 10)'),
        }),
        execute: async (args) => self.executeTool('list_meetings', args, userId),
      }),

      // MEETING INTELLIGENCE TOOLS - Transcript & Analysis
      get_meeting: tool({
        description: 'Get details of a specific meeting session including status, recording, transcript availability, and analysis.',
        inputSchema: z.object({
          meetingId: z.string().describe('ID of the meeting session to retrieve'),
        }),
        execute: async (args) => self.executeTool('get_meeting', args, userId),
      }),

      get_meeting_transcript: tool({
        description: 'Get the full transcript of a completed meeting, including speaker attribution and timestamps. Use when user asks "show transcript", "what was said".',
        inputSchema: z.object({
          meetingId: z.string().describe('ID of the meeting session to get transcript for'),
          format: z.enum(['text', 'segments']).optional().describe('Output format: "text" or "segments" (default: segments)'),
        }),
        execute: async (args) => self.executeTool('get_meeting_transcript', args, userId),
      }),

      get_meeting_analysis: tool({
        description: 'Get AI-generated analysis of a completed meeting including summary, key points, action items, decisions, and sales insights. Use when user asks "summarize meeting", "show analysis".',
        inputSchema: z.object({
          meetingId: z.string().describe('ID of the meeting session to get analysis for'),
        }),
        execute: async (args) => self.executeTool('get_meeting_analysis', args, userId),
      }),

      get_meeting_insights: tool({
        description: 'Get actionable sales insights from a meeting including buying signals, objections, competitor mentions, and deal risk.',
        inputSchema: z.object({
          meetingId: z.string().describe('ID of the meeting session'),
        }),
        execute: async (args) => self.executeTool('get_meeting_insights', args, userId),
      }),

      search_meeting_transcripts: tool({
        description: 'Search across all meeting transcripts for specific topics, keywords, or phrases.',
        inputSchema: z.object({
          query: z.string().describe('Search query - keywords or phrases to find'),
          limit: z.number().optional().describe('Maximum results (default: 10)'),
        }),
        execute: async (args) => self.executeTool('search_meeting_transcripts', args, userId),
      }),

      cancel_meeting: tool({
        description: 'Cancel/delete a scheduled meeting and send cancellation emails to all participants. Use this when user says "cancel meeting", "delete meeting", "remove meeting". First use list_meetings to find the meeting ID if user refers to meeting by person name.',
        inputSchema: z.object({
          meetingId: z.string().describe('ID of the meeting to cancel (get from list_meetings first)'),
          reason: z.string().optional().describe('Reason for cancellation'),
          sendNotification: z.boolean().optional().describe('Send cancellation email to participants (default: true)'),
        }),
        execute: async (args) => self.executeTool('cancel_meeting', args, userId),
      }),

      update_meeting: tool({
        description: 'Update/reschedule an existing meeting. Use this when user says "reschedule meeting", "change meeting time", "update meeting", or similar. Can update title, time, duration, or description. Sends update notifications to participants.',
        inputSchema: z.object({
          meetingId: z.string().describe('ID of the meeting to update (get from list_meetings first)'),
          title: z.string().optional().describe('New title for the meeting'),
          scheduledStart: z.string().optional().describe('New start time (ISO 8601 datetime)'),
          duration: z.number().optional().describe('New duration in minutes'),
          description: z.string().optional().describe('New description or agenda'),
          sendNotification: z.boolean().optional().describe('Send update notification to participants (default: true)'),
        }),
        execute: async (args) => self.executeTool('update_meeting', args, userId),
      }),

      get_meeting_rsvp_status: tool({
        description: 'Get the RSVP status summary for a meeting including who has accepted, declined, or not yet responded',
        inputSchema: z.object({
          meetingId: z.string().describe('ID of the meeting to check RSVP status for'),
        }),
        execute: async (args) => self.executeTool('get_meeting_rsvp_status', args, userId),
      }),

      // =============================================================================
      // PAGE LAYOUT TOOLS - Create, update, and manage page layouts
      // =============================================================================

      sf_list_page_layouts: tool({
        description: 'List all page layouts for a Salesforce object.',
        inputSchema: z.object({
          objectName: z.string().describe('The object API name (e.g., Account, Lead, Opportunity)'),
        }),
        execute: async (args) => self.executeTool('sf_list_page_layouts', args, userId, dataSource),
      }),

      sf_get_page_layout: tool({
        description: 'Get details of a specific page layout including sections and fields.',
        inputSchema: z.object({
          layoutId: z.string().describe('The page layout ID'),
        }),
        execute: async (args) => self.executeTool('sf_get_page_layout', args, userId, dataSource),
      }),

      sf_create_page_layout: tool({
        description: 'Create a new page layout for an object with sections and fields.',
        inputSchema: z.object({
          objectName: z.string().describe('The object API name'),
          name: z.string().describe('Name for the new layout'),
          sections: z.array(z.object({
            label: z.string(),
            columns: z.number().optional(),
            fields: z.array(z.string()),
          })).describe('Layout sections with fields'),
        }),
        execute: async (args) => self.executeTool('sf_create_page_layout', args, userId, dataSource),
      }),

      sf_update_page_layout: tool({
        description: 'Update an existing page layout - add/remove fields or reorganize sections.',
        inputSchema: z.object({
          layoutId: z.string().describe('The page layout ID to update'),
          addFields: z.object({
            sectionLabel: z.string(),
            fields: z.array(z.string()),
          }).optional().describe('Fields to add to a section'),
          removeFields: z.array(z.string()).optional().describe('Fields to remove from layout'),
        }),
        execute: async (args) => self.executeTool('sf_update_page_layout', args, userId, dataSource),
      }),

      sf_assign_page_layout: tool({
        description: 'Assign a page layout to a profile for a specific record type.',
        inputSchema: z.object({
          layoutId: z.string().describe('The page layout ID'),
          profileId: z.string().describe('The profile ID'),
          recordTypeId: z.string().optional().describe('Optional record type ID'),
        }),
        execute: async (args) => self.executeTool('sf_assign_page_layout', args, userId, dataSource),
      }),

      // =============================================================================
      // APEX DEPLOYMENT TOOLS - Deploy and manage Apex classes and triggers
      // =============================================================================

      sf_deploy_apex_class: tool({
        description: 'Deploy an Apex class to Salesforce. Creates new or updates existing class. IMPORTANT: Test in sandbox first.',
        inputSchema: z.object({
          name: z.string().describe('The Apex class name (no spaces, alphanumeric + underscore)'),
          body: z.string().describe('The full Apex class code including class declaration'),
          apiVersion: z.number().optional().describe('API version (default: 59.0)'),
        }),
        execute: async (args) => self.executeTool('sf_deploy_apex_class', args, userId, dataSource),
      }),

      sf_deploy_apex_trigger: tool({
        description: 'Deploy an Apex trigger to Salesforce.',
        inputSchema: z.object({
          name: z.string().describe('The trigger name'),
          body: z.string().describe('The full trigger code'),
          objectName: z.string().describe('The object the trigger fires on (e.g., Account, Lead)'),
          apiVersion: z.number().optional().describe('API version (default: 59.0)'),
        }),
        execute: async (args) => self.executeTool('sf_deploy_apex_trigger', args, userId, dataSource),
      }),

      sf_delete_apex_class: tool({
        description: 'Delete an Apex class from Salesforce. WARNING: This is permanent.',
        inputSchema: z.object({
          classId: z.string().describe('The Apex class ID to delete'),
        }),
        execute: async (args) => self.executeTool('sf_delete_apex_class', args, userId, dataSource),
      }),

      // =============================================================================
      // LIGHTNING WEB COMPONENT TOOLS - Deploy and manage LWC components
      // =============================================================================

      sf_deploy_lwc: tool({
        description: 'Deploy a Lightning Web Component to Salesforce.',
        inputSchema: z.object({
          name: z.string().describe('Component name (camelCase, e.g., myComponent)'),
          jsContent: z.string().describe('JavaScript file content'),
          htmlContent: z.string().optional().describe('HTML template content'),
          cssContent: z.string().optional().describe('CSS styles content'),
          metaXml: z.string().describe('Meta XML configuration (defines where component can be used)'),
          apiVersion: z.number().optional().describe('API version (default: 59.0)'),
        }),
        execute: async (args) => self.executeTool('sf_deploy_lwc', args, userId, dataSource),
      }),

      sf_list_lwc: tool({
        description: 'List all Lightning Web Components in the org.',
        inputSchema: z.object({}),
        execute: async () => self.executeTool('sf_list_lwc', {}, userId, dataSource),
      }),

      sf_delete_lwc: tool({
        description: 'Delete a Lightning Web Component. WARNING: This is permanent.',
        inputSchema: z.object({
          bundleId: z.string().describe('The LWC bundle ID to delete'),
        }),
        execute: async (args) => self.executeTool('sf_delete_lwc', args, userId, dataSource),
      }),

      // =============================================================================
      // WORKFLOW RULES TOOLS - Create and manage workflow automation
      // =============================================================================

      sf_list_workflow_rules: tool({
        description: 'List workflow rules for a Salesforce object.',
        inputSchema: z.object({
          objectName: z.string().describe('The object API name'),
        }),
        execute: async (args) => self.executeTool('sf_list_workflow_rules', args, userId, dataSource),
      }),

      sf_create_workflow_rule: tool({
        description: 'Create a workflow rule with optional field updates and email alerts.',
        inputSchema: z.object({
          objectName: z.string().describe('The object API name'),
          name: z.string().describe('Rule name'),
          description: z.string().optional().describe('Rule description'),
          triggerType: z.enum(['onAllChanges', 'onCreateOnly', 'onCreateOrTriggeringUpdate']).describe('When to trigger'),
          formula: z.string().describe('Filter criteria formula (e.g., Status = "New")'),
          active: z.boolean().optional().describe('Activate immediately (default: true)'),
          actions: z.object({
            fieldUpdates: z.array(z.object({
              name: z.string(),
              field: z.string(),
              value: z.string(),
            })).optional(),
            emailAlerts: z.array(z.object({
              name: z.string(),
              templateId: z.string(),
              recipients: z.array(z.string()),
            })).optional(),
          }).optional().describe('Actions to execute'),
        }),
        execute: async (args) => self.executeTool('sf_create_workflow_rule', args, userId, dataSource),
      }),

      sf_delete_workflow_rule: tool({
        description: 'Delete a workflow rule.',
        inputSchema: z.object({
          ruleId: z.string().describe('The workflow rule ID'),
        }),
        execute: async (args) => self.executeTool('sf_delete_workflow_rule', args, userId, dataSource),
      }),

      // =============================================================================
      // APPROVAL PROCESS TOOLS - Manage approval workflows
      // =============================================================================

      sf_list_approval_processes: tool({
        description: 'List approval processes for a Salesforce object.',
        inputSchema: z.object({
          objectName: z.string().describe('The object API name'),
        }),
        execute: async (args) => self.executeTool('sf_list_approval_processes', args, userId, dataSource),
      }),

      sf_create_approval_process: tool({
        description: 'Create an approval process with steps and criteria.',
        inputSchema: z.object({
          objectName: z.string().describe('The object API name'),
          name: z.string().describe('Process name'),
          description: z.string().optional().describe('Process description'),
          entryCriteria: z.string().describe('Formula for when records can be submitted'),
          approverType: z.enum(['user', 'queue', 'manager', 'related']).describe('Who approves'),
          approverId: z.string().optional().describe('User/queue ID if approverType is user/queue'),
          approverField: z.string().optional().describe('Field containing approver if related'),
          allowRecall: z.boolean().optional().describe('Allow submitter to recall (default: true)'),
          finalApprovalActions: z.array(z.object({
            type: z.enum(['fieldUpdate', 'emailAlert']),
            fieldName: z.string().optional(),
            fieldValue: z.string().optional(),
            templateId: z.string().optional(),
          })).optional().describe('Actions on final approval'),
          finalRejectionActions: z.array(z.object({
            type: z.enum(['fieldUpdate', 'emailAlert']),
            fieldName: z.string().optional(),
            fieldValue: z.string().optional(),
            templateId: z.string().optional(),
          })).optional().describe('Actions on final rejection'),
        }),
        execute: async (args) => self.executeTool('sf_create_approval_process', args, userId, dataSource),
      }),

      sf_toggle_approval_process: tool({
        description: 'Activate or deactivate an approval process.',
        inputSchema: z.object({
          processId: z.string().describe('The approval process ID'),
          active: z.boolean().describe('True to activate, false to deactivate'),
        }),
        execute: async (args) => self.executeTool('sf_toggle_approval_process', args, userId, dataSource),
      }),

      sf_delete_approval_process: tool({
        description: 'Delete an approval process.',
        inputSchema: z.object({
          processId: z.string().describe('The approval process ID'),
        }),
        execute: async (args) => self.executeTool('sf_delete_approval_process', args, userId, dataSource),
      }),

      sf_submit_for_approval: tool({
        description: 'Submit a record for approval.',
        inputSchema: z.object({
          recordId: z.string().describe('The record ID to submit'),
          comments: z.string().optional().describe('Submission comments'),
          processId: z.string().optional().describe('Specific approval process ID'),
        }),
        execute: async (args) => self.executeTool('sf_submit_for_approval', args, userId, dataSource),
      }),

      sf_process_approval: tool({
        description: 'Approve or reject a pending approval request.',
        inputSchema: z.object({
          workItemId: z.string().describe('The approval work item ID'),
          action: z.enum(['Approve', 'Reject']).describe('Action to take'),
          comments: z.string().optional().describe('Approver comments'),
        }),
        execute: async (args) => self.executeTool('sf_process_approval', args, userId, dataSource),
      }),

      // =============================================================================
      // REPORTS & DASHBOARDS TOOLS - Analytics and reporting
      // =============================================================================

      sf_list_reports: tool({
        description: 'List reports, optionally filtered by folder.',
        inputSchema: z.object({
          folderId: z.string().optional().describe('Folder ID to filter by'),
          limit: z.number().optional().describe('Maximum reports to return (default: 100)'),
        }),
        execute: async (args) => self.executeTool('sf_list_reports', args, userId, dataSource),
      }),

      sf_get_report_metadata: tool({
        description: 'Get detailed metadata for a report including columns, filters, and groupings.',
        inputSchema: z.object({
          reportId: z.string().describe('The report ID'),
        }),
        execute: async (args) => self.executeTool('sf_get_report_metadata', args, userId, dataSource),
      }),

      sf_create_report: tool({
        description: 'Create and SAVE a new persistent report IN SALESFORCE. Use this when user says "create a Salesforce report", "create a report in Salesforce", "save this as a Salesforce report", or "build me a SF report". This creates a saved report object in the Salesforce org that users can access from the Reports tab. Do NOT use sf_query for this - use this tool to create a persistent report.',
        inputSchema: z.object({
          name: z.string().describe('Report name - descriptive title for the report'),
          reportType: z.string().describe('Salesforce report type API name: AccountList, LeadList, OpportunityList, ContactList, or use sf_get_report_types to find others'),
          format: z.enum(['TABULAR', 'SUMMARY', 'MATRIX']).describe('Report format'),
          folderId: z.string().optional().describe('Folder to save in (default: private)'),
          columns: z.array(z.string()).describe('Field API names to include as columns'),
          filters: z.array(z.object({
            column: z.string(),
            operator: z.string(),
            value: z.string(),
          })).optional().describe('Report filters'),
          groupings: z.array(z.object({
            column: z.string(),
            sortOrder: z.enum(['Asc', 'Desc']).optional(),
            dateGranularity: z.enum(['Day', 'Week', 'Month', 'Quarter', 'Year']).optional(),
          })).optional().describe('Groupings for summary/matrix reports'),
        }),
        execute: async (args) => self.executeTool('sf_create_report', args, userId, dataSource),
      }),

      sf_run_report: tool({
        description: 'Execute a report and get results.',
        inputSchema: z.object({
          reportId: z.string().describe('The report ID'),
          includeDetails: z.boolean().optional().describe('Include row-level details (default: true)'),
        }),
        execute: async (args) => self.executeTool('sf_run_report', args, userId, dataSource),
      }),

      sf_update_report: tool({
        description: 'Update an existing report.',
        inputSchema: z.object({
          reportId: z.string().describe('The report ID'),
          name: z.string().optional().describe('New name'),
          columns: z.array(z.string()).optional().describe('New columns'),
          filters: z.array(z.object({
            column: z.string(),
            operator: z.string(),
            value: z.string(),
          })).optional().describe('New filters'),
        }),
        execute: async (args) => self.executeTool('sf_update_report', args, userId, dataSource),
      }),

      sf_delete_report: tool({
        description: 'Delete a report.',
        inputSchema: z.object({
          reportId: z.string().describe('The report ID to delete'),
        }),
        execute: async (args) => self.executeTool('sf_delete_report', args, userId, dataSource),
      }),

      sf_list_report_folders: tool({
        description: 'List report folders.',
        inputSchema: z.object({}),
        execute: async () => self.executeTool('sf_list_report_folders', {}, userId, dataSource),
      }),

      sf_get_report_types: tool({
        description: 'List available report types.',
        inputSchema: z.object({}),
        execute: async () => self.executeTool('sf_get_report_types', {}, userId, dataSource),
      }),

      sf_list_dashboards: tool({
        description: 'List dashboards, optionally filtered by folder.',
        inputSchema: z.object({
          folderId: z.string().optional().describe('Folder ID to filter by'),
          limit: z.number().optional().describe('Maximum dashboards to return (default: 100)'),
        }),
        execute: async (args) => self.executeTool('sf_list_dashboards', args, userId, dataSource),
      }),

      sf_get_dashboard_metadata: tool({
        description: 'Get detailed metadata for a dashboard including components.',
        inputSchema: z.object({
          dashboardId: z.string().describe('The dashboard ID'),
        }),
        execute: async (args) => self.executeTool('sf_get_dashboard_metadata', args, userId, dataSource),
      }),

      sf_create_dashboard: tool({
        description: 'Create a new dashboard with components.',
        inputSchema: z.object({
          name: z.string().describe('Dashboard name'),
          folderId: z.string().optional().describe('Folder to save in'),
          description: z.string().optional().describe('Dashboard description'),
          components: z.array(z.object({
            reportId: z.string(),
            componentType: z.enum(['Chart', 'Table', 'Metric', 'Gauge']),
            header: z.string().optional(),
            chartType: z.enum(['Bar', 'Column', 'Line', 'Pie', 'Donut', 'Funnel']).optional(),
          })).describe('Dashboard components'),
        }),
        execute: async (args) => self.executeTool('sf_create_dashboard', args, userId, dataSource),
      }),

      sf_refresh_dashboard: tool({
        description: 'Refresh dashboard data.',
        inputSchema: z.object({
          dashboardId: z.string().describe('The dashboard ID'),
        }),
        execute: async (args) => self.executeTool('sf_refresh_dashboard', args, userId, dataSource),
      }),

      sf_delete_dashboard: tool({
        description: 'Delete a dashboard.',
        inputSchema: z.object({
          dashboardId: z.string().describe('The dashboard ID to delete'),
        }),
        execute: async (args) => self.executeTool('sf_delete_dashboard', args, userId, dataSource),
      }),

      sf_list_dashboard_folders: tool({
        description: 'List dashboard folders.',
        inputSchema: z.object({}),
        execute: async () => self.executeTool('sf_list_dashboard_folders', {}, userId, dataSource),
      }),

      // =============================================================================
      // CRM TOOLS - Lead management with Salesforce support
      // =============================================================================

      search_leads: tool({
        description: 'Search for leads in Salesforce based on criteria like status, score, rating, company name, or lead name. IMPORTANT: If user specifies a number (e.g., "show 3 leads", "5 hot leads"), extract that number and pass it as the limit parameter.',
        inputSchema: z.object({
          name: z.string().optional().describe('Search by lead\'s first name, last name, or full name (e.g., "David Lee", "Sarah")'),
          status: z.string().optional().describe('Lead status (NEW, CONTACTED, QUALIFIED, CONVERTED, etc.)'),
          rating: z.string().optional().describe('Lead rating (HOT, WARM, COLD)'),
          minScore: z.number().optional().describe('Minimum lead score (0-100)'),
          company: z.string().optional().describe('Company name to search for'),
          limit: z.number().optional().describe('Maximum results - MUST be extracted from user query if specified (e.g., "show 3" â†’ limit: 3). Default: 10'),
        }),
        execute: async (args) => self.executeTool('search_leads', args, userId, dataSource),
      }),

      get_lead_details: tool({
        description: 'Get detailed information about a specific lead by ID, including all recent interactions, tasks, events, and activities. Use this tool when the user wants to view lead details, see recent interactions, or check activity history.',
        inputSchema: z.object({
          leadId: z.string().describe('The Salesforce Lead ID to retrieve'),
        }),
        execute: async (args) => self.executeTool('get_lead_details', args, userId, dataSource),
      }),
    };
  }

  /**
   * PERFORMANCE: Minimal Salesforce tools for simple queries (search/show/list)
   * Only includes 5 essential tools vs 70+ in full set
   * This dramatically reduces time-to-first-token by reducing prompt size
   */
  private createMinimalSalesforceTools(userId: string) {
    const self = this;
    // Explicitly set dataSource to 'salesforce' for all tools in this method
    const dataSource: 'salesforce' | 'local' = 'salesforce';

    return {
      sf_query: tool({
        description: `Execute a SOQL query against Salesforce. IMPORTANT: (1) ALWAYS include the Name field (or FirstName/LastName for Leads/Contacts) so users can identify records. (2) When ordering by numeric fields like Amount, use NULLS LAST to push empty values to the end. Example: SELECT Id, Name, Amount, StageName FROM Opportunity ORDER BY Amount DESC NULLS LAST LIMIT 5`,
        inputSchema: z.object({
          query: z.string().describe('The SOQL query - MUST include Name field and use NULLS LAST for numeric ordering'),
        }),
        execute: async (args) => self.executeTool('sf_query', args, userId, dataSource),
      }),

      sf_search: tool({
        description: 'Search across multiple Salesforce objects using SOSL. Use this for cross-object text searches.',
        inputSchema: z.object({
          searchTerm: z.string().describe('The text to search for'),
          objects: z.array(z.string()).optional().describe('Array of object names to search in (e.g., ["Lead", "Contact", "Account"])'),
          limit: z.number().optional().describe('Maximum records per object (default: 20)'),
        }),
        execute: async (args) => self.executeTool('sf_search', args, userId, dataSource),
      }),

      sf_create_lead: tool({
        description: 'Create a new Lead record in Salesforce',
        inputSchema: z.object({
          FirstName: z.string().optional().describe('Lead first name'),
          LastName: z.string().describe('Lead last name (required)'),
          Company: z.string().describe('Company name (required)'),
          Email: z.string().optional().describe('Email address'),
          Phone: z.string().optional().describe('Phone number'),
          Title: z.string().optional().describe('Job title'),
          Industry: z.string().optional().describe('Industry'),
          LeadSource: z.string().optional().describe('Lead source'),
          Status: z.string().optional().describe('Lead status'),
          Description: z.string().optional().describe('Description or notes'),
        }),
        execute: async (args) => self.executeTool('sf_create_lead', args, userId, dataSource),
      }),

      sf_create_task: tool({
        description: 'Create a new Task in Salesforce for follow-ups',
        inputSchema: z.object({
          Subject: z.string().describe('Task subject (required)'),
          WhoId: z.string().optional().describe('Related Contact or Lead ID'),
          WhatId: z.string().optional().describe('Related Account or Opportunity ID'),
          ActivityDate: z.string().optional().describe('Due date (YYYY-MM-DD)'),
          Status: z.string().optional().describe('Task status'),
          Priority: z.string().optional().describe('Priority (High, Normal, Low)'),
          Description: z.string().optional().describe('Task description'),
        }),
        execute: async (args) => self.executeTool('sf_create_task', args, userId, dataSource),
      }),

      // =============================================================================
      // TASK COMPLETION & UPDATE - Works with both IRIS and Salesforce tasks
      // =============================================================================

      complete_task: tool({
        description: 'Mark a task as completed. Works for both Salesforce tasks (IDs starting with "00T") and local IRIS tasks (IDs starting with "cm"). Use this when user wants to mark a task done, finish a task, or complete a follow-up.',
        inputSchema: z.object({
          taskId: z.string().describe('The task ID to complete (Salesforce "00T..." or IRIS "cm...")'),
          completionNotes: z.string().optional().describe('Optional notes about what was done to complete the task'),
        }),
        execute: async (args) => self.executeTool('complete_task', args, userId, dataSource),
      }),

      update_task: tool({
        description: 'Update a task status, priority, due date, or other fields. Works for both Salesforce tasks (IDs starting with "00T") and local IRIS tasks (IDs starting with "cm").',
        inputSchema: z.object({
          taskId: z.string().describe('The task ID to update'),
          status: z.string().optional().describe('New status (e.g., "Not Started", "In Progress", "Completed")'),
          priority: z.string().optional().describe('New priority (High, Normal, Low)'),
          dueDate: z.string().optional().describe('New due date (YYYY-MM-DD format)'),
          subject: z.string().optional().describe('Updated subject/title'),
          description: z.string().optional().describe('Updated description'),
        }),
        execute: async (args) => self.executeTool('update_task', args, userId, dataSource),
      }),

      // Local IRIS task tools - for tasks created in IRIS (not Salesforce)
      get_iris_task: tool({
        description: 'Get a local IRIS task by ID. IMPORTANT: Use this tool when the task ID starts with "cm" (e.g., cmk1k2m4q...) - these are local IRIS CUID format IDs, NOT Salesforce IDs. Salesforce task IDs start with "00T" prefix. If a user asks about a task with ID starting with "cm", ALWAYS use this tool instead of sf_get_record.',
        inputSchema: z.object({
          taskId: z.string().describe('The IRIS task ID (starts with "cm...")'),
        }),
        execute: async (args) => self.executeTool('get_iris_task', args, userId),
      }),

      list_iris_tasks: tool({
        description: 'List local IRIS tasks. Use this to see tasks created in IRIS (not Salesforce). Useful for checking overdue tasks, pending tasks, etc. Task IDs from this tool start with "cm" (CUID format).',
        inputSchema: z.object({
          status: z.enum(['NOT_STARTED', 'IN_PROGRESS', 'COMPLETED', 'DEFERRED']).optional().describe('Filter by task status'),
          limit: z.number().optional().describe('Maximum number of tasks to return (default: 20)'),
        }),
        execute: async (args) => self.executeTool('list_iris_tasks', args, userId),
      }),

      research_company: tool({
        description: 'Research a company by URL or name using WEB SEARCH. Gathers comprehensive information from the web including company overview, recent news, leadership team, financial data, stock info, earnings, revenue, and competitors. MUST USE this tool when user asks to: "research [company]", "analyze [company] financial performance", "[company] stock/revenue/earnings", or any company analysis beyond CRM data. CRM data does NOT contain financial information - this tool DOES.',
        inputSchema: z.object({
          companyUrlOrName: z.string().describe('Company website URL or company name'),
          includeNews: z.boolean().optional().describe('Include recent news'),
          includeLeadership: z.boolean().optional().describe('Include leadership info'),
          includeCompetitors: z.boolean().optional().describe('Include competitor analysis'),
        }),
        execute: async (args) => self.executeTool('research_company', args, userId, dataSource),
      }),

      // ==================== AI INSIGHTS & COACHING TOOLS (MVP #1 & #2) ====================
      get_my_ai_insights: tool({
        description: `Get AI-generated insights and recommendations for the current user. ALWAYS use this tool when user asks: "What should I focus on today?", "Give me coaching tips", "What are my AI insights?", "What deals need attention?", "Any recommendations for me?"`,
        inputSchema: z.object({
          agentType: z.enum(['DEAL_HEALTH', 'COACHING', 'ACCOUNT_INTELLIGENCE', 'PIPELINE_ACCELERATION', 'NEXT_BEST_ACTION']).optional().describe('Filter by agent type'),
          priority: z.enum(['URGENT', 'HIGH', 'MEDIUM', 'LOW']).optional().describe('Filter by priority level'),
          limit: z.number().optional().describe('Maximum number of insights to return (default: 10)'),
        }),
        execute: async (args) => self.executeTool('get_my_ai_insights', args, userId),
      }),

      get_sales_coaching: tool({
        description: `Get personalized AI sales coaching advice and performance analysis based on YOUR actual CRM data. ALWAYS use this tool (not sf_query) when the user asks: "How am I doing?", "Give me sales tips", "Coach me on my deals", "What can I improve?", "Analyze my performance", "Help me close more deals". This tool analyzes the user's real opportunities, win rates, and pipeline to provide personalized coaching tips.`,
        inputSchema: z.object({
          focusArea: z.enum(['discovery', 'negotiation', 'closing', 'prospecting', 'pipeline_management', 'general']).optional().describe('Optional focus area for coaching'),
        }),
        execute: async (args) => self.executeTool('get_sales_coaching', args, userId),
      }),

      get_account_intelligence: tool({
        description: `Get AI-generated intelligence and health score for a specific account. Use this when user asks: "How is [account name] doing?", "What's the health of my account?", "Any risks with [company]?", "Tell me about [account] engagement". Returns account health score, engagement metrics, risk indicators, and recommended actions.`,
        inputSchema: z.object({
          accountId: z.string().optional().describe('The account ID to analyze'),
          accountName: z.string().optional().describe('Account name to search for (if ID not provided)'),
        }),
        execute: async (args) => self.executeTool('get_account_intelligence', args, userId),
      }),

      get_deal_health: tool({
        description: `Get AI analysis of deal health and risk factors for opportunities. Use this when user asks: "Which deals are at risk?", "What's the health of my pipeline?", "Any stalled deals?", "Which opportunities need attention?". Returns deal health scores, risk factors, and recommended next steps.`,
        inputSchema: z.object({
          opportunityId: z.string().optional().describe('Specific opportunity ID to analyze'),
          riskLevel: z.enum(['high_risk', 'medium_risk', 'healthy']).optional().describe('Filter by risk level'),
          limit: z.number().optional().describe('Maximum number of deals to return (default: 10)'),
        }),
        execute: async (args) => self.executeTool('get_deal_health', args, userId),
      }),

      acknowledge_ai_insight: tool({
        description: 'Acknowledge an AI insight/alert to mark it as seen. Use when user says "got it", "thanks", "acknowledged" after seeing an insight.',
        inputSchema: z.object({
          alertId: z.string().describe('The ID of the alert to acknowledge'),
        }),
        execute: async (args) => self.executeTool('acknowledge_ai_insight', args, userId),
      }),

      dismiss_ai_insight: tool({
        description: 'Dismiss an AI insight/alert as not relevant. Use when user says "dismiss this", "not relevant", "ignore this".',
        inputSchema: z.object({
          alertId: z.string().describe('The ID of the alert to dismiss'),
          reason: z.string().optional().describe('Optional reason for dismissing'),
        }),
        execute: async (args) => self.executeTool('dismiss_ai_insight', args, userId),
      }),
    };
  }

  /**
   * INTELLIGENT ROUTING: Create tools for a specific cluster
   * Uses the full tool definitions but filters to only relevant tools
   */
  private createClusteredSalesforceTools(userId: string, clusterTools: string[]): Record<string, any> {
    const allTools = this.createSalesforceAiSdkTools(userId);
    return this.filterToolsByNames(allTools, clusterTools);
  }

  /**
   * Create Oracle CX AI SDK tools for ORACLE_CX_MODE
   * Used when user has connected to Oracle CX Sales Cloud
   */
  private createOracleCXAiSdkTools(userId: string) {
    const self = this;
    const dataSource: 'salesforce' | 'oracle_cx' | 'local' = 'oracle_cx';

    return {
      ocx_query: tool({
        description: 'Query Oracle CX Sales Cloud data. Fetches records from specified resource type with optional filters.',
        inputSchema: z.object({
          resource: z.string().describe('The Oracle CX resource type: opportunities, accounts, contacts, leads, activities'),
          filters: z.record(z.string(), z.any()).optional().describe('Query filters as key-value pairs'),
          limit: z.number().optional().describe('Maximum number of records to return'),
          offset: z.number().optional().describe('Number of records to skip for pagination'),
          orderBy: z.string().optional().describe('Field to sort by'),
          fields: z.string().optional().describe('Comma-separated list of fields to return'),
        }),
        execute: async (args) => self.executeTool('ocx_query', args, userId, dataSource),
      }),

      ocx_get_record: tool({
        description: 'Get a single Oracle CX record by ID',
        inputSchema: z.object({
          resource: z.string().describe('The Oracle CX resource type'),
          recordId: z.string().describe('The Oracle CX record ID'),
          expand: z.string().optional().describe('Related resources to include'),
        }),
        execute: async (args) => self.executeTool('ocx_get_record', args, userId, dataSource),
      }),

      ocx_create_lead: tool({
        description: 'Create a new Lead in Oracle CX Sales Cloud',
        inputSchema: z.object({
          FirstName: z.string().optional().describe('Lead first name'),
          LastName: z.string().describe('Lead last name (required)'),
          CompanyName: z.string().optional().describe('Company name'),
          EmailAddress: z.string().optional().describe('Email address'),
          WorkPhoneNumber: z.string().optional().describe('Work phone number'),
          Title: z.string().optional().describe('Job title'),
        }).passthrough(),
        execute: async (args) => self.executeTool('ocx_create_lead', args, userId, dataSource),
      }),

      ocx_update_lead: tool({
        description: 'Update an existing Lead in Oracle CX Sales Cloud',
        inputSchema: z.object({
          leadId: z.string().describe('The Oracle CX Lead ID'),
        }).passthrough(),
        execute: async (args) => self.executeTool('ocx_update_lead', args, userId, dataSource),
      }),

      ocx_create_opportunity: tool({
        description: 'Create a new Opportunity in Oracle CX Sales Cloud',
        inputSchema: z.object({
          Name: z.string().describe('Opportunity name (required)'),
          AccountId: z.string().optional().describe('Associated account ID'),
          Revenue: z.number().optional().describe('Revenue amount'),
          CloseDate: z.string().optional().describe('Expected close date'),
          SalesStage: z.string().optional().describe('Sales stage name'),
          WinProb: z.number().optional().describe('Win probability (0-100)'),
        }).passthrough(),
        execute: async (args) => self.executeTool('ocx_create_opportunity', args, userId, dataSource),
      }),

      ocx_update_opportunity: tool({
        description: 'Update an existing Opportunity in Oracle CX Sales Cloud. CRITICAL: You MUST have the Oracle CX Opportunity ID from a previous query. If you only have the opportunity NAME, FIRST use ocx_query to get the ID.',
        inputSchema: z.object({
          opportunityId: z.string().describe('The Oracle CX Opportunity ID (from previous search/query results)'),
        }).passthrough(),
        execute: async (args) => self.executeTool('ocx_update_opportunity', args, userId, dataSource),
      }),

      ocx_create_contact: tool({
        description: 'Create a new Contact in Oracle CX Sales Cloud',
        inputSchema: z.object({
          FirstName: z.string().optional().describe('Contact first name'),
          LastName: z.string().describe('Contact last name (required)'),
          AccountId: z.string().optional().describe('Associated account ID'),
          EmailAddress: z.string().optional().describe('Email address'),
          WorkPhoneNumber: z.string().optional().describe('Work phone number'),
          JobTitle: z.string().optional().describe('Job title'),
        }).passthrough(),
        execute: async (args) => self.executeTool('ocx_create_contact', args, userId, dataSource),
      }),

      ocx_update_contact: tool({
        description: 'Update an existing Contact in Oracle CX Sales Cloud',
        inputSchema: z.object({
          contactId: z.string().describe('The Oracle CX Contact ID'),
        }).passthrough(),
        execute: async (args) => self.executeTool('ocx_update_contact', args, userId, dataSource),
      }),

      ocx_create_account: tool({
        description: 'Create a new Account in Oracle CX Sales Cloud',
        inputSchema: z.object({
          OrganizationName: z.string().describe('Account/Organization name (required)'),
          Type: z.string().optional().describe('Account type'),
          Industry: z.string().optional().describe('Industry classification'),
          AnnualRevenue: z.number().optional().describe('Annual revenue'),
          NumberOfEmployees: z.number().optional().describe('Number of employees'),
        }).passthrough(),
        execute: async (args) => self.executeTool('ocx_create_account', args, userId, dataSource),
      }),

      ocx_create_task: tool({
        description: 'Create a new Task in Oracle CX Sales Cloud',
        inputSchema: z.object({
          Subject: z.string().describe('Task subject (required)'),
          DueDate: z.string().optional().describe('Due date'),
          Status: z.string().optional().describe('Task status'),
          Priority: z.string().optional().describe('Task priority'),
          AccountId: z.string().optional().describe('Related account ID'),
          ContactId: z.string().optional().describe('Related contact ID'),
          OpportunityId: z.string().optional().describe('Related opportunity ID'),
        }).passthrough(),
        execute: async (args) => self.executeTool('ocx_create_task', args, userId, dataSource),
      }),

      ocx_describe_resource: tool({
        description: 'Get metadata about an Oracle CX resource including available fields',
        inputSchema: z.object({
          resource: z.string().describe('The Oracle CX resource type'),
        }),
        execute: async (args) => self.executeTool('ocx_describe_resource', args, userId, dataSource),
      }),

      ocx_update_record: tool({
        description: 'Update any Oracle CX record',
        inputSchema: z.object({
          resource: z.string().describe('The Oracle CX resource type'),
          recordId: z.string().describe('The Oracle CX record ID'),
          fields: z.record(z.string(), z.any()).describe('Fields to update'),
        }),
        execute: async (args) => self.executeTool('ocx_update_record', args, userId, dataSource),
      }),

      ocx_create_record: tool({
        description: 'Create any Oracle CX record',
        inputSchema: z.object({
          resource: z.string().describe('The Oracle CX resource type'),
          fields: z.record(z.string(), z.any()).describe('Fields for the new record'),
        }),
        execute: async (args) => self.executeTool('ocx_create_record', args, userId, dataSource),
      }),

      // Include common tools
      research_company: tool({
        description: 'Research a company via web search',
        inputSchema: z.object({
          companyUrlOrName: z.string().describe('Company name or website URL'),
        }),
        execute: async (args) => self.executeTool('research_company', args, userId, dataSource),
      }),

      web_search: tool({
        description: 'Search the web for information',
        inputSchema: z.object({
          query: z.string().describe('Search query'),
        }),
        execute: async (args) => self.executeTool('web_search', args, userId, dataSource),
      }),

      send_email: tool({
        description: 'Send an email',
        inputSchema: z.object({
          to: z.array(z.string()).describe('Recipient email addresses'),
          subject: z.string().describe('Email subject'),
          body: z.string().describe('Email body'),
          cc: z.array(z.string()).optional().describe('CC recipients'),
        }),
        execute: async (args) => self.executeTool('send_email', args, userId, dataSource),
      }),

      schedule_meeting: tool({
        description: 'Schedule a video meeting',
        inputSchema: z.object({
          title: z.string().describe('Meeting title'),
          startTime: z.string().describe('Start time in ISO 8601 format'),
          endTime: z.string().describe('End time in ISO 8601 format'),
          attendeeEmails: z.array(z.string()).optional().describe('Attendee emails'),
          platform: z.enum(['ZOOM', 'TEAMS', 'GOOGLE_MEET']).describe('Video platform'),
          description: z.string().optional().describe('Meeting description'),
        }),
        execute: async (args) => self.executeTool('schedule_meeting', args, userId, dataSource),
      }),

      compute_analytics: tool({
        description: 'Compute sales analytics from CRM data',
        inputSchema: z.object({
          metricType: z.string().describe('Type of metric to compute'),
          records: z.array(z.any()).describe('Array of CRM records to analyze'),
        }),
        execute: async (args) => self.executeTool('compute_analytics', args, userId, dataSource),
      }),

      // ==================== AI INSIGHTS & COACHING TOOLS (MVP #1 & #2) ====================
      get_my_ai_insights: tool({
        description: `Get AI-generated insights and recommendations for the current user. ALWAYS use this tool when user asks: "What should I focus on today?", "Give me coaching tips", "What are my AI insights?", "What deals need attention?", "Any recommendations for me?"`,
        inputSchema: z.object({
          agentType: z.enum(['DEAL_HEALTH', 'COACHING', 'ACCOUNT_INTELLIGENCE', 'PIPELINE_ACCELERATION', 'NEXT_BEST_ACTION']).optional().describe('Filter by agent type'),
          priority: z.enum(['URGENT', 'HIGH', 'MEDIUM', 'LOW']).optional().describe('Filter by priority level'),
          limit: z.number().optional().describe('Maximum number of insights to return (default: 10)'),
        }),
        execute: async (args) => self.executeTool('get_my_ai_insights', args, userId),
      }),

      get_sales_coaching: tool({
        description: `Get personalized AI sales coaching advice and performance analysis based on YOUR actual CRM data. ALWAYS use this tool (not ocx_query) when the user asks: "How am I doing?", "Give me sales tips", "Coach me on my deals", "What can I improve?", "Analyze my performance", "Help me close more deals". This tool analyzes the user's real opportunities, win rates, and pipeline to provide personalized coaching tips.`,
        inputSchema: z.object({
          focusArea: z.enum(['discovery', 'negotiation', 'closing', 'prospecting', 'pipeline_management', 'general']).optional().describe('Optional focus area for coaching'),
        }),
        execute: async (args) => self.executeTool('get_sales_coaching', args, userId),
      }),

      get_account_intelligence: tool({
        description: `Get AI-generated intelligence and health score for a specific account. Use this when user asks: "How is [account name] doing?", "What's the health of my account?", "Any risks with [company]?", "Tell me about [account] engagement". Returns account health score, engagement metrics, risk indicators, and recommended actions.`,
        inputSchema: z.object({
          accountId: z.string().optional().describe('The account ID to analyze'),
          accountName: z.string().optional().describe('Account name to search for (if ID not provided)'),
        }),
        execute: async (args) => self.executeTool('get_account_intelligence', args, userId),
      }),

      get_deal_health: tool({
        description: `Get AI analysis of deal health and risk factors for opportunities. Use this when user asks: "Which deals are at risk?", "What's the health of my pipeline?", "Any stalled deals?", "Which opportunities need attention?". Returns deal health scores, risk factors, and recommended next steps.`,
        inputSchema: z.object({
          opportunityId: z.string().optional().describe('Specific opportunity ID to analyze'),
          riskLevel: z.enum(['high_risk', 'medium_risk', 'healthy']).optional().describe('Filter by risk level'),
          limit: z.number().optional().describe('Maximum number of deals to return (default: 10)'),
        }),
        execute: async (args) => self.executeTool('get_deal_health', args, userId),
      }),

      acknowledge_ai_insight: tool({
        description: 'Acknowledge an AI insight/alert to mark it as seen. Use when user says "got it", "thanks", "acknowledged" after seeing an insight.',
        inputSchema: z.object({
          alertId: z.string().describe('The ID of the alert to acknowledge'),
        }),
        execute: async (args) => self.executeTool('acknowledge_ai_insight', args, userId),
      }),

      dismiss_ai_insight: tool({
        description: 'Dismiss an AI insight/alert as not relevant. Use when user says "dismiss this", "not relevant", "ignore this".',
        inputSchema: z.object({
          alertId: z.string().describe('The ID of the alert to dismiss'),
          reason: z.string().optional().describe('Optional reason for dismissing'),
        }),
        execute: async (args) => self.executeTool('dismiss_ai_insight', args, userId),
      }),
    };
  }

  /**
   * Filter tools to only include those with names in the provided list
   * Used by the query router to reduce tool set for simple queries
   */
  private filterToolsByNames(
    allTools: Record<string, any>,
    relevantToolNames: string[]
  ): Record<string, any> {
    const filtered: Record<string, any> = {};
    for (const toolName of relevantToolNames) {
      if (allTools[toolName]) {
        filtered[toolName] = allTools[toolName];
      }
    }
    // If no tools matched, return all tools as fallback
    if (Object.keys(filtered).length === 0) {
      this.logger.warn('No tools matched filter, using all tools');
      return allTools;
    }
    return filtered;
  }

  /**
   * Sync meeting to Salesforce as an Event record (for Salesforce mode users)
   * Creates a new Event or updates existing one based on salesforceEventId
   * 
   * @param meeting - The meeting session data
   * @param userId - The user ID who owns the meeting
   * @param action - 'create' | 'update' | 'cancel'
   * @returns The Salesforce Event ID if successful, null otherwise
   */
  private async syncMeetingToSalesforceEvent(
    meeting: {
      id: string;
      title: string;
      description?: string | null;
      scheduledStart: Date;
      scheduledEnd?: Date | null;
      meetingUrl?: string | null;
      platform: string;
      leadId?: string | null;
      accountId?: string | null;
      opportunityId?: string | null;
      salesforceEventId?: string | null;
    },
    userId: string,
    action: 'create' | 'update' | 'cancel',
  ): Promise<string | null> {
    try {
      this.logger.log(`[SF_EVENT_SYNC] Starting sync for meeting ${meeting.id}, action=${action}, userId=${userId}`);

      // Check if user has Salesforce connected
      const sfConnection = await this.prisma.salesforceConnection.findFirst({
        where: { userId },
      });

      if (!sfConnection) {
        this.logger.warn(`[SF_EVENT_SYNC] User ${userId} has no Salesforce connection - skipping Event sync`);
        return null;
      }

      this.logger.log(`[SF_EVENT_SYNC] Found Salesforce connection for user ${userId}, proceeding with ${action}`);

      // Calculate end time (default 60 min if not provided)
      const startDateTime = meeting.scheduledStart.toISOString();
      const endDateTime = meeting.scheduledEnd
        ? meeting.scheduledEnd.toISOString()
        : new Date(meeting.scheduledStart.getTime() + 60 * 60 * 1000).toISOString();

      // Calculate duration in minutes for display
      const durationMs = new Date(endDateTime).getTime() - new Date(startDateTime).getTime();
      const durationMins = Math.round(durationMs / (1000 * 60));

      // Build rich description with meeting details
      const descriptionParts: string[] = [];

      // Add agenda/description if provided
      if (meeting.description) {
        descriptionParts.push(`ðŸ“‹ AGENDA:\n${meeting.description}`);
        descriptionParts.push('\n');
      }

      // Add video conference details prominently
      descriptionParts.push('â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”');
      descriptionParts.push(`ðŸ“¹ VIDEO CONFERENCE DETAILS`);
      descriptionParts.push('â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”');
      descriptionParts.push(`Platform: ${meeting.platform}`);
      if (meeting.meetingUrl) {
        descriptionParts.push(`\nðŸ”— JOIN MEETING:\n${meeting.meetingUrl}`);
      }
      descriptionParts.push(`\nDuration: ${durationMins} minutes`);
      descriptionParts.push('â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”');

      // Add IRIS tracking info
      descriptionParts.push(`\n\nðŸ“Š Managed by IRIS Sales CRM`);
      descriptionParts.push(`Meeting ID: ${meeting.id}`);

      const fullDescription = descriptionParts.join('\n');

      // Prepare Event data for Salesforce
      // Note: Type field is not standard across all orgs, so we omit it
      const eventData: Record<string, any> = {
        Subject: meeting.title,
        StartDateTime: startDateTime,
        EndDateTime: endDateTime,
        Description: fullDescription,
        Location: meeting.meetingUrl || `${meeting.platform} Meeting`,
        ShowAs: 'Busy',
        IsAllDayEvent: false,
      };

      // Link to Salesforce Lead/Account/Opportunity if they have SF IDs
      // Note: We need to look up the Salesforce IDs from the local records
      if (meeting.leadId) {
        const lead = await this.prisma.lead.findUnique({
          where: { id: meeting.leadId },
          select: { salesforceId: true },
        });
        if (lead?.salesforceId) {
          eventData.WhoId = lead.salesforceId; // WhoId for Lead/Contact
        }
      }

      if (meeting.accountId) {
        const account = await this.prisma.account.findUnique({
          where: { id: meeting.accountId },
          select: { salesforceId: true },
        });
        if (account?.salesforceId) {
          eventData.WhatId = account.salesforceId; // WhatId for Account/Opportunity
        }
      }

      // Opportunity takes precedence over Account for WhatId
      if (meeting.opportunityId) {
        const opportunity = await this.prisma.opportunity.findUnique({
          where: { id: meeting.opportunityId },
          select: { salesforceId: true },
        });
        if (opportunity?.salesforceId) {
          eventData.WhatId = opportunity.salesforceId;
        }
      }

      if (action === 'create') {
        // Create new Event in Salesforce
        this.logger.log(`[SF_EVENT_SYNC] Creating Salesforce Event with data: Subject=${eventData.Subject}, StartDateTime=${eventData.StartDateTime}`);
        const result = await this.salesforceService.create(userId, 'Event', eventData);
        this.logger.log(`[SF_EVENT_SYNC] Salesforce create result: ${JSON.stringify(result)}`);

        if (result?.id) {
          this.logger.log(`[SF_EVENT_SYNC] Created Salesforce Event ${result.id} for meeting ${meeting.id}`);
          
          // Store the Salesforce Event ID in the meeting record
          await this.prisma.meetingSession.update({
            where: { id: meeting.id },
            data: { salesforceEventId: result.id },
          });
          
          return result.id;
        }
      } else if (action === 'update' && meeting.salesforceEventId) {
        // Update existing Event in Salesforce
        await this.salesforceService.update(userId, 'Event', meeting.salesforceEventId, eventData);
        this.logger.log(`Updated Salesforce Event ${meeting.salesforceEventId} for meeting ${meeting.id}`);
        return meeting.salesforceEventId;
      } else if (action === 'cancel' && meeting.salesforceEventId) {
        // For cancellation, we update the Event subject and description
        // Salesforce Events don't have a "cancelled" status, so we mark it clearly
        const cancelledAt = new Date().toISOString();
        const cancelDescription = [
          'âŒ THIS MEETING HAS BEEN CANCELLED',
          'â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”',
          `Cancelled on: ${new Date(cancelledAt).toLocaleString()}`,
          meeting.description ? `Cancellation reason: ${meeting.description}` : '',
          'â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”',
          '',
          'Original meeting details:',
          fullDescription,
        ].filter(Boolean).join('\n');

        const cancelData: Record<string, any> = {
          Subject: `[CANCELLED] ${meeting.title}`,
          Description: cancelDescription,
          // Keep the ShowAs as Free since meeting is cancelled
          ShowAs: 'Free',
        };

        await this.salesforceService.update(userId, 'Event', meeting.salesforceEventId, cancelData);
        this.logger.log(`Marked Salesforce Event ${meeting.salesforceEventId} as cancelled for meeting ${meeting.id}`);
        return meeting.salesforceEventId;
      }

      return null;
    } catch (error: any) {
      // Log but don't fail the meeting operation if SF sync fails
      this.logger.warn(`Failed to sync meeting to Salesforce Event: ${error.message}`);
      return null;
    }
  }

  /**
   * Extract document sources from tool results for attribution
   */
  private async extractDocumentSources(
    toolName: string,
    toolInput: any,
    toolResult: any,
    sources: DocumentSource[],
  ): Promise<void> {
    try {
      if (toolName === 'search_document' && toolResult.data?.results) {
        // Get document filename
        const docId = toolInput.documentId;
        let filename = docId;

        try {
          const docList = await this.pageIndexService.listDocuments();
          const doc = docList.documents?.find(d => d.document_id === docId);
          if (doc) filename = doc.filename;
        } catch (e) {
          // Use documentId as fallback
        }

        // Check if we already have this document in sources
        let existingSource = sources.find(s => s.documentId === docId);
        if (!existingSource) {
          existingSource = { documentId: docId, filename, sections: [] };
          sources.push(existingSource);
        }

        // Add sections from search results
        for (const result of toolResult.data.results) {
          existingSource.sections.push({
            title: result.title || 'Untitled Section',
            pages: result.pages || 'N/A',
            relevanceScore: result.relevanceScore,
          });
        }
      } else if (toolName === 'get_document_summary' || toolName === 'get_document_structure') {
        const docId = toolInput.documentId;
        let filename = docId;

        try {
          const docList = await this.pageIndexService.listDocuments();
          const doc = docList.documents?.find(d => d.document_id === docId);
          if (doc) filename = doc.filename;
        } catch (e) {
          // Use documentId as fallback
        }

        // Check if we already have this document
        if (!sources.find(s => s.documentId === docId)) {
          sources.push({
            documentId: docId,
            filename,
            sections: [{ title: 'Full Document', pages: 'All' }],
          });
        }
      }
    } catch (error) {
      this.logger.warn(`Failed to extract document sources: ${error.message}`);
    }
  }

  /**
   * Dynamic field extractor - finds field values by pattern matching
   * Instead of hardcoding field names, we search for fields matching semantic patterns
   * This makes the code CRM-agnostic and maintainable
   */
  private extractFieldByPattern(obj: any, patterns: RegExp[], fallback: any = ''): any {
    if (!obj || typeof obj !== 'object') return fallback;
    for (const pattern of patterns) {
      for (const key of Object.keys(obj)) {
        if (pattern.test(key) && obj[key] !== undefined && obj[key] !== null) {
          return obj[key];
        }
      }
    }
    return fallback;
  }

  // Semantic field patterns for CRM entities - used for dynamic field extraction
  private readonly FIELD_PATTERNS = {
    id: [/^id$/i, /lead.*id$/i, /contact.*id$/i, /opty.*id$/i, /party.*id$/i],
    email: [/^email$/i, /email.*address/i, /primary.*email/i, /contact.*email/i],
    phone: [/^phone$/i, /phone.*number/i, /primary.*phone/i, /contact.*phone/i],
    firstName: [/^firstname$/i, /^first_name$/i, /person.*first.*name/i, /contact.*first.*name/i],
    lastName: [/^lastname$/i, /^last_name$/i, /person.*last.*name/i, /contact.*last.*name/i],
    name: [/^name$/i, /^full.*name$/i],
    company: [/^company$/i, /company.*name/i, /customer.*party.*name/i, /organization.*name/i],
    title: [/^title$/i, /^job.*title$/i],
    status: [/^status$/i, /status.*code/i],
    rating: [/^rating$/i, /^rank$/i, /rank.*code/i],
    amount: [/^amount$/i, /^revenue$/i],
    stage: [/^stage$/i, /stage.*name/i, /sales.*stage/i],
    closeDate: [/^close.*date$/i, /effective.*date/i],
    probability: [/^probability$/i, /win.*prob/i],
    accountName: [/^account.*name$/i, /customer.*name/i, /party.*name/i, /organization.*name/i],
  };

  /**
   * Extract structured widget data from tool results for frontend rendering
   * This allows the frontend to render rich UI components without parsing markdown
   */
  private extractWidgetDataFromToolResult(
    toolName: string,
    toolResult: any,
    toolInput?: any,
  ): WidgetData | null {
    try {
      // Only extract from successful tool calls with data
      if (!toolResult || toolResult.success === false || !toolResult.data) {
        return null;
      }

      const data = toolResult.data;

      // ============================================================
      // SALESFORCE QUERY RESULTS (sf_query)
      // Detect object type from SOQL query and extract structured data
      // ============================================================
      if (toolName === 'sf_query' && data.records && Array.isArray(data.records)) {
        const records = data.records;
        if (records.length === 0) return null;

        // Detect object type from query
        const query = (toolInput?.query || '').toUpperCase();
        const fromMatch = query.match(/FROM\s+(\w+)/i);
        const objectType = fromMatch ? fromMatch[1].toLowerCase() : null;

        // Extract Salesforce Opportunities
        if (objectType === 'opportunity' || records[0]?.attributes?.type === 'Opportunity') {
          return {
            type: 'opportunities',
            title: `Found ${records.length} opportunities`,
            data: records.map((rec: any) => ({
              id: rec.Id,
              name: rec.Name,
              amount: rec.Amount,
              stage: rec.StageName || rec.Stage,
              probability: rec.Probability,
              closeDate: rec.CloseDate,
              accountName: rec.Account?.Name || rec.AccountName,
              accountId: rec.AccountId,
              ownerName: rec.Owner?.Name,
              type: rec.Type,
              leadSource: rec.LeadSource,
              description: rec.Description,
              nextStep: rec.NextStep,
              createdDate: rec.CreatedDate,
            })),
            metadata: { totalCount: data.totalSize || records.length, source: 'salesforce' },
          };
        }

        // Extract Salesforce Leads
        if (objectType === 'lead' || records[0]?.attributes?.type === 'Lead') {
          return {
            type: 'leads',
            title: `Found ${records.length} leads`,
            data: records.map((rec: any) => ({
              id: rec.Id,
              name: `${rec.FirstName || ''} ${rec.LastName || ''}`.trim() || rec.Name,
              firstName: rec.FirstName,
              lastName: rec.LastName,
              company: rec.Company,
              title: rec.Title,
              email: rec.Email,
              phone: rec.Phone,
              status: rec.Status,
              rating: rec.Rating,
              source: rec.LeadSource,
              industry: rec.Industry,
              createdDate: rec.CreatedDate,
              description: rec.Description,
            })),
            metadata: { totalCount: data.totalSize || records.length, source: 'salesforce' },
          };
        }

        // Extract Salesforce Accounts
        if (objectType === 'account' || records[0]?.attributes?.type === 'Account') {
          return {
            type: 'accounts',
            title: `Found ${records.length} accounts`,
            data: records.map((rec: any) => ({
              id: rec.Id,
              name: rec.Name,
              type: rec.Type,
              industry: rec.Industry,
              phone: rec.Phone,
              website: rec.Website,
              billingCity: rec.BillingCity,
              billingState: rec.BillingState,
              billingCountry: rec.BillingCountry,
              annualRevenue: rec.AnnualRevenue,
              numberOfEmployees: rec.NumberOfEmployees,
              description: rec.Description,
              createdDate: rec.CreatedDate,
              ownerName: rec.Owner?.Name,
            })),
            metadata: { totalCount: data.totalSize || records.length, source: 'salesforce' },
          };
        }

        // Extract Salesforce Contacts
        if (objectType === 'contact' || records[0]?.attributes?.type === 'Contact') {
          return {
            type: 'contacts',
            title: `Found ${records.length} contacts`,
            data: records.map((rec: any) => ({
              id: rec.Id,
              name: `${rec.FirstName || ''} ${rec.LastName || ''}`.trim() || rec.Name,
              firstName: rec.FirstName,
              lastName: rec.LastName,
              email: rec.Email,
              phone: rec.Phone,
              title: rec.Title,
              accountName: rec.Account?.Name,
              accountId: rec.AccountId,
              department: rec.Department,
              mailingCity: rec.MailingCity,
              mailingState: rec.MailingState,
              createdDate: rec.CreatedDate,
            })),
            metadata: { totalCount: data.totalSize || records.length, source: 'salesforce' },
          };
        }

        // Extract Salesforce Tasks
        if (objectType === 'task' || records[0]?.attributes?.type === 'Task') {
          return {
            type: 'tasks',
            title: `Found ${records.length} tasks`,
            data: records.map((rec: any) => ({
              id: rec.Id,
              subject: rec.Subject,
              status: rec.Status,
              priority: rec.Priority,
              dueDate: rec.ActivityDate,
              description: rec.Description,
              type: rec.Type,
              whoName: rec.Who?.Name,
              whatName: rec.What?.Name,
              ownerName: rec.Owner?.Name,
              createdDate: rec.CreatedDate,
            })),
            metadata: { totalCount: data.totalSize || records.length, source: 'salesforce' },
          };
        }

        // Generic fallback for other Salesforce objects - don't render as widget
        // This prevents raw data from being shown as markdown
        return null;
      }

      // ============================================================
      // Salesforce single record operations
      // ============================================================
      if (toolName === 'sf_get_record' && data) {
        const rec = data;
        const objType = rec.attributes?.type?.toLowerCase();

        if (objType === 'opportunity') {
          return {
            type: 'opportunities',
            title: `Opportunity: ${rec.Name}`,
            data: [{
              id: rec.Id,
              name: rec.Name,
              amount: rec.Amount,
              stage: rec.StageName || rec.Stage,
              probability: rec.Probability,
              closeDate: rec.CloseDate,
              accountName: rec.Account?.Name,
              accountId: rec.AccountId,
              ownerName: rec.Owner?.Name,
              type: rec.Type,
              description: rec.Description,
              nextStep: rec.NextStep,
            }],
          };
        }

        if (objType === 'lead') {
          return {
            type: 'leads',
            title: `Lead: ${rec.FirstName || ''} ${rec.LastName || ''}`.trim(),
            data: [{
              id: rec.Id,
              name: `${rec.FirstName || ''} ${rec.LastName || ''}`.trim(),
              firstName: rec.FirstName,
              lastName: rec.LastName,
              company: rec.Company,
              title: rec.Title,
              email: rec.Email,
              phone: rec.Phone,
              status: rec.Status,
              rating: rec.Rating,
              source: rec.LeadSource,
              description: rec.Description,
            }],
          };
        }

        if (objType === 'account') {
          return {
            type: 'accounts',
            title: `Account: ${rec.Name}`,
            data: [{
              id: rec.Id,
              name: rec.Name,
              type: rec.Type,
              industry: rec.Industry,
              phone: rec.Phone,
              website: rec.Website,
              billingCity: rec.BillingCity,
              billingState: rec.BillingState,
              annualRevenue: rec.AnnualRevenue,
              numberOfEmployees: rec.NumberOfEmployees,
              description: rec.Description,
            }],
          };
        }

        if (objType === 'contact') {
          return {
            type: 'contacts',
            title: `Contact: ${rec.FirstName || ''} ${rec.LastName || ''}`.trim(),
            data: [{
              id: rec.Id,
              name: `${rec.FirstName || ''} ${rec.LastName || ''}`.trim(),
              firstName: rec.FirstName,
              lastName: rec.LastName,
              email: rec.Email,
              phone: rec.Phone,
              title: rec.Title,
              accountName: rec.Account?.Name,
              department: rec.Department,
            }],
          };
        }

        if (objType === 'task') {
          return {
            type: 'tasks',
            title: `Task: ${rec.Subject}`,
            data: [{
              id: rec.Id,
              subject: rec.Subject,
              status: rec.Status,
              priority: rec.Priority,
              dueDate: rec.ActivityDate,
              description: rec.Description,
            }],
          };
        }
      }

      // ============================================================
      // ORACLE CX QUERY RESULTS (ocx_query)
      // ============================================================
      if (toolName === 'ocx_query' && data.records && Array.isArray(data.records)) {
        const records = data.records;
        if (records.length === 0) return null;

        // Detect resource type from tool input
        const resource = (toolInput?.resource || '').toLowerCase();

        // Extract Oracle CX Leads - using pattern-based field extraction
        if (resource === 'leads' || records[0]?.LeadId) {
          return {
            type: 'leads',
            title: `Found ${records.length} leads`,
            data: records.map((rec: any) => {
              const firstName = this.extractFieldByPattern(rec, this.FIELD_PATTERNS.firstName);
              const lastName = this.extractFieldByPattern(rec, this.FIELD_PATTERNS.lastName);
              return {
                id: this.extractFieldByPattern(rec, this.FIELD_PATTERNS.id),
                name: this.extractFieldByPattern(rec, this.FIELD_PATTERNS.name) || `${firstName} ${lastName}`.trim(),
                firstName,
                lastName,
                company: this.extractFieldByPattern(rec, this.FIELD_PATTERNS.company),
                title: this.extractFieldByPattern(rec, this.FIELD_PATTERNS.title),
                email: this.extractFieldByPattern(rec, this.FIELD_PATTERNS.email),
                phone: this.extractFieldByPattern(rec, this.FIELD_PATTERNS.phone),
                status: this.extractFieldByPattern(rec, this.FIELD_PATTERNS.status),
                rating: this.extractFieldByPattern(rec, this.FIELD_PATTERNS.rating),
                source: rec.SourceCode,
                createdDate: rec.CreationDate,
                description: rec.Description,
                ownerName: rec.OwnerPartyName,
              };
            }),
            metadata: { totalCount: data.totalSize || records.length, source: 'oracle_cx' },
          };
        }

        // Extract Oracle CX Opportunities - using pattern-based field extraction
        if (resource === 'opportunities' || records[0]?.OptyId) {
          return {
            type: 'opportunities',
            title: `Found ${records.length} opportunities`,
            data: records.map((rec: any) => ({
              id: this.extractFieldByPattern(rec, this.FIELD_PATTERNS.id),
              name: this.extractFieldByPattern(rec, this.FIELD_PATTERNS.name),
              amount: this.extractFieldByPattern(rec, this.FIELD_PATTERNS.amount, 0),
              stage: this.extractFieldByPattern(rec, this.FIELD_PATTERNS.stage),
              probability: this.extractFieldByPattern(rec, this.FIELD_PATTERNS.probability, 0),
              closeDate: this.extractFieldByPattern(rec, this.FIELD_PATTERNS.closeDate),
              accountName: this.extractFieldByPattern(rec, this.FIELD_PATTERNS.accountName),
              accountId: rec.TargetPartyId || rec.AccountId,
              ownerName: rec.OwnerPartyName,
              type: rec.Type,
              createdDate: rec.CreationDate,
              description: rec.Description,
              statusCode: this.extractFieldByPattern(rec, this.FIELD_PATTERNS.status),
            })),
            metadata: { totalCount: data.totalSize || records.length, source: 'oracle_cx' },
          };
        }

        // Extract Oracle CX Accounts - using pattern-based field extraction
        if (resource === 'accounts' || (records[0]?.PartyId && records[0]?.OrganizationName)) {
          return {
            type: 'accounts',
            title: `Found ${records.length} accounts`,
            data: records.map((rec: any) => ({
              id: this.extractFieldByPattern(rec, this.FIELD_PATTERNS.id),
              name: this.extractFieldByPattern(rec, this.FIELD_PATTERNS.company) || this.extractFieldByPattern(rec, this.FIELD_PATTERNS.name),
              type: rec.Type || rec.PartyType,
              industry: rec.Industry,
              phone: this.extractFieldByPattern(rec, this.FIELD_PATTERNS.phone),
              website: rec.URL || rec.Website,
              billingCity: rec.City,
              billingState: rec.State,
              billingCountry: rec.Country,
              annualRevenue: rec.AnnualRevenue,
              numberOfEmployees: rec.EmployeesTotal,
              description: rec.Comments,
              createdDate: rec.CreationDate,
              ownerName: rec.OwnerPartyName,
            })),
            metadata: { totalCount: data.totalSize || records.length, source: 'oracle_cx' },
          };
        }

        // Extract Oracle CX Contacts - using pattern-based field extraction
        if (resource === 'contacts' || (records[0]?.FirstName && records[0]?.LastName && !records[0]?.OrganizationName)) {
          return {
            type: 'contacts',
            title: `Found ${records.length} contacts`,
            data: records.map((rec: any) => {
              const firstName = this.extractFieldByPattern(rec, this.FIELD_PATTERNS.firstName);
              const lastName = this.extractFieldByPattern(rec, this.FIELD_PATTERNS.lastName);
              return {
                id: this.extractFieldByPattern(rec, this.FIELD_PATTERNS.id),
                name: this.extractFieldByPattern(rec, this.FIELD_PATTERNS.name) || `${firstName} ${lastName}`.trim(),
                firstName,
                lastName,
                email: this.extractFieldByPattern(rec, this.FIELD_PATTERNS.email),
                phone: this.extractFieldByPattern(rec, this.FIELD_PATTERNS.phone),
                title: this.extractFieldByPattern(rec, this.FIELD_PATTERNS.title),
                accountName: this.extractFieldByPattern(rec, this.FIELD_PATTERNS.accountName),
                accountId: rec.OrganizationPartyId || rec.AccountId,
                department: rec.Department,
                createdDate: rec.CreationDate,
              };
            }),
            metadata: { totalCount: data.totalSize || records.length, source: 'oracle_cx' },
          };
        }

        // Generic fallback for other Oracle CX objects - don't render as widget
        return null;
      }

      // ============================================================
      // ORACLE CX SINGLE RECORD (ocx_get_record)
      // ============================================================
      if (toolName === 'ocx_get_record' && data) {
        const rec = data;
        const resource = (toolInput?.resource || '').toLowerCase();

        // Detect record type from resource or field presence
        if (resource === 'leads' || rec.LeadId) {
          const firstName = this.extractFieldByPattern(rec, this.FIELD_PATTERNS.firstName);
          const lastName = this.extractFieldByPattern(rec, this.FIELD_PATTERNS.lastName);
          return {
            type: 'leads',
            title: `Lead: ${this.extractFieldByPattern(rec, this.FIELD_PATTERNS.name) || `${firstName} ${lastName}`.trim()}`,
            data: [{
              id: this.extractFieldByPattern(rec, this.FIELD_PATTERNS.id),
              name: this.extractFieldByPattern(rec, this.FIELD_PATTERNS.name) || `${firstName} ${lastName}`.trim(),
              firstName,
              lastName,
              company: this.extractFieldByPattern(rec, this.FIELD_PATTERNS.company),
              title: this.extractFieldByPattern(rec, this.FIELD_PATTERNS.title),
              email: this.extractFieldByPattern(rec, this.FIELD_PATTERNS.email),
              phone: this.extractFieldByPattern(rec, this.FIELD_PATTERNS.phone),
              status: this.extractFieldByPattern(rec, this.FIELD_PATTERNS.status),
              rating: this.extractFieldByPattern(rec, this.FIELD_PATTERNS.rating),
              source: rec.SourceCode || rec.LeadSource,
              createdDate: rec.CreationDate,
              description: rec.Description,
              ownerName: rec.OwnerPartyName,
            }],
            metadata: { source: 'oracle_cx' },
          };
        }

        if (resource === 'opportunities' || rec.OptyId) {
          return {
            type: 'opportunities',
            title: `Opportunity: ${this.extractFieldByPattern(rec, this.FIELD_PATTERNS.name)}`,
            data: [{
              id: this.extractFieldByPattern(rec, this.FIELD_PATTERNS.id),
              name: this.extractFieldByPattern(rec, this.FIELD_PATTERNS.name),
              amount: this.extractFieldByPattern(rec, this.FIELD_PATTERNS.amount, 0),
              stage: this.extractFieldByPattern(rec, this.FIELD_PATTERNS.stage),
              probability: this.extractFieldByPattern(rec, this.FIELD_PATTERNS.probability, 0),
              closeDate: this.extractFieldByPattern(rec, this.FIELD_PATTERNS.closeDate),
              accountName: this.extractFieldByPattern(rec, this.FIELD_PATTERNS.accountName),
              ownerName: rec.OwnerPartyName,
              description: rec.Description,
            }],
            metadata: { source: 'oracle_cx' },
          };
        }

        if (resource === 'contacts' || (rec.FirstName && rec.LastName && !rec.OrganizationName)) {
          const firstName = this.extractFieldByPattern(rec, this.FIELD_PATTERNS.firstName);
          const lastName = this.extractFieldByPattern(rec, this.FIELD_PATTERNS.lastName);
          return {
            type: 'contacts',
            title: `Contact: ${this.extractFieldByPattern(rec, this.FIELD_PATTERNS.name) || `${firstName} ${lastName}`.trim()}`,
            data: [{
              id: this.extractFieldByPattern(rec, this.FIELD_PATTERNS.id),
              name: this.extractFieldByPattern(rec, this.FIELD_PATTERNS.name) || `${firstName} ${lastName}`.trim(),
              firstName,
              lastName,
              email: this.extractFieldByPattern(rec, this.FIELD_PATTERNS.email),
              phone: this.extractFieldByPattern(rec, this.FIELD_PATTERNS.phone),
              title: this.extractFieldByPattern(rec, this.FIELD_PATTERNS.title),
              accountName: this.extractFieldByPattern(rec, this.FIELD_PATTERNS.accountName),
            }],
            metadata: { source: 'oracle_cx' },
          };
        }

        if (resource === 'accounts' || rec.OrganizationName) {
          return {
            type: 'accounts',
            title: `Account: ${this.extractFieldByPattern(rec, this.FIELD_PATTERNS.company) || this.extractFieldByPattern(rec, this.FIELD_PATTERNS.name)}`,
            data: [{
              id: this.extractFieldByPattern(rec, this.FIELD_PATTERNS.id),
              name: this.extractFieldByPattern(rec, this.FIELD_PATTERNS.company) || this.extractFieldByPattern(rec, this.FIELD_PATTERNS.name),
              type: rec.Type || rec.PartyType,
              industry: rec.Industry,
              phone: this.extractFieldByPattern(rec, this.FIELD_PATTERNS.phone),
              website: rec.URL || rec.Website,
              billingCity: rec.City,
              billingState: rec.State,
            }],
            metadata: { source: 'oracle_cx' },
          };
        }

        // Fallback - don't render unknown record types as widget
        return null;
      }

      // ============================================================
      // LOCAL DATABASE TOOLS
      // ============================================================

      // Lead-related tools
      if (toolName === 'search_leads' || toolName === 'get_leads' || toolName === 'list_leads') {
        const leads = Array.isArray(data) ? data : (data.leads || []);
        if (leads.length === 0) return null;
        return {
          type: 'leads',
          title: toolResult.message || `Found ${leads.length} leads`,
          data: leads.map((lead: any) => ({
            id: lead.id || lead.Id,
            name: lead.name || `${lead.firstName || lead.FirstName || ''} ${lead.lastName || lead.LastName || ''}`.trim(),
            firstName: lead.firstName || lead.FirstName,
            lastName: lead.lastName || lead.LastName,
            company: lead.company || lead.Company || '',
            title: lead.title || lead.Title || '',
            email: lead.email || lead.Email || '',
            phone: lead.phone || lead.Phone || '',
            status: lead.status || lead.Status || '',
            rating: lead.rating || lead.Rating || '',
            score: lead.aiScore || lead.score || lead.leadScore || 0,
            leadSource: lead.leadSource || lead.LeadSource || '',
            createdAt: lead.createdAt,
            updatedAt: lead.updatedAt,
          })),
          metadata: {
            totalCount: toolResult.count || leads.length,
            query: toolInput?.name || toolInput?.company,
            filters: toolInput,
            source: toolResult.source || 'local',  // Include data source for debugging
          },
        };
      }

      // Single lead details
      if (toolName === 'get_lead_details' || toolName === 'get_lead') {
        const lead = data;
        if (!lead?.id) return null;
        return {
          type: 'leads',
          title: `Lead: ${lead.firstName || ''} ${lead.lastName || ''}`.trim(),
          data: [{
            id: lead.id,
            name: `${lead.firstName || ''} ${lead.lastName || ''}`.trim() || lead.name,
            firstName: lead.firstName,
            lastName: lead.lastName,
            company: lead.company,
            title: lead.title,
            email: lead.email,
            phone: lead.phone,
            status: lead.status,
            rating: lead.rating,
            score: lead.aiScore || lead.score,
            source: lead.leadSource,
            createdAt: lead.createdAt,
            updatedAt: lead.updatedAt,
            activities: lead.activities,
            tasks: lead.tasks,
            notes: lead.notes,
          }],
        };
      }

      // Opportunity-related tools
      if (toolName === 'search_opportunities' || toolName === 'get_opportunities' || toolName === 'list_opportunities') {
        const opportunities = Array.isArray(data) ? data : (data.opportunities || []);
        if (opportunities.length === 0) return null;
        return {
          type: 'opportunities',
          title: toolResult.message || `Found ${opportunities.length} opportunities`,
          data: opportunities.map((opp: any) => ({
            id: opp.id,
            name: opp.name,
            amount: opp.amount,
            stage: opp.stage || opp.stageName,
            probability: opp.probability,
            closeDate: opp.closeDate || opp.expectedCloseDate,
            accountName: opp.account?.name || opp.accountName,
            accountId: opp.accountId,
            ownerName: opp.owner?.name,
            createdAt: opp.createdAt,
            updatedAt: opp.updatedAt,
          })),
          metadata: {
            totalCount: toolResult.count || opportunities.length,
            filters: toolInput,
          },
        };
      }

      // Account-related tools
      if (toolName === 'search_accounts' || toolName === 'get_accounts' || toolName === 'list_accounts') {
        const accounts = Array.isArray(data) ? data : (data.accounts || []);
        if (accounts.length === 0) return null;
        return {
          type: 'accounts',
          title: toolResult.message || `Found ${accounts.length} accounts`,
          data: accounts.map((acc: any) => ({
            id: acc.id,
            name: acc.name,
            type: acc.type,
            industry: acc.industry,
            phone: acc.phone,
            website: acc.website,
            billingCity: acc.billingCity,
            billingState: acc.billingState,
            annualRevenue: acc.annualRevenue,
            numberOfEmployees: acc.numberOfEmployees,
            createdAt: acc.createdAt,
          })),
          metadata: {
            totalCount: toolResult.count || accounts.length,
            filters: toolInput,
          },
        };
      }

      // Contact-related tools
      if (toolName === 'search_contacts' || toolName === 'get_contacts' || toolName === 'list_contacts') {
        const contacts = Array.isArray(data) ? data : (data.contacts || []);
        if (contacts.length === 0) return null;
        return {
          type: 'contacts',
          title: toolResult.message || `Found ${contacts.length} contacts`,
          data: contacts.map((contact: any) => ({
            id: contact.id,
            name: `${contact.firstName || ''} ${contact.lastName || ''}`.trim() || contact.name,
            firstName: contact.firstName,
            lastName: contact.lastName,
            email: contact.email,
            phone: contact.phone,
            title: contact.title,
            accountName: contact.account?.name || contact.accountName,
            accountId: contact.accountId,
          })),
          metadata: {
            totalCount: toolResult.count || contacts.length,
            filters: toolInput,
          },
        };
      }

      // Task-related tools
      if (toolName === 'search_tasks' || toolName === 'get_tasks' || toolName === 'list_tasks') {
        const tasks = Array.isArray(data) ? data : (data.tasks || []);
        if (tasks.length === 0) return null;
        return {
          type: 'tasks',
          title: toolResult.message || `Found ${tasks.length} tasks`,
          data: tasks.map((task: any) => ({
            id: task.id,
            subject: task.subject,
            status: task.status,
            priority: task.priority,
            dueDate: task.dueDate,
            description: task.description,
            relatedTo: task.lead?.firstName ? `${task.lead.firstName} ${task.lead.lastName}` : task.account?.name,
          })),
          metadata: {
            totalCount: toolResult.count || tasks.length,
            filters: toolInput,
          },
        };
      }

      // Pipeline/forecast data
      if (toolName === 'get_pipeline_stats' || toolName === 'get_pipeline_summary' || toolName === 'get_forecast') {
        return {
          type: 'pipeline',
          title: 'Pipeline Overview',
          data: [data],
          metadata: {
            filters: toolInput,
          },
        };
      }

      // Meeting-related tools
      if (toolName === 'schedule_meeting' || toolName === 'create_meeting' || toolName === 'get_meeting') {
        const meeting = data;
        if (!meeting) return null;
        return {
          type: 'meeting',
          title: meeting.title || 'Meeting Scheduled',
          data: [{
            id: meeting.id,
            title: meeting.title,
            startTime: meeting.startTime,
            endTime: meeting.endTime,
            attendees: meeting.attendees,
            description: meeting.description,
            location: meeting.location,
            platform: meeting.platform,
            joinUrl: meeting.joinUrl,
          }],
        };
      }

      // Email draft tools
      if (toolName === 'draft_email' || toolName === 'compose_email') {
        return {
          type: 'email_draft',
          title: 'Email Draft',
          data: [{
            to: data.to,
            subject: data.subject,
            body: data.body,
            from: data.from,
          }],
        };
      }

      // ============================================================
      // SALESFORCE SEARCH RESULTS (sf_search) - Mixed object types
      // ============================================================
      if (toolName === 'sf_search' && data.records && Array.isArray(data.records)) {
        const records = data.records;
        if (records.length === 0) return null;

        // Group records by object type
        const leads = records.filter((r: any) => r.objectType === 'Lead');
        const contacts = records.filter((r: any) => r.objectType === 'Contact');
        const accounts = records.filter((r: any) => r.objectType === 'Account');
        const opportunities = records.filter((r: any) => r.objectType === 'Opportunity');

        // Return the largest group as the primary widget type
        // This keeps the UI clean while still being accurate
        if (leads.length >= contacts.length && leads.length >= accounts.length && leads.length >= opportunities.length && leads.length > 0) {
          return {
            type: 'leads',
            title: `Found ${leads.length} leads`,
            data: leads.map((rec: any) => ({
              id: rec.id,
              name: rec.name,
              company: rec.company,
              title: rec.title,
              email: rec.email,
              phone: rec.phone,
              status: rec.status,
            })),
            metadata: { totalCount: leads.length, source: 'salesforce', searchTerm: data.searchTerm },
          };
        }

        if (opportunities.length >= contacts.length && opportunities.length >= accounts.length && opportunities.length > 0) {
          return {
            type: 'opportunities',
            title: `Found ${opportunities.length} opportunities`,
            data: opportunities.map((rec: any) => ({
              id: rec.id,
              name: rec.name,
              amount: rec.amount,
              stage: rec.stageName,
              closeDate: rec.closeDate,
              accountName: rec.accountName,
            })),
            metadata: { totalCount: opportunities.length, source: 'salesforce', searchTerm: data.searchTerm },
          };
        }

        if (accounts.length >= contacts.length && accounts.length > 0) {
          return {
            type: 'accounts',
            title: `Found ${accounts.length} accounts`,
            data: accounts.map((rec: any) => ({
              id: rec.id,
              name: rec.name,
              industry: rec.industry,
              phone: rec.phone,
              website: rec.website,
              type: rec.type,
            })),
            metadata: { totalCount: accounts.length, source: 'salesforce', searchTerm: data.searchTerm },
          };
        }

        if (contacts.length > 0) {
          return {
            type: 'contacts',
            title: `Found ${contacts.length} contacts`,
            data: contacts.map((rec: any) => ({
              id: rec.id,
              name: rec.name,
              email: rec.email,
              phone: rec.phone,
              title: rec.title,
              accountName: rec.accountName,
            })),
            metadata: { totalCount: contacts.length, source: 'salesforce', searchTerm: data.searchTerm },
          };
        }
      }

      return null;
    } catch (error) {
      this.logger.warn(`Failed to extract widget data from ${toolName}: ${error.message}`);
      return null;
    }
  }

  private async executeTool(
    toolName: string,
    toolInput: any,
    userId: string,
    dataSource?: 'salesforce' | 'oracle_cx' | 'local',
  ): Promise<any> {
      // Tool execution - reduced logging verbosity
      this.logger.log(`Executing tool: ${toolName} with input: dataSource=${dataSource || 'auto'}`);
      this.logger.log(toolInput);

      // Get user's organizationId for tenant isolation (used by multiple service calls)
      const userMembershipForOrg = await this.prisma.organizationMember.findFirst({
        where: { userId, isActive: true },
        select: { organizationId: true },
      });
      const organizationId = userMembershipForOrg?.organizationId || '';

      try {
      switch (toolName) {
        // ENTITY RESOLUTION - Resolve names to IDs for natural language commands
        case 'resolve_entity': {
          const { entityType, name, fuzzyMatch = true } = toolInput;
          const searchName = name.toLowerCase().trim();

          let results: any[] = [];
          let entityTypeLabel = entityType;

          switch (entityType) {
            case 'lead': {
              const leads = await this.prisma.lead.findMany({
                where: {
                  ownerId: userId,
                  OR: fuzzyMatch ? [
                    { firstName: { contains: searchName, mode: 'insensitive' } },
                    { lastName: { contains: searchName, mode: 'insensitive' } },
                    { company: { contains: searchName, mode: 'insensitive' } },
                  ] : [
                    { firstName: { equals: searchName, mode: 'insensitive' } },
                    { lastName: { equals: searchName, mode: 'insensitive' } },
                    { company: { equals: searchName, mode: 'insensitive' } },
                  ],
                },
                take: 5,
                select: {
                  id: true,
                  firstName: true,
                  lastName: true,
                  company: true,
                  email: true,
                  status: true,
                },
              });
              results = leads.map(l => ({
                id: l.id,
                name: `${l.firstName} ${l.lastName}`,
                company: l.company,
                email: l.email,
                status: l.status,
                entityRef: `lead:${l.id}`,
              }));
              break;
            }
            case 'contact': {
              const contacts = await this.prisma.contact.findMany({
                where: {
                  ownerId: userId,
                  OR: fuzzyMatch ? [
                    { firstName: { contains: searchName, mode: 'insensitive' } },
                    { lastName: { contains: searchName, mode: 'insensitive' } },
                  ] : [
                    { firstName: { equals: searchName, mode: 'insensitive' } },
                    { lastName: { equals: searchName, mode: 'insensitive' } },
                  ],
                },
                take: 5,
                include: { account: { select: { name: true } } },
              });
              results = contacts.map(c => ({
                id: c.id,
                name: `${c.firstName} ${c.lastName}`,
                company: c.account?.name || 'N/A',
                email: c.email,
                title: c.title,
                entityRef: `contact:${c.id}`,
              }));
              break;
            }
            case 'account': {
              const accounts = await this.prisma.account.findMany({
                where: {
                  ownerId: userId,
                  name: fuzzyMatch
                    ? { contains: searchName, mode: 'insensitive' }
                    : { equals: searchName, mode: 'insensitive' },
                },
                take: 5,
                select: {
                  id: true,
                  name: true,
                  type: true,
                  industry: true,
                  website: true,
                },
              });
              results = accounts.map(a => ({
                id: a.id,
                name: a.name,
                type: a.type,
                industry: a.industry,
                website: a.website,
                entityRef: `account:${a.id}`,
              }));
              break;
            }
            case 'opportunity': {
              const opportunities = await this.prisma.opportunity.findMany({
                where: {
                  ownerId: userId,
                  OR: fuzzyMatch ? [
                    { name: { contains: searchName, mode: 'insensitive' } },
                    { account: { name: { contains: searchName, mode: 'insensitive' } } },
                  ] : [
                    { name: { equals: searchName, mode: 'insensitive' } },
                    { account: { name: { equals: searchName, mode: 'insensitive' } } },
                  ],
                },
                take: 5,
                include: { account: { select: { name: true } } },
              });
              results = opportunities.map(o => ({
                id: o.id,
                name: o.name,
                accountName: o.account?.name || 'N/A',
                amount: o.amount,
                stage: o.stage,
                entityRef: `opportunity:${o.id}`,
              }));
              break;
            }
          }

          if (results.length === 0) {
            return {
              success: false,
              message: `No ${entityTypeLabel} found matching "${name}". Please check the spelling or try a different search term.`,
              suggestions: [
                `Try searching for a partial name`,
                `Use search_${entityType}s to browse available records`,
                `Create a new ${entityType} if it doesn't exist`,
              ],
            };
          }

          if (results.length === 1) {
            return {
              success: true,
              message: `Found ${entityTypeLabel}: ${results[0].name}`,
              exactMatch: true,
              entity: results[0],
              entityId: results[0].id,
              entityRef: results[0].entityRef,
            };
          }

          return {
            success: true,
            message: `Found ${results.length} ${entityTypeLabel}s matching "${name}". Please specify which one:`,
            exactMatch: false,
            matches: results,
            instruction: `Use the entityRef (e.g., "${results[0].entityRef}") for the relatedTo parameter in your next action.`,
          };
        }

        // LEAD OPERATIONS
        case 'create_lead': {
          try {
            const leadDto = {
              firstName: toolInput.firstName,
              lastName: toolInput.lastName,
              company: toolInput.company,
              email: toolInput.email,
              phone: toolInput.phone,
              title: toolInput.title,
              industry: toolInput.industry,
            };

            const lead = await this.leadsService.create(userId, leadDto, organizationId);

            const fieldsSet = Object.keys(leadDto).filter(k => leadDto[k] !== undefined && leadDto[k] !== null);
            const recordName = `${lead.firstName} ${lead.lastName}`;

            const facts: RecordCreateFacts = {
              action_completed: true,
              record_created: true,
              record_id: lead.id,
              record_type: 'Lead',
              record_name: recordName,
              fields_set: fieldsSet,
              duplicate_detected: false,
            };

            const verified_response = `Lead "${recordName}" created successfully.
- ID: ${lead.id}
- Company: ${lead.company}
- Fields set: ${fieldsSet.join(', ')}`;

            return createHighRiskResult(true, facts, verified_response, {
              leadId: lead.id,
              name: recordName,
              company: lead.company,
              leadScore: lead.leadScore,
              buyingIntent: lead.buyingIntent,
              status: lead.status,
            });
          } catch (error) {
            const facts: RecordCreateFacts = {
              action_completed: false,
              record_created: false,
              record_type: 'Lead',
              fields_set: [],
              validation_errors: [error.message],
            };
            return createHighRiskResult(false, facts, `Failed to create Lead: ${error.message}`);
          }
        }

        case 'search_leads': {
          const limit = toolInput.limit || 10;

          // RESPECT dataSource parameter - only use Salesforce if explicitly requested
          const shouldUseSalesforceLeads = dataSource === 'salesforce';
          const sfStatusLeads = shouldUseSalesforceLeads
            ? await this.salesforceService.getConnectionStatus(userId)
            : { connected: false };

          if (shouldUseSalesforceLeads && sfStatusLeads.connected) {
            try {
              // Build SOQL WHERE clause based on filters
              const conditions: string[] = ['IsConverted = false'];
              if (toolInput.name) {
                // Search in FirstName, LastName, or full name (FirstName + LastName)
                const nameSearch = toolInput.name.replace(/'/g, "\\'");
                conditions.push(`(FirstName LIKE '%${nameSearch}%' OR LastName LIKE '%${nameSearch}%' OR Name LIKE '%${nameSearch}%')`);
              }
              if (toolInput.status) conditions.push(`Status = '${toolInput.status}'`);
              if (toolInput.rating) conditions.push(`Rating = '${toolInput.rating}'`);

              const soql = `SELECT Id, FirstName, LastName, Company, Email, Title, Status, Rating, LeadSource, Industry, Phone
                            FROM Lead
                            ${conditions.length > 0 ? 'WHERE ' + conditions.join(' AND ') : ''}
                            ORDER BY CreatedDate DESC
                            LIMIT ${limit * 2}`;

              const result = await this.salesforceService.query(userId, soql);
              const sfLeads = result.records || [];

              // Map Rating to score
              const ratingToScore = (rating: string): number => {
                switch (rating?.toLowerCase()) {
                  case 'hot': return 90;
                  case 'warm': return 70;
                  case 'cold': return 40;
                  default: return 50;
                }
              };

              // Filter by minScore if provided
              let mappedLeads = sfLeads.map((l: any) => ({
                id: l.Id,
                name: `${l.FirstName || ''} ${l.LastName || ''}`.trim(),
                company: l.Company,
                email: l.Email,
                title: l.Title,
                score: ratingToScore(l.Rating),
                status: l.Status,
                rating: l.Rating,
                industry: l.Industry,
                phone: l.Phone,
              }));

              if (toolInput.minScore) {
                mappedLeads = mappedLeads.filter(l => l.score >= toolInput.minScore);
              }

              return {
                success: true,
                count: mappedLeads.length,
                showing: Math.min(mappedLeads.length, limit),
                data: mappedLeads.slice(0, limit),
                source: 'salesforce',
              };
            } catch (sfError) {
              this.logger.warn(`Salesforce search_leads query failed, falling back to local: ${sfError.message}`);
              // Fall through to local database query only if not explicitly requesting salesforce
              if (dataSource === 'salesforce') {
                return {
                  success: false,
                  error: `Salesforce query failed: ${sfError.message}`,
                  source: 'salesforce',
                };
              }
            }
          } else if (dataSource === 'salesforce' && !sfStatusLeads.connected) {
            return {
              success: false,
              error: 'Salesforce is not connected. Please connect your Salesforce account.',
              source: 'salesforce',
            };
          }

          // Local database query
          const leadsResult = await this.leadsService.findAll(userId, organizationId, {
            name: toolInput.name,
            status: toolInput.status,
            rating: toolInput.rating,
            minScore: toolInput.minScore,
          }, false);
          const leads = Array.isArray(leadsResult) ? leadsResult : leadsResult.data;

          return {
            success: true,
            count: leads.length,
            showing: Math.min(leads.length, limit),
            data: leads.slice(0, limit).map(l => ({
              id: l.id,
              name: `${l.firstName} ${l.lastName}`,
              company: l.company,
              email: l.email,
              title: l.title,
              score: l.leadScore,
              buyingIntent: l.buyingIntent,
              status: l.status,
              rating: l.rating,
            })),
            source: 'local',
          };
        }

        case 'get_lead_details': {
          // Check if the leadId is a Salesforce ID and query Salesforce if so
          const { target: leadDetailTarget } = determineOperationTarget(toolInput.leadId);

          if (leadDetailTarget === 'salesforce') {
            try {
              const sfStatusLeadDetail = await this.salesforceService.getConnectionStatus(userId);
              if (sfStatusLeadDetail.connected && sfStatusLeadDetail.connection) {
                // Query Lead with related Tasks and Events (activities)
                const soql = `SELECT Id, FirstName, LastName, Company, Email, Phone, Title, Industry,
                              LeadSource, Status, Rating, Description, Website, Street, City, State,
                              PostalCode, Country, NumberOfEmployees, AnnualRevenue, CreatedDate, LastModifiedDate,
                              ConvertedDate, ConvertedAccountId, ConvertedContactId, ConvertedOpportunityId, IsConverted,
                              (SELECT Id, Subject, Status, Priority, ActivityDate, Description, CreatedDate, LastModifiedDate
                               FROM Tasks ORDER BY CreatedDate DESC LIMIT 50),
                              (SELECT Id, Subject, StartDateTime, EndDateTime, Description, CreatedDate, LastModifiedDate
                               FROM Events ORDER BY StartDateTime DESC LIMIT 50)
                              FROM Lead WHERE Id = '${toolInput.leadId}'`;
                const result = await this.salesforceService.query(userId, soql);

                if (result.records && result.records.length > 0) {
                  const sfLead = result.records[0];

                  // Extract and format activities (Tasks and Events)
                  const tasks = sfLead.Tasks?.records || [];
                  const events = sfLead.Events?.records || [];
                  const activities = [
                    ...tasks.map((t: any) => ({
                      id: t.Id,
                      type: 'Task',
                      subject: t.Subject,
                      status: t.Status,
                      priority: t.Priority,
                      dueDate: t.ActivityDate,
                      description: t.Description,
                      createdAt: t.CreatedDate,
                      updatedAt: t.LastModifiedDate,
                    })),
                    ...events.map((e: any) => ({
                      id: e.Id,
                      type: 'Event',
                      subject: e.Subject,
                      startDateTime: e.StartDateTime,
                      endDateTime: e.EndDateTime,
                      description: e.Description,
                      createdAt: e.CreatedDate,
                      updatedAt: e.LastModifiedDate,
                    })),
                  ].sort((a, b) => new Date(b.createdAt).getTime() - new Date(a.createdAt).getTime());

                  return {
                    success: true,
                    source: 'salesforce',
                    data: {
                      id: sfLead.Id,
                      name: `${sfLead.FirstName || ''} ${sfLead.LastName || ''}`.trim(),
                      firstName: sfLead.FirstName,
                      lastName: sfLead.LastName,
                      company: sfLead.Company,
                      email: sfLead.Email,
                      phone: sfLead.Phone,
                      title: sfLead.Title,
                      industry: sfLead.Industry,
                      leadSource: sfLead.LeadSource,
                      status: sfLead.Status,
                      rating: sfLead.Rating,
                      description: sfLead.Description,
                      website: sfLead.Website,
                      address: {
                        street: sfLead.Street,
                        city: sfLead.City,
                        state: sfLead.State,
                        postalCode: sfLead.PostalCode,
                        country: sfLead.Country,
                      },
                      numberOfEmployees: sfLead.NumberOfEmployees,
                      annualRevenue: sfLead.AnnualRevenue,
                      isConverted: sfLead.IsConverted,
                      convertedDate: sfLead.ConvertedDate,
                      convertedAccountId: sfLead.ConvertedAccountId,
                      convertedContactId: sfLead.ConvertedContactId,
                      convertedOpportunityId: sfLead.ConvertedOpportunityId,
                      createdAt: sfLead.CreatedDate,
                      updatedAt: sfLead.LastModifiedDate,
                      activities: activities,
                      tasksCount: tasks.length,
                      eventsCount: events.length,
                    },
                  };
                }
              }
            } catch (sfError) {
              this.logger.warn(`Salesforce lead detail query failed: ${sfError.message}`);
            }
            // If Salesforce query fails, return error since we know this is a Salesforce ID
            return {
              success: false,
              error: `Lead with Salesforce ID ${toolInput.leadId} not found or Salesforce connection unavailable`,
              hint: 'Make sure your Salesforce is connected and the lead exists',
            };
          }

          // Local database lookup for local IDs
          const lead = await this.leadsService.findOne(toolInput.leadId, userId, organizationId, false);
          return {
            success: true,
            source: 'local',
            data: {
              id: lead.id,
              name: `${lead.firstName} ${lead.lastName}`,
              company: lead.company,
              email: lead.email,
              phone: lead.phone,
              title: lead.title,
              industry: lead.industry,
              leadSource: lead.leadSource,
              status: lead.status,
              rating: lead.rating,
              leadScore: lead.leadScore,
              buyingIntent: lead.buyingIntent,
              painPoints: lead.painPoints,
              budget: lead.budget,
              timeline: lead.timeline,
              convertedDate: lead.convertedDate,
            },
          };
        }

        case 'update_lead': {
          // Detect if the leadId is a Salesforce ID and route appropriately
          const { target: updateLeadTarget } = determineOperationTarget(toolInput.leadId);

          if (updateLeadTarget === 'salesforce') {
            try {
              const sfLeadData: any = {};
              if (toolInput.status) sfLeadData.Status = toolInput.status;
              if (toolInput.rating) sfLeadData.Rating = toolInput.rating;

              if (Object.keys(sfLeadData).length === 0) {
                return { success: false, error: 'No fields provided to update' };
              }

              // Get current values before update for comparison
              const beforeQuery = `SELECT Id, FirstName, LastName, Status, Rating FROM Lead WHERE Id = '${toolInput.leadId}'`;
              const beforeResult = await this.salesforceService.query(userId, beforeQuery);
              const beforeSfLead = beforeResult.records?.[0];

              await this.salesforceService.update(userId, 'Lead', toolInput.leadId, sfLeadData);

              // Add note if provided (as a Salesforce Task/Note)
              if (toolInput.notes) {
                try {
                  await this.salesforceService.create(userId, 'Note', {
                    ParentId: toolInput.leadId,
                    Title: 'Update Note',
                    Body: toolInput.notes,
                  });
                } catch {
                  // Note creation is optional, don't fail the update
                }
              }

              // Determine what actually changed
              const sfChangedFields: string[] = [];
              const sfPreviousValues: Record<string, any> = {};
              const sfNewValues: Record<string, any> = {};

              if (sfLeadData.Status && beforeSfLead?.Status !== sfLeadData.Status) {
                sfChangedFields.push('Status');
                sfPreviousValues.Status = beforeSfLead?.Status || 'Not set';
                sfNewValues.Status = sfLeadData.Status;
              }
              if (sfLeadData.Rating && beforeSfLead?.Rating !== sfLeadData.Rating) {
                sfChangedFields.push('Rating');
                sfPreviousValues.Rating = beforeSfLead?.Rating || 'Not set';
                sfNewValues.Rating = sfLeadData.Rating;
              }

              const sfLeadName = beforeSfLead ? `${beforeSfLead.FirstName || ''} ${beforeSfLead.LastName || ''}`.trim() : toolInput.leadId;

              const sfFacts: RecordUpdateFacts = {
                action_completed: true,
                record_updated: sfChangedFields.length > 0,
                record_id: toolInput.leadId,
                record_type: 'Lead',
                record_name: sfLeadName,
                fields_changed: sfChangedFields,
                previous_values: sfPreviousValues,
                new_values: sfNewValues,
              };

              let sfVerifiedResponse: string;
              if (sfChangedFields.length > 0) {
                const changes = sfChangedFields.map(f => `${f}: "${sfPreviousValues[f]}" -> "${sfNewValues[f]}"`).join(', ');
                sfVerifiedResponse = `Salesforce Lead "${sfLeadName}" updated.\n- Changes: ${changes}`;
                if (sfChangedFields.includes('Status')) {
                  sfVerifiedResponse += `\n- Status changed: ${sfPreviousValues.Status} -> ${sfNewValues.Status}`;
                }
              } else {
                sfVerifiedResponse = `No changes made to Salesforce Lead "${sfLeadName}" - values were already set.`;
              }

              return createHighRiskResult(true, sfFacts, sfVerifiedResponse, {
                leadId: toolInput.leadId,
                updatedFields: sfChangedFields,
                values: sfLeadData,
                source: 'salesforce',
              });
            } catch (error) {
              const errorFacts: RecordUpdateFacts = {
                action_completed: false,
                record_updated: false,
                record_id: toolInput.leadId,
                record_type: 'Lead',
                fields_changed: [],
                previous_values: {},
                new_values: {},
              };
              return createHighRiskResult(false, errorFacts, `Failed to update Salesforce Lead: ${error.message}`, undefined, error.message);
            }
          }

          // Local database update (original behavior)
          // First get the current values for comparison
          const beforeLead = await this.prisma.lead.findUnique({ where: { id: toolInput.leadId } });

          const updateLeadData: any = {};
          if (toolInput.status) updateLeadData.status = toolInput.status;
          if (toolInput.rating) updateLeadData.rating = toolInput.rating;

          const lead = await this.leadsService.update(toolInput.leadId, userId, organizationId, updateLeadData, false);

          if (toolInput.notes) {
            await this.prisma.note.create({
              data: {
                userId: userId,
                leadId: toolInput.leadId,
                title: 'Update Note',
                body: toolInput.notes,
              },
            });
          }

          // Determine what actually changed
          const leadChangedFields = Object.keys(updateLeadData).filter(k =>
            updateLeadData[k] !== undefined && beforeLead && beforeLead[k] !== updateLeadData[k]
          );

          const leadName = `${lead.firstName} ${lead.lastName}`;

          const leadFacts: RecordUpdateFacts = {
            action_completed: true,
            record_updated: leadChangedFields.length > 0,
            record_id: lead.id,
            record_type: 'Lead',
            record_name: leadName,
            fields_changed: leadChangedFields,
            previous_values: leadChangedFields.reduce((acc, f) => ({ ...acc, [f]: beforeLead?.[f] }), {}),
            new_values: leadChangedFields.reduce((acc, f) => ({ ...acc, [f]: lead[f] }), {}),
          };

          let leadVerifiedResponse: string;
          if (leadChangedFields.length > 0) {
            const changes = leadChangedFields.map(f => `${f}: "${leadFacts.previous_values[f]}" -> "${leadFacts.new_values[f]}"`).join(', ');
            leadVerifiedResponse = `Lead "${leadName}" updated.\n- Changes: ${changes}`;
            if (leadChangedFields.includes('status')) {
              leadVerifiedResponse += `\n- Status changed: ${leadFacts.previous_values.status} -> ${leadFacts.new_values.status}`;
            }
          } else {
            leadVerifiedResponse = `No changes made to Lead "${leadName}" - values were already set.`;
          }

          return createHighRiskResult(true, leadFacts, leadVerifiedResponse, {
            leadId: lead.id,
            status: lead.status,
            rating: lead.rating,
            source: 'local',
          });
        }

        case 'qualify_lead': {
          // Qualify lead by updating isQualified flag
          const lead = await this.leadsService.update(toolInput.leadId, userId, organizationId, { isQualified: true }, false);
          return {
            success: true,
            message: `Lead qualified and ready for conversion`,
            data: {
              leadId: lead.id,
              status: lead.status,
              leadScore: lead.leadScore,
            },
          };
        }

        case 'convert_lead': {
          const convertData: any = {
            createAccount: true,
            createContact: true,
          };
          if (toolInput.createOpportunity) {
            convertData.createOpportunity = true;
            convertData.opportunityAmount = toolInput.opportunityAmount;
          }

          const result = await this.leadsService.convertLead(toolInput.leadId, userId, organizationId, convertData, false);
          return {
            success: true,
            message: `Lead converted successfully`,
            data: {
              accountId: result.accountId,
              contactId: result.contactId,
              opportunityId: result.opportunityId,
            },
          };
        }

        case 'get_top_leads': {
          const limit = toolInput.limit || 5;

          // RESPECT dataSource parameter - only use Salesforce if explicitly requested
          const shouldUseSalesforceTopLeads = dataSource === 'salesforce';
          const sfStatus = shouldUseSalesforceTopLeads
            ? await this.salesforceService.getConnectionStatus(userId)
            : { connected: false };

          if (shouldUseSalesforceTopLeads && sfStatus.connected) {
            try {
              // Query Salesforce for leads, ordered by Rating and Status
              const soql = `SELECT Id, FirstName, LastName, Company, Email, Title, Status, Rating, LeadSource, Industry, Phone
                            FROM Lead
                            WHERE IsConverted = false
                            ORDER BY Rating DESC NULLS LAST, CreatedDate DESC
                            LIMIT ${limit * 2}`;

              const result = await this.salesforceService.query(userId, soql);
              const sfLeads = result.records || [];

              if (sfLeads.length === 0) {
                return {
                  success: true,
                  message: 'No leads found in Salesforce',
                  data: [],
                  count: 0,
                  source: 'salesforce',
                };
              }

              // Map Rating to score (Hot=90, Warm=70, Cold=40)
              const ratingToScore = (rating: string): number => {
                switch (rating?.toLowerCase()) {
                  case 'hot': return 90;
                  case 'warm': return 70;
                  case 'cold': return 40;
                  default: return 50;
                }
              };

              const mappedLeads = sfLeads
                .map((l: any) => ({
                  id: l.Id,
                  name: `${l.FirstName || ''} ${l.LastName || ''}`.trim(),
                  company: l.Company,
                  email: l.Email,
                  title: l.Title,
                  score: ratingToScore(l.Rating),
                  status: l.Status,
                  rating: l.Rating,
                  industry: l.Industry,
                  phone: l.Phone,
                }))
                .sort((a, b) => b.score - a.score)
                .slice(0, limit);

              return {
                success: true,
                message: `Found ${mappedLeads.length} leads from Salesforce`,
                data: mappedLeads,
                count: sfLeads.length,
                source: 'salesforce',
              };
            } catch (sfError) {
              this.logger.warn(`Salesforce query failed, falling back to local: ${sfError.message}`);
              // Only fall through to local if not explicitly requesting salesforce
              if (dataSource === 'salesforce') {
                return {
                  success: false,
                  error: `Salesforce query failed: ${sfError.message}`,
                  source: 'salesforce',
                };
              }
            }
          } else if (dataSource === 'salesforce' && !sfStatus.connected) {
            return {
              success: false,
              error: 'Salesforce is not connected. Please connect your Salesforce account.',
              source: 'salesforce',
            };
          }

          // Local database query
          const allLeadsResult = await this.leadsService.findAll(userId, organizationId, {}, false);
          const allLeads = Array.isArray(allLeadsResult) ? allLeadsResult : allLeadsResult.data;

          if (allLeads.length === 0) {
            return {
              success: true,
              message: 'No leads found in the system',
              data: [],
              count: 0,
              source: 'local',
            };
          }

          // Now filter for high-scoring leads
          const highScoringLeadsResult = await this.leadsService.findAll(userId, organizationId, {
            minScore: 70,
          }, false);
          const highScoringLeads = Array.isArray(highScoringLeadsResult) ? highScoringLeadsResult : highScoringLeadsResult.data;

          const sortedLeads = highScoringLeads
            .sort((a, b) => (b.leadScore || 0) - (a.leadScore || 0))
            .slice(0, limit);

          if (sortedLeads.length === 0) {
            return {
              success: true,
              message: `You have ${allLeads.length} leads in the system, but none have a score of 70 or higher yet`,
              data: [],
              count: allLeads.length,
              avgScore: Math.round(allLeads.reduce((sum, l) => sum + (l.leadScore || 0), 0) / allLeads.length),
              source: 'local',
            };
          }

          return {
            success: true,
            message: `Found ${sortedLeads.length} high-scoring leads (out of ${allLeads.length} total leads)`,
            data: sortedLeads.map(l => ({
              id: l.id,
              name: `${l.firstName} ${l.lastName}`,
              company: l.company,
              email: l.email,
              title: l.title,
              score: l.leadScore,
              buyingIntent: l.buyingIntent,
              status: l.status,
              rating: l.rating,
            })),
            count: allLeads.length,
            source: 'local',
          };
        }

        // OPPORTUNITY OPERATIONS
        case 'get_pipeline_stats': {
          // RESPECT dataSource parameter - only use Salesforce if explicitly requested
          const shouldUseSalesforcePipeline = dataSource === 'salesforce';
          const sfStatusPipeline = shouldUseSalesforcePipeline
            ? await this.salesforceService.getConnectionStatus(userId)
            : { connected: false };

          if (shouldUseSalesforcePipeline && sfStatusPipeline.connected) {
            try {
              // Get pipeline stats from Salesforce
              const soql = `SELECT StageName, COUNT(Id) count, SUM(Amount) totalAmount
                            FROM Opportunity
                            WHERE IsClosed = false
                            GROUP BY StageName`;

              const result = await this.salesforceService.query(userId, soql);
              const stageStats = result.records || [];

              // Calculate totals
              let totalValue = 0;
              let totalCount = 0;
              const stages: any[] = [];

              for (const stage of stageStats) {
                totalValue += stage.totalAmount || 0;
                totalCount += stage.count || 0;
                stages.push({
                  stage: stage.StageName,
                  count: stage.count,
                  totalAmount: stage.totalAmount || 0,
                });
              }

              return {
                success: true,
                data: {
                  totalValue,
                  totalCount,
                  stages,
                  avgDealSize: totalCount > 0 ? Math.round(totalValue / totalCount) : 0,
                },
                source: 'salesforce',
              };
            } catch (sfError) {
              this.logger.warn(`Salesforce pipeline stats query failed, falling back to local: ${sfError.message}`);
              if (dataSource === 'salesforce') {
                return {
                  success: false,
                  error: `Salesforce query failed: ${sfError.message}`,
                  source: 'salesforce',
                };
              }
            }
          } else if (dataSource === 'salesforce' && !sfStatusPipeline.connected) {
            return {
              success: false,
              error: 'Salesforce is not connected. Please connect your Salesforce account.',
              source: 'salesforce',
            };
          }

          // Local database query
          const stats = await this.opportunitiesService.getPipelineStats(organizationId, userId, false);
          return {
            success: true,
            data: stats,
            source: 'local',
          };
        }

        case 'search_opportunities': {
          const limit = toolInput.limit || 10;

          // RESPECT dataSource parameter - only use Salesforce if explicitly requested
          const shouldUseSalesforceOpps = dataSource === 'salesforce';
          const sfStatusOpps = shouldUseSalesforceOpps
            ? await this.salesforceService.getConnectionStatus(userId)
            : { connected: false };

          if (shouldUseSalesforceOpps && sfStatusOpps.connected) {
            try {
              // Build SOQL WHERE clause based on filters
              const conditions: string[] = ['IsClosed = false'];
              if (toolInput.stage) conditions.push(`StageName = '${toolInput.stage}'`);
              if (toolInput.minAmount) conditions.push(`Amount >= ${toolInput.minAmount}`);

              // Handle close date filtering
              if (toolInput.closeDate) {
                const now = new Date();
                if (toolInput.closeDate === 'this_month') {
                  const endOfMonth = new Date(now.getFullYear(), now.getMonth() + 1, 0);
                  conditions.push(`CloseDate <= ${endOfMonth.toISOString().split('T')[0]}`);
                } else if (toolInput.closeDate === 'this_quarter') {
                  const endOfQuarter = new Date(now.getFullYear(), Math.floor(now.getMonth() / 3) * 3 + 3, 0);
                  conditions.push(`CloseDate <= ${endOfQuarter.toISOString().split('T')[0]}`);
                }
              }

              const soql = `SELECT Id, Name, StageName, Amount, Probability, CloseDate, Account.Name, Type
                            FROM Opportunity
                            ${conditions.length > 0 ? 'WHERE ' + conditions.join(' AND ') : ''}
                            ORDER BY Amount DESC NULLS LAST
                            LIMIT ${limit * 2}`;

              const result = await this.salesforceService.query(userId, soql);
              const sfOpps = result.records || [];

              const mappedOpps = sfOpps.map((o: any) => ({
                id: o.Id,
                name: o.Name,
                accountName: o.Account?.Name,
                stage: o.StageName,
                amount: o.Amount,
                probability: o.Probability,
                closeDate: o.CloseDate,
                type: o.Type,
              }));

              return {
                success: true,
                count: mappedOpps.length,
                showing: Math.min(mappedOpps.length, limit),
                data: mappedOpps.slice(0, limit),
                source: 'salesforce',
              };
            } catch (sfError) {
              this.logger.warn(`Salesforce search_opportunities query failed, falling back to local: ${sfError.message}`);
              // Fall through to local database query
            }
          }

          // Local database fallback
          const opportunitiesResult = await this.opportunitiesService.listOpportunities({
            stage: toolInput.stage,
            ownerId: userId,
          }, organizationId, false);
          const opportunities = Array.isArray(opportunitiesResult) ? opportunitiesResult : opportunitiesResult.data;

          let filtered = opportunities;

          if (toolInput.minAmount) {
            filtered = filtered.filter(o => (o.amount || 0) >= toolInput.minAmount);
          }

          if (toolInput.closeDate) {
            const now = new Date();
            const endOfMonth = new Date(now.getFullYear(), now.getMonth() + 1, 0);
            const endOfQuarter = new Date(now.getFullYear(), Math.floor(now.getMonth() / 3) * 3 + 3, 0);

            if (toolInput.closeDate === 'this_month') {
              filtered = filtered.filter(o => o.closeDate && new Date(o.closeDate) <= endOfMonth);
            } else if (toolInput.closeDate === 'this_quarter') {
              filtered = filtered.filter(o => o.closeDate && new Date(o.closeDate) <= endOfQuarter);
            }
          }

          return {
            success: true,
            count: filtered.length,
            showing: Math.min(filtered.length, limit),
            data: filtered.slice(0, limit).map((o: any) => ({
              id: o.id,
              name: o.name,
              accountName: o.account?.name,
              stage: o.stage,
              amount: o.amount,
              probability: o.probability,
              closeDate: o.closeDate,
              winProbability: o.winProbability,
            })),
            source: 'local',
          };
        }

        case 'get_opportunity_details': {
          // Check if the opportunityId is a Salesforce ID and query Salesforce if so
          const { target: oppDetailTarget } = determineOperationTarget(toolInput.opportunityId);

          if (oppDetailTarget === 'salesforce') {
            try {
              const sfStatusOppDetail = await this.salesforceService.getConnectionStatus(userId);
              if (sfStatusOppDetail.connected && sfStatusOppDetail.connection) {
                const soql = `SELECT Id, Name, AccountId, Account.Name, StageName, Amount, Probability,
                              ExpectedRevenue, CloseDate, Type, NextStep, Description, LeadSource,
                              IsClosed, IsWon, ForecastCategory, ForecastCategoryName,
                              CreatedDate, LastModifiedDate
                              FROM Opportunity WHERE Id = '${toolInput.opportunityId}'`;
                const result = await this.salesforceService.query(userId, soql);

                if (result.records && result.records.length > 0) {
                  const sfOpp = result.records[0];
                  return {
                    success: true,
                    source: 'salesforce',
                    data: {
                      id: sfOpp.Id,
                      name: sfOpp.Name,
                      accountId: sfOpp.AccountId,
                      accountName: sfOpp.Account?.Name,
                      stage: sfOpp.StageName,
                      amount: sfOpp.Amount,
                      probability: sfOpp.Probability,
                      expectedRevenue: sfOpp.ExpectedRevenue,
                      closeDate: sfOpp.CloseDate,
                      type: sfOpp.Type,
                      nextStep: sfOpp.NextStep,
                      description: sfOpp.Description,
                      leadSource: sfOpp.LeadSource,
                      forecastCategory: sfOpp.ForecastCategoryName || sfOpp.ForecastCategory,
                      isClosed: sfOpp.IsClosed,
                      isWon: sfOpp.IsWon,
                      createdAt: sfOpp.CreatedDate,
                      updatedAt: sfOpp.LastModifiedDate,
                    },
                  };
                }
              }
            } catch (sfError) {
              this.logger.warn(`Salesforce opportunity detail query failed: ${sfError.message}`);
            }
            return {
              success: false,
              error: `Opportunity with Salesforce ID ${toolInput.opportunityId} not found or Salesforce connection unavailable`,
              hint: 'Make sure your Salesforce is connected and the opportunity exists',
            };
          }

          // Local database lookup for local IDs
          const opp = await this.opportunitiesService.getOpportunity(toolInput.opportunityId, userId, organizationId, false);
          return {
            success: true,
            source: 'local',
            data: {
              id: opp.id,
              name: opp.name,
              accountId: opp.accountId,
              accountName: opp.account?.name,
              stage: opp.stage,
              amount: opp.amount,
              probability: opp.probability,
              expectedRevenue: opp.expectedRevenue,
              closeDate: opp.closeDate,
              type: opp.type,
              nextStep: opp.nextStep,
              winProbability: opp.winProbability,
              riskFactors: opp.riskFactors,
              recommendedActions: opp.recommendedActions,
              isClosed: opp.isClosed,
              isWon: opp.isWon,
            },
          };
        }

        case 'update_opportunity': {
          // Detect if the opportunityId is a Salesforce ID and route appropriately
          const { target: updateOppTarget } = determineOperationTarget(toolInput.opportunityId);

          if (updateOppTarget === 'salesforce') {
            try {
              const sfOppData: any = {};
              if (toolInput.stage) sfOppData.StageName = toolInput.stage;
              if (toolInput.amount) sfOppData.Amount = toolInput.amount;
              if (toolInput.closeDate) sfOppData.CloseDate = toolInput.closeDate;

              if (Object.keys(sfOppData).length === 0) {
                return { success: false, error: 'No fields provided to update' };
              }

              // Get current values before update for comparison
              const beforeOppQuery = `SELECT Id, Name, StageName, Amount, CloseDate FROM Opportunity WHERE Id = '${toolInput.opportunityId}'`;
              const beforeOppResult = await this.salesforceService.query(userId, beforeOppQuery);
              const beforeSfOpp = beforeOppResult.records?.[0];

              await this.salesforceService.update(userId, 'Opportunity', toolInput.opportunityId, sfOppData);

              // Add note if provided
              if (toolInput.notes) {
                try {
                  await this.salesforceService.create(userId, 'Note', {
                    ParentId: toolInput.opportunityId,
                    Title: 'Update Note',
                    Body: toolInput.notes,
                  });
                } catch {
                  // Note creation is optional
                }
              }

              // Determine what actually changed
              const sfOppChangedFields: string[] = [];
              const sfOppPreviousValues: Record<string, any> = {};
              const sfOppNewValues: Record<string, any> = {};

              Object.keys(sfOppData).forEach(field => {
                if (beforeSfOpp?.[field] !== sfOppData[field]) {
                  sfOppChangedFields.push(field);
                  sfOppPreviousValues[field] = beforeSfOpp?.[field] || 'Not set';
                  sfOppNewValues[field] = sfOppData[field];
                }
              });

              const sfOppName = beforeSfOpp?.Name || toolInput.opportunityId;

              const sfOppFacts: RecordUpdateFacts = {
                action_completed: true,
                record_updated: sfOppChangedFields.length > 0,
                record_id: toolInput.opportunityId,
                record_type: 'Opportunity',
                record_name: sfOppName,
                fields_changed: sfOppChangedFields,
                previous_values: sfOppPreviousValues,
                new_values: sfOppNewValues,
              };

              let sfOppVerifiedResponse: string;
              if (sfOppChangedFields.length > 0) {
                const changes = sfOppChangedFields.map(f => `${f}: "${sfOppPreviousValues[f]}" -> "${sfOppNewValues[f]}"`).join(', ');
                sfOppVerifiedResponse = `Salesforce Opportunity "${sfOppName}" updated.\n- Changes: ${changes}`;
                if (sfOppChangedFields.includes('StageName')) {
                  sfOppVerifiedResponse += `\n- Stage changed: ${sfOppPreviousValues.StageName} -> ${sfOppNewValues.StageName}`;
                }
              } else {
                sfOppVerifiedResponse = `No changes made to Salesforce Opportunity "${sfOppName}" - values were already set.`;
              }

              return createHighRiskResult(true, sfOppFacts, sfOppVerifiedResponse, {
                opportunityId: toolInput.opportunityId,
                updatedFields: sfOppChangedFields,
                values: sfOppData,
                source: 'salesforce',
              });
            } catch (error) {
              const errorOppFacts: RecordUpdateFacts = {
                action_completed: false,
                record_updated: false,
                record_id: toolInput.opportunityId,
                record_type: 'Opportunity',
                fields_changed: [],
                previous_values: {},
                new_values: {},
              };
              return createHighRiskResult(false, errorOppFacts, `Failed to update Salesforce Opportunity: ${error.message}`, undefined, error.message);
            }
          }

          // Local database update (original behavior)
          // First get the current values for comparison
          const beforeOpp = await this.prisma.opportunity.findUnique({ where: { id: toolInput.opportunityId } });

          const updateOppData: any = {};
          if (toolInput.stage) updateOppData.stage = toolInput.stage;
          if (toolInput.amount) updateOppData.amount = toolInput.amount;
          if (toolInput.closeDate) updateOppData.closeDate = new Date(toolInput.closeDate);

          const opp = await this.opportunitiesService.updateOpportunity(toolInput.opportunityId, userId, updateOppData, organizationId, false);

          if (toolInput.notes) {
            await this.prisma.note.create({
              data: {
                userId: userId,
                opportunityId: toolInput.opportunityId,
                title: 'Update Note',
                body: toolInput.notes,
              },
            });
          }

          // Determine what actually changed
          const oppChangedFields = Object.keys(updateOppData).filter(k =>
            updateOppData[k] !== undefined && beforeOpp && beforeOpp[k] !== updateOppData[k]
          );

          const oppFacts: RecordUpdateFacts = {
            action_completed: true,
            record_updated: oppChangedFields.length > 0,
            record_id: opp.id,
            record_type: 'Opportunity',
            record_name: opp.name,
            fields_changed: oppChangedFields,
            previous_values: oppChangedFields.reduce((acc, f) => ({ ...acc, [f]: beforeOpp?.[f] }), {}),
            new_values: oppChangedFields.reduce((acc, f) => ({ ...acc, [f]: opp[f] }), {}),
          };

          let oppVerifiedResponse: string;
          if (oppChangedFields.length > 0) {
            const changes = oppChangedFields.map(f => `${f}: "${oppFacts.previous_values[f]}" -> "${oppFacts.new_values[f]}"`).join(', ');
            oppVerifiedResponse = `Opportunity "${opp.name}" updated.\n- Changes: ${changes}`;
            if (oppChangedFields.includes('stage')) {
              oppVerifiedResponse += `\n- Stage changed: ${oppFacts.previous_values.stage} -> ${oppFacts.new_values.stage}`;
            }
          } else {
            oppVerifiedResponse = `No changes made to Opportunity "${opp.name}" - values were already set.`;
          }

          return createHighRiskResult(true, oppFacts, oppVerifiedResponse, {
            opportunityId: opp.id,
            stage: opp.stage,
            amount: opp.amount,
            closeDate: opp.closeDate,
            source: 'local',
          });
        }

        case 'create_opportunity': {
          // If accountId is provided, validate it's not a Salesforce ID
          if (toolInput.accountId) {
            const { target: accountTarget } = determineOperationTarget(toolInput.accountId);
            if (accountTarget === 'salesforce') {
              // Route to Salesforce opportunity creation
              try {
                const sfOppData: any = {
                  Name: toolInput.name,
                  AccountId: toolInput.accountId,
                  Amount: toolInput.amount,
                  StageName: toolInput.stage || 'Qualification',
                  CloseDate: toolInput.closeDate || new Date().toISOString().split('T')[0],
                  Description: toolInput.description,
                  Type: toolInput.type || 'New Business',
                };
                const result = await this.salesforceService.create(userId, 'Opportunity', sfOppData);

                const sfFieldsSet = Object.keys(sfOppData).filter(k => sfOppData[k] !== undefined && sfOppData[k] !== null);

                const sfFacts: RecordCreateFacts = {
                  action_completed: true,
                  record_created: true,
                  record_id: result.id,
                  record_type: 'Opportunity',
                  record_name: toolInput.name,
                  fields_set: sfFieldsSet,
                  duplicate_detected: false,
                };

                const sfVerified = `Salesforce Opportunity "${toolInput.name}" created successfully.
- ID: ${result.id}
- Account ID: ${toolInput.accountId}
- Amount: ${sfOppData.Amount || 'Not set'}
- Stage: ${sfOppData.StageName}
- Fields set: ${sfFieldsSet.join(', ')}`;

                return createHighRiskResult(true, sfFacts, sfVerified, {
                  opportunityId: result.id,
                  name: toolInput.name,
                  accountId: toolInput.accountId,
                  source: 'salesforce',
                });
              } catch (error) {
                const sfFacts: RecordCreateFacts = {
                  action_completed: false,
                  record_created: false,
                  record_type: 'Opportunity',
                  fields_set: [],
                  validation_errors: [error.message],
                };
                return createHighRiskResult(false, sfFacts, `Failed to create Salesforce Opportunity: ${error.message}`);
              }
            }
          }

          // Find or create the account
          let accountId = toolInput.accountId;

          if (!accountId && toolInput.accountName) {
            // Search for existing account
            const existingAccounts = await this.prisma.account.findMany({
              where: {
                name: { contains: toolInput.accountName, mode: 'insensitive' },
              },
              take: 1,
            });

            if (existingAccounts.length > 0) {
              accountId = existingAccounts[0].id;
            } else {
              // Create new account
              const newAccount = await this.prisma.account.create({
                data: {
                  name: toolInput.accountName,
                  ownerId: userId,
                  type: 'PROSPECT',
                },
              });
              accountId = newAccount.id;
            }
          }

          if (!accountId) {
            return {
              success: false,
              message: 'Account is required. Please provide an accountId or accountName.',
              data: null,
            };
          }

          // Parse close date
          let closeDate = toolInput.closeDate ? new Date(toolInput.closeDate) : new Date();
          if (isNaN(closeDate.getTime())) {
            closeDate = new Date();
            closeDate.setMonth(closeDate.getMonth() + 1); // Default to 1 month from now
          }

          // Parse amount - handle currency strings like "$9,975,000" or "9975000"
          let amount = 0;
          if (toolInput.amount !== undefined && toolInput.amount !== null) {
            if (typeof toolInput.amount === 'string') {
              // Remove currency symbols, commas, and spaces
              const cleanAmount = toolInput.amount.replace(/[$,\s]/g, '');
              amount = parseFloat(cleanAmount) || 0;
            } else {
              amount = Number(toolInput.amount) || 0;
            }
          }

          // Map stage to enum value
          const stageMapping: Record<string, string> = {
            'PROSPECTING': 'PROSPECTING',
            'QUALIFICATION': 'QUALIFICATION',
            'NEEDS_ANALYSIS': 'NEEDS_ANALYSIS',
            'VALUE_PROPOSITION': 'VALUE_PROPOSITION',
            'DECISION_MAKERS_IDENTIFIED': 'DECISION_MAKERS_IDENTIFIED',
            'PERCEPTION_ANALYSIS': 'PERCEPTION_ANALYSIS',
            'PROPOSAL_PRICE_QUOTE': 'PROPOSAL_PRICE_QUOTE',
            'PROPOSAL': 'PROPOSAL_PRICE_QUOTE',
            'NEGOTIATION_REVIEW': 'NEGOTIATION_REVIEW',
            'NEGOTIATION': 'NEGOTIATION_REVIEW',
          };

          const stage = stageMapping[toolInput.stage?.toUpperCase()] || 'QUALIFICATION';

          const opportunity = await this.opportunitiesService.createOpportunity({
            name: toolInput.name,
            accountId,
            amount: amount,
            closeDate,
            stage: stage as any,
            type: toolInput.type || 'NEW_BUSINESS',
            opportunitySource: toolInput.source,
            nextStep: toolInput.nextStep || 'Schedule discovery call',
          }, userId, organizationId);

          // Create a note with the description if provided
          if (toolInput.description) {
            await this.prisma.note.create({
              data: {
                userId: userId,
                opportunityId: opportunity.id,
                title: 'Opportunity Details',
                body: toolInput.description,
              },
            });
          }

          // Build list of fields that were actually set
          const oppFieldsSet: string[] = ['name', 'accountId', 'amount', 'closeDate', 'stage'];
          if (toolInput.type) oppFieldsSet.push('type');
          if (toolInput.source) oppFieldsSet.push('source');
          if (toolInput.nextStep) oppFieldsSet.push('nextStep');
          if (toolInput.description) oppFieldsSet.push('description (as note)');

          const oppFacts: RecordCreateFacts = {
            action_completed: true,
            record_created: true,
            record_id: opportunity.id,
            record_type: 'Opportunity',
            record_name: opportunity.name,
            fields_set: oppFieldsSet,
            duplicate_detected: false,
          };

          const oppVerifiedResponse = `Opportunity "${opportunity.name}" created successfully.
- ID: ${opportunity.id}
- Account ID: ${opportunity.accountId}
- Amount: $${opportunity.amount?.toLocaleString() || '0'}
- Stage: ${opportunity.stage}
- Close Date: ${opportunity.closeDate?.toISOString().split('T')[0] || 'Not set'}
- Probability: ${opportunity.probability}%
- Fields set: ${oppFieldsSet.join(', ')}`;

          return createHighRiskResult(true, oppFacts, oppVerifiedResponse, {
            opportunityId: opportunity.id,
            name: opportunity.name,
            accountId: opportunity.accountId,
            amount: opportunity.amount,
            stage: opportunity.stage,
            closeDate: opportunity.closeDate,
            probability: opportunity.probability,
            expectedRevenue: opportunity.expectedRevenue,
            source: 'local',
          });
        }

        case 'analyze_opportunity': {
          try {
            const analysis = await this.opportunitiesService.analyzeOpportunity(toolInput.opportunityId, userId, organizationId, false);

            // Determine confidence based on data quality (using available fields from OpportunityAnalysis)
            const hasGoodProbability = analysis.winProbability > 0;
            const hasRiskFactors = analysis.riskFactors && analysis.riskFactors.length > 0;
            const hasRecommendations = analysis.recommendedActions && analysis.recommendedActions.length > 0;

            const confidenceLevel: 'high' | 'medium' | 'low' =
              (hasGoodProbability && hasRiskFactors && hasRecommendations) ? 'high' :
              (hasGoodProbability || hasRiskFactors) ? 'medium' : 'low';

            const caveats: string[] = [];
            if (!hasGoodProbability) caveats.push('Win probability could not be determined');
            if (!hasRiskFactors) caveats.push('No risk factors identified');
            if (!hasRecommendations) caveats.push('No recommended actions available');

            const facts: AnalysisFacts = {
              action_completed: true,
              analysis_completed: true,
              data_sources_used: ['CRM data', 'AI analysis'],
              records_analyzed: 1,
              confidence_level: confidenceLevel,
              data_freshness: `as of ${new Date().toISOString().split('T')[0]}`,
              caveats,
              methodology: 'AI analysis based on historical patterns and current deal state',
            };

            let verified_response = `## Opportunity Analysis (${confidenceLevel.toUpperCase()} confidence)\n`;
            verified_response += `**Win Probability:** ${(analysis.winProbability * 100).toFixed(0)}%\n`;
            verified_response += `**Deal Velocity:** ${analysis.dealVelocity} days in pipeline\n`;
            verified_response += `**Data as of:** ${facts.data_freshness}\n`;
            if (caveats.length > 0) {
              verified_response += `**Caveats:** ${caveats.join('; ')}\n`;
            }
            verified_response += `\nBased on analysis: ${analysis.reasoning || 'Analysis complete'}`;

            return createMediumRiskResult(true, facts, verified_response, analysis);
          } catch (error) {
            const errorFacts: AnalysisFacts = {
              action_completed: false,
              analysis_completed: false,
              data_sources_used: [],
              records_analyzed: 0,
              confidence_level: 'low',
              data_freshness: `as of ${new Date().toISOString().split('T')[0]}`,
              caveats: ['Analysis failed'],
            };
            return createMediumRiskResult(false, errorFacts, RESPONSE_TEMPLATES.analysis.failure(error.message), undefined, error.message);
          }
        }

        case 'close_opportunity': {
          let result;
          if (toolInput.won) {
            result = await this.opportunitiesService.closeWon(toolInput.opportunityId, userId, organizationId, false);
          } else {
            result = await this.opportunitiesService.closeLost(toolInput.opportunityId, userId, organizationId, toolInput.reason, false);
          }

          return {
            success: true,
            message: `Opportunity closed as ${toolInput.won ? 'WON' : 'LOST'}`,
            data: result,
          };
        }

        case 'get_at_risk_opportunities': {
          const limit = toolInput.limit || 5;

          // RESPECT dataSource parameter - only use Salesforce if explicitly requested
          const shouldUseSalesforceAtRisk = dataSource === 'salesforce';
          const sfStatusAtRisk = shouldUseSalesforceAtRisk
            ? await this.salesforceService.getConnectionStatus(userId)
            : { connected: false };

          if (shouldUseSalesforceAtRisk && sfStatusAtRisk.connected) {
            try {
              // Query Salesforce for opportunities with low probability
              const soql = `SELECT Id, Name, StageName, Amount, Probability, CloseDate, Account.Name, Type
                            FROM Opportunity
                            WHERE IsClosed = false AND Probability < 50
                            ORDER BY Probability ASC NULLS FIRST, CloseDate ASC
                            LIMIT ${limit * 2}`;

              const result = await this.salesforceService.query(userId, soql);
              const sfOpps = result.records || [];

              const mappedOpps = sfOpps.slice(0, limit).map((o: any) => ({
                id: o.Id,
                name: o.Name,
                accountName: o.Account?.Name,
                stage: o.StageName,
                amount: o.Amount,
                closeDate: o.CloseDate,
                winProbability: (o.Probability || 0) / 100, // Convert percentage to decimal
                probability: o.Probability,
              }));

              return {
                success: true,
                message: `Found ${mappedOpps.length} at-risk opportunities from Salesforce`,
                data: mappedOpps,
                source: 'salesforce',
              };
            } catch (sfError) {
              this.logger.warn(`Salesforce get_at_risk_opportunities query failed, falling back to local: ${sfError.message}`);
              // Fall through to local database query
            }
          }

          // Local database fallback
          const opportunitiesResult = await this.opportunitiesService.listOpportunities({ ownerId: userId }, organizationId, false);
          const opportunities = Array.isArray(opportunitiesResult) ? opportunitiesResult : opportunitiesResult.data;

          const atRisk = opportunities
            .filter(o => !o.isClosed && (o.winProbability || 0) < 0.5)
            .sort((a, b) => (a.winProbability || 0) - (b.winProbability || 0))
            .slice(0, limit);

          return {
            success: true,
            message: `Found ${atRisk.length} at-risk opportunities`,
            data: atRisk.map((o: any) => ({
              id: o.id,
              name: o.name,
              accountName: o.account?.name,
              stage: o.stage,
              amount: o.amount,
              closeDate: o.closeDate,
              winProbability: o.winProbability,
              riskFactors: o.riskFactors,
            })),
            source: 'local',
          };
        }

        case 'get_hot_opportunities': {
          const minAmount = toolInput.minAmount || 50000;
          const limit = toolInput.limit || 10;

          // Hot stages - active sales stages (not closed)
          const hotStages = [
            'Prospecting', 'Qualification', 'Needs Analysis', 'Value Proposition',
            'Id. Decision Makers', 'Decision Makers Identified', 'Perception Analysis',
            'Proposal/Price Quote', 'Proposal Price Quote', 'Negotiation/Review', 'Negotiation Review',
            'PROSPECTING', 'QUALIFICATION', 'NEEDS_ANALYSIS', 'VALUE_PROPOSITION',
            'DECISION_MAKERS_IDENTIFIED', 'PERCEPTION_ANALYSIS', 'PROPOSAL_PRICE_QUOTE', 'NEGOTIATION_REVIEW'
          ];

          // RESPECT dataSource parameter
          const shouldUseSalesforceHot = dataSource === 'salesforce';
          this.logger.warn(`[get_hot_opportunities] dataSource=${dataSource}, shouldUseSalesforce=${shouldUseSalesforceHot}`);
          const sfStatusHot = shouldUseSalesforceHot
            ? await this.salesforceService.getConnectionStatus(userId)
            : { connected: false };
          this.logger.warn(`[get_hot_opportunities] sfStatusHot.connected=${sfStatusHot.connected}`);

          if (shouldUseSalesforceHot && sfStatusHot.connected) {
            try {
              // Query Salesforce for high-value opportunities in active stages
              const stageList = hotStages.filter(s => !s.includes('_')).map(s => `'${s}'`).join(', ');
              const soql = `SELECT Id, Name, StageName, Amount, Probability, CloseDate, Account.Name, Type, CreatedDate
                            FROM Opportunity
                            WHERE IsClosed = false
                            AND Amount >= ${minAmount}
                            AND StageName IN (${stageList})
                            ORDER BY Amount DESC, CloseDate ASC
                            LIMIT ${limit * 2}`;
              this.logger.warn(`[get_hot_opportunities] SOQL: ${soql}`);

              const result = await this.salesforceService.query(userId, soql);
              const sfOpps = result.records || [];
              this.logger.warn(`[get_hot_opportunities] Found ${sfOpps.length} records from Salesforce`);

              const mappedOpps = sfOpps.slice(0, limit).map((o: any) => ({
                id: o.Id,
                name: o.Name,
                accountName: o.Account?.Name,
                stage: o.StageName,
                amount: o.Amount,
                closeDate: o.CloseDate,
                probability: o.Probability,
                type: o.Type,
              }));

              this.logger.warn(`[get_hot_opportunities] Returning ${mappedOpps.length} hot opportunities`);
              return {
                success: true,
                message: `Found ${mappedOpps.length} hot opportunities from Salesforce (deals >$${minAmount.toLocaleString()} in active stages)`,
                data: mappedOpps,
                source: 'salesforce',
                insight: mappedOpps.length > 0
                  ? `Total pipeline value: $${mappedOpps.reduce((sum: number, o: any) => sum + (o.amount || 0), 0).toLocaleString()}`
                  : 'No high-value opportunities in active sales stages',
              };
            } catch (sfError) {
              this.logger.warn(`Salesforce get_hot_opportunities query failed, falling back to local: ${sfError.message}`);
              // Fall through to local database query
            }
          }

          // Local database fallback
          const opportunitiesResult = await this.opportunitiesService.listOpportunities({ ownerId: userId }, organizationId, false);
          const opportunities = Array.isArray(opportunitiesResult) ? opportunitiesResult : opportunitiesResult.data;

          const hotOpps = opportunities
            .filter(o => {
              if (o.isClosed) return false;
              if ((o.amount || 0) < minAmount) return false;
              const stage = (o.stage || '').toUpperCase();
              return hotStages.some(s => stage.includes(s.toUpperCase().replace(/[^A-Z]/g, '')));
            })
            .sort((a, b) => (b.amount || 0) - (a.amount || 0))
            .slice(0, limit);

          return {
            success: true,
            message: `Found ${hotOpps.length} hot opportunities (deals >$${minAmount.toLocaleString()} in active stages)`,
            data: hotOpps.map((o: any) => ({
              id: o.id,
              name: o.name,
              accountName: o.account?.name,
              stage: o.stage,
              amount: o.amount,
              closeDate: o.closeDate,
              probability: o.probability,
            })),
            source: 'local',
            insight: hotOpps.length > 0
              ? `Total pipeline value: $${hotOpps.reduce((sum: number, o: any) => sum + (o.amount || 0), 0).toLocaleString()}`
              : 'No high-value opportunities in active sales stages',
          };
        }

        // ACCOUNT SIGNALS - AI-detected buying signals and intelligence
        case 'get_account_signals': {
          const signals = await this.signalsService.getSignals(userId, {
            accountId: toolInput.accountId,
            status: toolInput.status,
            priority: toolInput.priority,
            signalTypes: toolInput.signalTypes,
            timeframe: toolInput.timeframe || '30d',
            limit: toolInput.limit || 20,
          });

          if (signals.length === 0) {
            return {
              success: true,
              message: 'No account signals found. The Listening Agent may not have detected any recent signals for your accounts.',
              data: [],
              suggestion: 'You can trigger the Listening Agent manually from the Admin panel to scan for new signals.',
            };
          }

          // Group signals by priority for better presentation
          const criticalSignals = signals.filter(s => s.priority === 'CRITICAL');
          const highSignals = signals.filter(s => s.priority === 'HIGH');
          const otherSignals = signals.filter(s => s.priority !== 'CRITICAL' && s.priority !== 'HIGH');

          return {
            success: true,
            message: `Found ${signals.length} account signals (${criticalSignals.length} critical, ${highSignals.length} high priority)`,
            data: signals.map(s => ({
              id: s.id,
              accountName: s.accountName,
              accountId: s.accountId,
              type: s.type,
              title: s.title,
              description: s.description,
              priority: s.priority,
              status: s.status,
              confidence: s.confidence,
              source: s.source,
              recommendedAction: s.recommendedAction ? (typeof s.recommendedAction === 'string' ? JSON.parse(s.recommendedAction) : s.recommendedAction) : null,
              createdAt: s.createdAt,
            })),
            summary: {
              total: signals.length,
              byPriority: {
                critical: criticalSignals.length,
                high: highSignals.length,
                medium: signals.filter(s => s.priority === 'MEDIUM').length,
                low: signals.filter(s => s.priority === 'LOW').length,
              },
              byType: signals.reduce((acc, s) => {
                acc[s.type] = (acc[s.type] || 0) + 1;
                return acc;
              }, {} as Record<string, number>),
            },
          };
        }

        // ACCOUNT OPERATIONS
        case 'search_accounts': {
          const limit = toolInput.limit || 10;

          // RESPECT dataSource parameter - only use Salesforce if explicitly requested
          // When dataSource is 'local' or not specified, use local database
          const shouldUseSalesforce = dataSource === 'salesforce';
          this.logger.warn(`[CRM_MODE_TOOL] search_accounts - dataSource="${dataSource}", shouldUseSalesforce=${shouldUseSalesforce}`);
          const sfStatusAccounts = shouldUseSalesforce
            ? await this.salesforceService.getConnectionStatus(userId)
            : { connected: false };

          if (shouldUseSalesforce && sfStatusAccounts.connected) {
            try {
              // Build SOQL WHERE clause based on filters
              const conditions: string[] = [];
              if (toolInput.type) conditions.push(`Type = '${toolInput.type}'`);
              if (toolInput.industry) conditions.push(`Industry = '${toolInput.industry}'`);
              if (toolInput.name) conditions.push(`Name LIKE '%${toolInput.name}%'`);

              const soql = `SELECT Id, Name, Type, Industry, Website, Phone, AnnualRevenue, NumberOfEmployees, BillingCity, BillingState
                            FROM Account
                            ${conditions.length > 0 ? 'WHERE ' + conditions.join(' AND ') : ''}
                            ORDER BY AnnualRevenue DESC NULLS LAST, Name ASC
                            LIMIT ${limit * 2}`;

              const result = await this.salesforceService.query(userId, soql);
              const sfAccounts = result.records || [];

              const mappedAccounts = sfAccounts.map((a: any) => ({
                id: a.Id,
                name: a.Name,
                type: a.Type,
                industry: a.Industry,
                website: a.Website,
                phone: a.Phone,
                annualRevenue: a.AnnualRevenue,
                numberOfEmployees: a.NumberOfEmployees,
                billingCity: a.BillingCity,
                billingState: a.BillingState,
              }));

              return {
                success: true,
                count: mappedAccounts.length,
                showing: Math.min(mappedAccounts.length, limit),
                data: mappedAccounts.slice(0, limit),
                source: 'salesforce',
              };
            } catch (sfError) {
              this.logger.warn(`Salesforce search_accounts query failed, falling back to local: ${sfError.message}`);
              // Fall through to local database query
            }
          }

          // Local database fallback
          const accounts = await this.accountsService.listAccounts({
            type: toolInput.type,
            industry: toolInput.industry,
            search: toolInput.name,
            ownerId: userId,
          }, organizationId, false);

          return {
            success: true,
            count: accounts.length,
            showing: Math.min(accounts.length, limit),
            data: accounts.slice(0, limit).map(a => ({
              id: a.id,
              name: a.name,
              type: a.type,
              industry: a.industry,
              website: a.website,
              phone: a.phone,
              annualRevenue: a.annualRevenue,
              numberOfEmployees: a.numberOfEmployees,
              healthScore: a.healthScore,
            })),
            source: 'local',
          };
        }

        case 'get_account_details': {
          // Check if the accountId is a Salesforce ID and query Salesforce if so
          const { target: accountDetailTarget } = determineOperationTarget(toolInput.accountId);

          if (accountDetailTarget === 'salesforce') {
            try {
              const sfStatusAcctDetail = await this.salesforceService.getConnectionStatus(userId);
              if (sfStatusAcctDetail.connected && sfStatusAcctDetail.connection) {
                const soql = `SELECT Id, Name, Type, Industry, Website, Phone, Fax, Description,
                              AnnualRevenue, NumberOfEmployees, BillingStreet, BillingCity, BillingState,
                              BillingPostalCode, BillingCountry, ShippingStreet, ShippingCity, ShippingState,
                              ShippingPostalCode, ShippingCountry, OwnerId, Owner.Name,
                              CreatedDate, LastModifiedDate
                              FROM Account WHERE Id = '${toolInput.accountId}'`;
                const result = await this.salesforceService.query(userId, soql);

                if (result.records && result.records.length > 0) {
                  const sfAcct = result.records[0];
                  return {
                    success: true,
                    source: 'salesforce',
                    data: {
                      id: sfAcct.Id,
                      name: sfAcct.Name,
                      type: sfAcct.Type,
                      industry: sfAcct.Industry,
                      website: sfAcct.Website,
                      phone: sfAcct.Phone,
                      fax: sfAcct.Fax,
                      description: sfAcct.Description,
                      annualRevenue: sfAcct.AnnualRevenue,
                      numberOfEmployees: sfAcct.NumberOfEmployees,
                      billingAddress: {
                        street: sfAcct.BillingStreet,
                        city: sfAcct.BillingCity,
                        state: sfAcct.BillingState,
                        postalCode: sfAcct.BillingPostalCode,
                        country: sfAcct.BillingCountry,
                      },
                      shippingAddress: {
                        street: sfAcct.ShippingStreet,
                        city: sfAcct.ShippingCity,
                        state: sfAcct.ShippingState,
                        postalCode: sfAcct.ShippingPostalCode,
                        country: sfAcct.ShippingCountry,
                      },
                      ownerName: sfAcct.Owner?.Name,
                      createdAt: sfAcct.CreatedDate,
                      updatedAt: sfAcct.LastModifiedDate,
                    },
                  };
                }
              }
            } catch (sfError) {
              this.logger.warn(`Salesforce account detail query failed: ${sfError.message}`);
            }
            return {
              success: false,
              error: `Account with Salesforce ID ${toolInput.accountId} not found or Salesforce connection unavailable`,
              hint: 'Make sure your Salesforce is connected and the account exists',
            };
          }

          // Local database lookup for local IDs
          const account = await this.accountsService.getAccount(toolInput.accountId, userId, organizationId, false);
          const revenue = await this.accountsService.getAccountRevenue(toolInput.accountId, userId, organizationId, false);

          return {
            success: true,
            source: 'local',
            data: {
              id: account.id,
              name: account.name,
              type: account.type,
              industry: account.industry,
              website: account.website,
              phone: account.phone,
              annualRevenue: account.annualRevenue,
              numberOfEmployees: account.numberOfEmployees,
              healthScore: account.healthScore,
              lifetimeValue: account.lifetimeValue,
              churnRisk: account.churnRisk,
              revenue,
            },
          };
        }

        // CONTACT OPERATIONS
        case 'search_contacts': {
          const limit = toolInput.limit || 10;

          // RESPECT dataSource parameter - only use Salesforce if explicitly requested
          const shouldUseSalesforceContacts = dataSource === 'salesforce';
          const sfStatusContacts = shouldUseSalesforceContacts
            ? await this.salesforceService.getConnectionStatus(userId)
            : { connected: false };

          if (shouldUseSalesforceContacts && sfStatusContacts.connected) {
            try {
              // Build SOQL WHERE clause based on filters
              const conditions: string[] = [];
              if (toolInput.accountId) {
                // Check if accountId is a Salesforce ID
                const { target } = determineOperationTarget(toolInput.accountId);
                if (target === 'salesforce') {
                  conditions.push(`AccountId = '${toolInput.accountId}'`);
                }
              }
              if (toolInput.name) conditions.push(`Name LIKE '%${toolInput.name}%'`);
              if (toolInput.title) conditions.push(`Title LIKE '%${toolInput.title}%'`);

              const soql = `SELECT Id, FirstName, LastName, Title, Email, Phone, MobilePhone, Account.Name, Department
                            FROM Contact
                            ${conditions.length > 0 ? 'WHERE ' + conditions.join(' AND ') : ''}
                            ORDER BY LastName ASC, FirstName ASC
                            LIMIT ${limit * 2}`;

              const result = await this.salesforceService.query(userId, soql);
              const sfContacts = result.records || [];

              const mappedContacts = sfContacts.map((c: any) => ({
                id: c.Id,
                name: `${c.FirstName || ''} ${c.LastName || ''}`.trim(),
                title: c.Title,
                email: c.Email,
                phone: c.Phone,
                mobilePhone: c.MobilePhone,
                accountName: c.Account?.Name,
                department: c.Department,
              }));

              return {
                success: true,
                count: mappedContacts.length,
                data: mappedContacts.slice(0, limit),
                source: 'salesforce',
              };
            } catch (sfError) {
              this.logger.warn(`Salesforce search_contacts query failed, falling back to local: ${sfError.message}`);
              // Fall through to local database query
            }
          }

          // Local database fallback
          const contacts = await this.prisma.contact.findMany({
            where: {
              ownerId: userId,
              ...(toolInput.accountId && { accountId: toolInput.accountId }),
              ...(toolInput.name && {
                OR: [
                  { firstName: { contains: toolInput.name, mode: 'insensitive' as any } },
                  { lastName: { contains: toolInput.name, mode: 'insensitive' as any } },
                ],
              }),
              ...(toolInput.title && { title: { contains: toolInput.title, mode: 'insensitive' as any } }),
            },
            include: { account: true },
            take: limit,
          });

          return {
            success: true,
            count: contacts.length,
            data: contacts.map(c => ({
              id: c.id,
              name: `${c.firstName} ${c.lastName}`,
              title: c.title,
              email: c.email,
              phone: c.phone,
              accountName: c.account?.name,
              role: c.role,
              engagementScore: c.engagementScore,
            })),
            source: 'local',
          };
        }

        case 'get_contact_details': {
          // Check if the contactId is a Salesforce ID and query Salesforce if so
          const { target: contactDetailTarget } = determineOperationTarget(toolInput.contactId);

          if (contactDetailTarget === 'salesforce') {
            try {
              const sfStatusContactDetail = await this.salesforceService.getConnectionStatus(userId);
              if (sfStatusContactDetail.connected && sfStatusContactDetail.connection) {
                const soql = `SELECT Id, FirstName, LastName, Email, Phone, MobilePhone, Title,
                              Department, AccountId, Account.Name, MailingStreet, MailingCity,
                              MailingState, MailingPostalCode, MailingCountry, Description,
                              LeadSource, OwnerId, Owner.Name, CreatedDate, LastModifiedDate
                              FROM Contact WHERE Id = '${toolInput.contactId}'`;
                const result = await this.salesforceService.query(userId, soql);

                if (result.records && result.records.length > 0) {
                  const sfContact = result.records[0];
                  return {
                    success: true,
                    source: 'salesforce',
                    data: {
                      id: sfContact.Id,
                      name: `${sfContact.FirstName || ''} ${sfContact.LastName || ''}`.trim(),
                      firstName: sfContact.FirstName,
                      lastName: sfContact.LastName,
                      email: sfContact.Email,
                      phone: sfContact.Phone,
                      mobilePhone: sfContact.MobilePhone,
                      title: sfContact.Title,
                      department: sfContact.Department,
                      accountId: sfContact.AccountId,
                      accountName: sfContact.Account?.Name,
                      mailingAddress: {
                        street: sfContact.MailingStreet,
                        city: sfContact.MailingCity,
                        state: sfContact.MailingState,
                        postalCode: sfContact.MailingPostalCode,
                        country: sfContact.MailingCountry,
                      },
                      description: sfContact.Description,
                      leadSource: sfContact.LeadSource,
                      ownerName: sfContact.Owner?.Name,
                      createdAt: sfContact.CreatedDate,
                      updatedAt: sfContact.LastModifiedDate,
                    },
                  };
                }
              }
            } catch (sfError) {
              this.logger.warn(`Salesforce contact detail query failed: ${sfError.message}`);
            }
            return {
              success: false,
              error: `Contact with Salesforce ID ${toolInput.contactId} not found or Salesforce connection unavailable`,
              hint: 'Make sure your Salesforce is connected and the contact exists',
            };
          }

          // Local database lookup for local IDs
          const contact = await this.prisma.contact.findUnique({
            where: { id: toolInput.contactId },
            include: {
              account: true,
              opportunityRoles: {
                include: { opportunity: true },
              },
            },
          });

          if (!contact) throw new Error('Contact not found');

          return {
            success: true,
            source: 'local',
            data: {
              id: contact.id,
              name: `${contact.firstName} ${contact.lastName}`,
              email: contact.email,
              phone: contact.phone,
              mobilePhone: contact.mobilePhone,
              title: contact.title,
              department: contact.department,
              role: contact.role,
              accountName: contact.account?.name,
              engagementScore: contact.engagementScore,
              communicationStyle: contact.communicationStyle,
              opportunities: contact.opportunityRoles?.map(r => ({
                id: r.opportunity.id,
                name: r.opportunity.name,
                role: r.role,
              })),
            },
          };
        }

        // QUOTE OPERATIONS
        case 'search_quotes': {
          const quotes = await this.quotesService.listQuotes({
            quoteNumber: toolInput.quoteNumber,
            status: toolInput.status,
            opportunityId: toolInput.opportunityId,
            accountId: toolInput.accountId,
            ownerId: userId,
          }, false, organizationId);

          const limit = toolInput.limit || 10;
          return {
            success: true,
            count: quotes.length,
            showing: Math.min(quotes.length, limit),
            data: quotes.slice(0, limit).map((q: any) => ({
              id: q.id,
              quoteNumber: q.quoteNumber,
              name: q.name,
              status: q.status,
              totalAmount: q.totalPrice, // Database field is totalPrice
              validUntil: q.validUntil,
              opportunityName: q.opportunity?.name,
              accountName: q.account?.name,
              lineItemCount: q.lineItems?.length || 0,
              createdAt: q.createdAt,
            })),
          };
        }

        case 'get_quote_details': {
          const quote = await this.quotesService.getQuote(toolInput.quoteId, userId, false, organizationId);

          return {
            success: true,
            _artifactType: 'quote', // Signal frontend to render quote artifact
            _artifactTitle: `${quote.name} (${quote.quoteNumber})`,
            data: {
              id: quote.id,
              quoteNumber: quote.quoteNumber,
              name: quote.name,
              status: quote.status,
              subtotal: quote.subtotal,
              discount: quote.discount,
              tax: quote.tax,
              totalAmount: quote.totalPrice, // Database field is totalPrice
              validUntil: quote.validUntil,
              paymentTerms: quote.paymentTerms,
              description: quote.description,
              opportunityName: quote.opportunity?.name,
              accountName: quote.account?.name,
              lineItems: quote.lineItems?.map((item: any) => ({
                productName: item.productName,
                productCode: item.productCode,
                quantity: item.quantity,
                unitPrice: item.unitPrice,
                discount: item.discount,
                totalPrice: item.totalPrice,
              })),
              createdAt: quote.createdAt,
              updatedAt: quote.updatedAt,
            },
          };
        }

        case 'create_quote': {
          try {
            const quoteDto = {
              opportunityId: toolInput.opportunityId,
              accountId: toolInput.accountId,
              name: toolInput.name,
              validUntil: toolInput.validUntil ? new Date(toolInput.validUntil) : undefined,
              paymentTerms: toolInput.paymentTerms,
              description: toolInput.description,
            };

            const quote = await this.quotesService.createQuote(quoteDto, userId, organizationId);

            const quoteFieldsSet = Object.keys(quoteDto).filter(k => quoteDto[k] !== undefined && quoteDto[k] !== null);

            const quoteFacts: RecordCreateFacts = {
              action_completed: true,
              record_created: true,
              record_id: quote.id,
              record_type: 'Quote',
              record_name: quote.name,
              fields_set: quoteFieldsSet,
              duplicate_detected: false,
            };

            const quoteVerifiedResponse = `Quote "${quote.name}" created successfully.
- ID: ${quote.id}
- Quote Number: ${quote.quoteNumber}
- Status: ${quote.status}
- Opportunity ID: ${toolInput.opportunityId}
- Account ID: ${toolInput.accountId}
- Valid Until: ${quote.validUntil?.toISOString().split('T')[0] || 'Not set'}
- Fields set: ${quoteFieldsSet.join(', ')}`;

            return createHighRiskResult(true, quoteFacts, quoteVerifiedResponse, {
              quoteId: quote.id,
              quoteNumber: quote.quoteNumber,
              name: quote.name,
              status: quote.status,
              source: 'local',
            });
          } catch (error) {
            const quoteFacts: RecordCreateFacts = {
              action_completed: false,
              record_created: false,
              record_type: 'Quote',
              fields_set: [],
              validation_errors: [error.message],
            };
            return createHighRiskResult(false, quoteFacts, `Failed to create Quote: ${error.message}`);
          }
        }

        case 'update_quote': {
          // First get the current values for comparison
          const beforeQuote = await this.prisma.quote.findUnique({ where: { id: toolInput.quoteId } });

          if (!beforeQuote) {
            const notFoundFacts: RecordUpdateFacts = {
              action_completed: false,
              record_updated: false,
              record_id: toolInput.quoteId,
              record_type: 'Quote',
              fields_changed: [],
              previous_values: {},
              new_values: {},
              validation_errors: ['Quote not found'],
            };
            return createHighRiskResult(false, notFoundFacts, `Quote with ID "${toolInput.quoteId}" not found.`, undefined, 'Quote not found');
          }

          const updateData: any = {};
          if (toolInput.status) updateData.status = toolInput.status;
          if (toolInput.validUntil) updateData.validUntil = new Date(toolInput.validUntil);
          if (toolInput.paymentTerms) updateData.paymentTerms = toolInput.paymentTerms;

          if (Object.keys(updateData).length === 0) {
            const noFieldsFacts: RecordUpdateFacts = {
              action_completed: false,
              record_updated: false,
              record_id: toolInput.quoteId,
              record_type: 'Quote',
              record_name: beforeQuote.name,
              fields_changed: [],
              previous_values: {},
              new_values: {},
              validation_errors: ['No fields provided to update'],
            };
            return createHighRiskResult(false, noFieldsFacts, `No fields provided to update Quote "${beforeQuote.name}".`, undefined, 'No fields provided to update');
          }

          const quote = await this.quotesService.updateQuote(toolInput.quoteId, userId, updateData, false, organizationId);

          // Determine what actually changed
          const quoteChangedFields: string[] = [];
          const quotePreviousValues: Record<string, any> = {};
          const quoteNewValues: Record<string, any> = {};

          if (updateData.status && beforeQuote.status !== updateData.status) {
            quoteChangedFields.push('status');
            quotePreviousValues.status = beforeQuote.status;
            quoteNewValues.status = updateData.status;
          }
          if (updateData.validUntil && beforeQuote.validUntil?.getTime() !== updateData.validUntil.getTime()) {
            quoteChangedFields.push('validUntil');
            quotePreviousValues.validUntil = beforeQuote.validUntil?.toISOString().split('T')[0] || 'Not set';
            quoteNewValues.validUntil = updateData.validUntil.toISOString().split('T')[0];
          }
          if (updateData.paymentTerms && beforeQuote.paymentTerms !== updateData.paymentTerms) {
            quoteChangedFields.push('paymentTerms');
            quotePreviousValues.paymentTerms = beforeQuote.paymentTerms || 'Not set';
            quoteNewValues.paymentTerms = updateData.paymentTerms;
          }

          const quoteFacts: RecordUpdateFacts = {
            action_completed: true,
            record_updated: quoteChangedFields.length > 0,
            record_id: quote.id,
            record_type: 'Quote',
            record_name: quote.name,
            fields_changed: quoteChangedFields,
            previous_values: quotePreviousValues,
            new_values: quoteNewValues,
          };

          let quoteVerifiedResponse: string;
          if (quoteChangedFields.length > 0) {
            const changes = quoteChangedFields.map(f => `${f}: "${quotePreviousValues[f]}" -> "${quoteNewValues[f]}"`).join(', ');
            quoteVerifiedResponse = `Quote "${quote.name}" updated successfully.\nChanges made:\n  - ${changes}`;
            if (quoteChangedFields.includes('status')) {
              quoteVerifiedResponse += `\nStatus changed: ${quotePreviousValues.status} -> ${quoteNewValues.status}`;
            }
          } else {
            quoteVerifiedResponse = `No changes made to Quote "${quote.name}" - values were already set to the requested values.`;
          }

          return createHighRiskResult(true, quoteFacts, quoteVerifiedResponse, {
            quoteId: quote.id,
            name: quote.name,
            status: quote.status,
            validUntil: quote.validUntil,
            source: 'local',
          });
        }

        case 'delete_quote': {
          // Detect if the quoteId is a Salesforce ID and route appropriately
          const { target: deleteQuoteTarget } = determineOperationTarget(toolInput.quoteId);

          if (deleteQuoteTarget === 'salesforce') {
            try {
              // Get quote info before deletion for Salesforce
              let sfQuoteName: string | undefined;
              try {
                const sfQuote = await this.salesforceService.query(userId, `SELECT Id, Name FROM Quote WHERE Id = '${toolInput.quoteId}'`);
                sfQuoteName = sfQuote.records?.[0]?.Name;
              } catch {
                // If we can't get the name, proceed anyway
              }

              await this.salesforceService.delete(userId, 'Quote', toolInput.quoteId);

              const facts: RecordDeleteFacts = {
                action_completed: true,
                record_deleted: true,
                record_id: toolInput.quoteId,
                record_type: 'Quote',
                record_name: sfQuoteName,
                cascade_deleted: [],
              };

              return createHighRiskResult(
                true,
                facts,
                `Quote "${sfQuoteName || toolInput.quoteId}" deleted successfully from Salesforce.`,
                { quoteId: toolInput.quoteId, source: 'salesforce' }
              );
            } catch (error) {
              const isBlocked = error.message?.includes('ENTITY_IS_DELETED') || error.message?.includes('insufficient access');

              const facts: RecordDeleteFacts = {
                action_completed: false,
                record_deleted: false,
                record_id: toolInput.quoteId,
                record_type: 'Quote',
                cascade_deleted: [],
                deletion_blocked: isBlocked,
                block_reason: isBlocked ? 'Insufficient access or record already deleted' : error.message,
              };

              return createHighRiskResult(
                false,
                facts,
                `Failed to delete Salesforce Quote: ${facts.block_reason}`,
                undefined,
                error.message
              );
            }
          }

          // Local database delete (original behavior)
          try {
            const quote = await this.prisma.quote.findFirst({
              where: { id: toolInput.quoteId, ownerId: userId },
              include: {
                lineItems: { select: { id: true, productName: true } },
              },
            });

            if (!quote) {
              const facts: RecordDeleteFacts = {
                action_completed: false,
                record_deleted: false,
                record_id: toolInput.quoteId,
                record_type: 'Quote',
                cascade_deleted: [],
                deletion_blocked: true,
                block_reason: 'Quote not found or access denied',
              };

              return createHighRiskResult(
                false,
                facts,
                `Quote with ID "${toolInput.quoteId}" not found.`,
                undefined,
                'Quote not found or access denied'
              );
            }

            if (quote.status !== 'DRAFT') {
              const facts: RecordDeleteFacts = {
                action_completed: false,
                record_deleted: false,
                record_id: toolInput.quoteId,
                record_type: 'Quote',
                record_name: quote.name,
                cascade_deleted: [],
                deletion_blocked: true,
                block_reason: `Cannot delete non-draft quotes. Quote status is "${quote.status}". Only draft quotes can be deleted.`,
              };

              return createHighRiskResult(
                false,
                facts,
                `Cannot delete Quote "${quote.name}": ${facts.block_reason}`,
                undefined,
                facts.block_reason
              );
            }

            // Track cascade deletions (line items)
            const cascadeDeleted = (quote as any).lineItems?.map((li: any) => ({
              type: 'QuoteLineItem',
              id: li.id,
              name: li.productName || 'Line Item',
            })) || [];

            await this.prisma.quote.delete({ where: { id: toolInput.quoteId } });

            const facts: RecordDeleteFacts = {
              action_completed: true,
              record_deleted: true,
              record_id: toolInput.quoteId,
              record_type: 'Quote',
              record_name: quote.name,
              cascade_deleted: cascadeDeleted,
            };

            let verified_response = `Quote "${facts.record_name}" deleted successfully.`;
            if (cascadeDeleted.length > 0) {
              verified_response += `\n\u26A0\uFE0F Also deleted (cascade): ${cascadeDeleted.length} line item(s)`;
            }

            return createHighRiskResult(true, facts, verified_response);
          } catch (error) {
            const isBlocked = error.code === 'P2003' || error.message?.includes('constraint');

            const facts: RecordDeleteFacts = {
              action_completed: false,
              record_deleted: false,
              record_id: toolInput.quoteId,
              record_type: 'Quote',
              cascade_deleted: [],
              deletion_blocked: isBlocked,
              block_reason: isBlocked ? 'Has dependent records that prevent deletion' : error.message,
            };

            return createHighRiskResult(
              false,
              facts,
              `Failed to delete Quote: ${facts.block_reason}`,
              undefined,
              error.message
            );
          }
        }

        // CONTRACT OPERATIONS
        case 'search_contracts': {
          const contracts = await this.contractsService.listContracts({
            status: toolInput.status,
            accountId: toolInput.accountId,
            renewalDue: toolInput.renewalDue,
            ownerId: userId,
          }, false, organizationId);

          const limit = toolInput.limit || 10;
          return {
            success: true,
            count: contracts.length,
            showing: Math.min(contracts.length, limit),
            data: contracts.slice(0, limit).map((c: any) => ({
              id: c.id,
              contractNumber: c.contractNumber,
              contractName: c.contractName,
              status: c.status,
              contractValue: c.contractValue,
              startDate: c.startDate,
              endDate: c.endDate,
              renewalDate: c.renewalDate,
              autoRenew: c.autoRenew,
              accountName: c.account?.name,
            })),
          };
        }

        case 'get_contract_details': {
          const contract = await this.contractsService.getContract(toolInput.contractId, userId, false, organizationId);

          return {
            success: true,
            data: {
              id: contract.id,
              contractNumber: contract.contractNumber,
              contractName: contract.contractName,
              status: contract.status,
              contractValue: contract.contractValue,
              startDate: contract.startDate,
              endDate: contract.endDate,
              contractTerm: contract.contractTerm,
              billingFrequency: contract.billingFrequency,
              autoRenew: contract.autoRenew,
              renewalDate: contract.renewalDate,
              signedDate: contract.signedDate,
              activatedDate: contract.activatedDate,
              description: contract.description,
              specialTerms: contract.specialTerms,
              accountName: contract.account?.name,
              quoteName: contract.quote?.name,
              quoteAmount: contract.quote?.totalAmount,
            },
          };
        }

        case 'create_contract': {
          try {
            const contractDto = {
              accountId: toolInput.accountId,
              quoteId: toolInput.quoteId,
              contractName: toolInput.contractName,
              startDate: toolInput.startDate ? new Date(toolInput.startDate) : undefined,
              endDate: toolInput.endDate ? new Date(toolInput.endDate) : undefined,
              contractTerm: toolInput.contractTerm,
              contractValue: toolInput.contractValue,
              billingFrequency: toolInput.billingFrequency,
              autoRenew: toolInput.autoRenew,
              description: toolInput.description,
            };

            const contract = await this.contractsService.createContract(contractDto, userId, organizationId);

            const fieldsSet = Object.keys(contractDto).filter(k => contractDto[k] !== undefined && contractDto[k] !== null);

            const facts: RecordCreateFacts = {
              action_completed: true,
              record_created: true,
              record_id: contract.id,
              record_type: 'Contract',
              record_name: contract.contractName,
              fields_set: fieldsSet,
              duplicate_detected: false,
            };

            const verified_response = `Contract "${contract.contractName}" created successfully.
- ID: ${contract.id}
- Contract Number: ${contract.contractNumber}
- Status: ${contract.status}
- Fields set: ${fieldsSet.join(', ')}`;

            return createHighRiskResult(true, facts, verified_response, {
              contractId: contract.id,
              contractNumber: contract.contractNumber,
              contractName: contract.contractName,
              status: contract.status,
            });
          } catch (error) {
            const facts: RecordCreateFacts = {
              action_completed: false,
              record_created: false,
              record_type: 'Contract',
              fields_set: [],
              validation_errors: [error.message],
            };
            return createHighRiskResult(false, facts, `Failed to create Contract: ${error.message}`);
          }
        }

        case 'update_contract': {
          // First get the current values for comparison
          const beforeContract = await this.prisma.contract.findUnique({ where: { id: toolInput.contractId } });

          if (!beforeContract) {
            const notFoundFacts: RecordUpdateFacts = {
              action_completed: false,
              record_updated: false,
              record_id: toolInput.contractId,
              record_type: 'Contract',
              fields_changed: [],
              previous_values: {},
              new_values: {},
              validation_errors: ['Contract not found'],
            };
            return createHighRiskResult(false, notFoundFacts, `Contract with ID "${toolInput.contractId}" not found.`, undefined, 'Contract not found');
          }

          const updateData: any = {};
          if (toolInput.status) updateData.status = toolInput.status;
          if (toolInput.endDate) updateData.endDate = new Date(toolInput.endDate);
          if (toolInput.autoRenew !== undefined) updateData.autoRenew = toolInput.autoRenew;

          if (Object.keys(updateData).length === 0) {
            const noFieldsFacts: RecordUpdateFacts = {
              action_completed: false,
              record_updated: false,
              record_id: toolInput.contractId,
              record_type: 'Contract',
              record_name: beforeContract.contractName,
              fields_changed: [],
              previous_values: {},
              new_values: {},
              validation_errors: ['No fields provided to update'],
            };
            return createHighRiskResult(false, noFieldsFacts, `No fields provided to update Contract "${beforeContract.contractName}".`, undefined, 'No fields provided to update');
          }

          const contract = await this.contractsService.updateContract(toolInput.contractId, userId, updateData, false, organizationId);

          // Determine what actually changed
          const contractChangedFields: string[] = [];
          const contractPreviousValues: Record<string, any> = {};
          const contractNewValues: Record<string, any> = {};

          if (updateData.status && beforeContract.status !== updateData.status) {
            contractChangedFields.push('status');
            contractPreviousValues.status = beforeContract.status;
            contractNewValues.status = updateData.status;
          }
          if (updateData.endDate && beforeContract.endDate?.getTime() !== updateData.endDate.getTime()) {
            contractChangedFields.push('endDate');
            contractPreviousValues.endDate = beforeContract.endDate?.toISOString().split('T')[0] || 'Not set';
            contractNewValues.endDate = updateData.endDate.toISOString().split('T')[0];
          }
          if (updateData.autoRenew !== undefined && beforeContract.autoRenew !== updateData.autoRenew) {
            contractChangedFields.push('autoRenew');
            contractPreviousValues.autoRenew = beforeContract.autoRenew;
            contractNewValues.autoRenew = updateData.autoRenew;
          }

          const contractFacts: RecordUpdateFacts = {
            action_completed: true,
            record_updated: contractChangedFields.length > 0,
            record_id: contract.id,
            record_type: 'Contract',
            record_name: contract.contractName,
            fields_changed: contractChangedFields,
            previous_values: contractPreviousValues,
            new_values: contractNewValues,
          };

          let contractVerifiedResponse: string;
          if (contractChangedFields.length > 0) {
            const changes = contractChangedFields.map(f => `${f}: "${contractPreviousValues[f]}" -> "${contractNewValues[f]}"`).join(', ');
            contractVerifiedResponse = `Contract "${contract.contractName}" updated successfully.\nChanges made:\n  - ${changes}`;
            if (contractChangedFields.includes('status')) {
              contractVerifiedResponse += `\nStatus changed: ${contractPreviousValues.status} -> ${contractNewValues.status}`;
            }
          } else {
            contractVerifiedResponse = `No changes made to Contract "${contract.contractName}" - values were already set to the requested values.`;
          }

          return createHighRiskResult(true, contractFacts, contractVerifiedResponse, {
            contractId: contract.id,
            contractName: contract.contractName,
            status: contract.status,
            endDate: contract.endDate,
            autoRenew: contract.autoRenew,
            source: 'local',
          });
        }

        case 'delete_contract': {
          const { target: deleteContractTarget } = determineOperationTarget(toolInput.contractId);
          if (deleteContractTarget === 'salesforce') {
            try {
              let sfContractName: string | undefined;
              try {
                const sfContract = await this.salesforceService.query(userId, `SELECT Id, ContractNumber FROM Contract WHERE Id = '${toolInput.contractId}'`);
                sfContractName = sfContract.records?.[0]?.ContractNumber;
              } catch { /* ignore */ }
              await this.salesforceService.delete(userId, 'Contract', toolInput.contractId);
              const sfDeleteContractFacts: RecordDeleteFacts = { action_completed: true, record_deleted: true, record_id: toolInput.contractId, record_type: 'Contract', record_name: sfContractName, cascade_deleted: [] };
              return createHighRiskResult(true, sfDeleteContractFacts, `Contract "${sfContractName || toolInput.contractId}" deleted successfully from Salesforce.`, { contractId: toolInput.contractId, source: 'salesforce' });
            } catch (error) {
              const isBlocked = error.message?.includes('ENTITY_IS_DELETED') || error.message?.includes('insufficient access') || error.message?.includes('DELETE_FAILED');
              const sfDeleteContractFailFacts: RecordDeleteFacts = { action_completed: false, record_deleted: false, record_id: toolInput.contractId, record_type: 'Contract', cascade_deleted: [], deletion_blocked: isBlocked, block_reason: isBlocked ? 'Insufficient access, record already deleted, or has dependent records' : error.message };
              return createHighRiskResult(false, sfDeleteContractFailFacts, `Failed to delete Salesforce Contract: ${sfDeleteContractFailFacts.block_reason}`, undefined, error.message);
            }
          }
          try {
            const contractToDelete = await this.prisma.contract.findFirst({ where: { id: toolInput.contractId, ownerId: userId } });
            if (!contractToDelete) {
              const notFoundFacts: RecordDeleteFacts = { action_completed: false, record_deleted: false, record_id: toolInput.contractId, record_type: 'Contract', cascade_deleted: [], deletion_blocked: true, block_reason: 'Contract not found or access denied' };
              return createHighRiskResult(false, notFoundFacts, `Contract with ID "${toolInput.contractId}" not found.`, undefined, 'Contract not found or access denied');
            }
            if (contractToDelete.status !== 'DRAFT') {
              const blockedFacts: RecordDeleteFacts = { action_completed: false, record_deleted: false, record_id: toolInput.contractId, record_type: 'Contract', record_name: contractToDelete.contractName, cascade_deleted: [], deletion_blocked: true, block_reason: `Cannot delete active contracts. Only draft contracts can be deleted. Current status: ${contractToDelete.status}` };
              return createHighRiskResult(false, blockedFacts, `Cannot delete Contract "${contractToDelete.contractName}": ${blockedFacts.block_reason}`, undefined, blockedFacts.block_reason);
            }
            await this.prisma.contract.delete({ where: { id: toolInput.contractId } });
            const deleteSuccessFacts: RecordDeleteFacts = { action_completed: true, record_deleted: true, record_id: toolInput.contractId, record_type: 'Contract', record_name: contractToDelete.contractName, cascade_deleted: [] };
            return createHighRiskResult(true, deleteSuccessFacts, `Contract "${contractToDelete.contractName}" deleted successfully.`, { contractId: toolInput.contractId, source: 'local' });
          } catch (error) {
            const isBlocked = error.code === 'P2003' || error.message?.includes('constraint');
            const deleteErrorFacts: RecordDeleteFacts = { action_completed: false, record_deleted: false, record_id: toolInput.contractId, record_type: 'Contract', cascade_deleted: [], deletion_blocked: isBlocked, block_reason: isBlocked ? 'Has dependent records that prevent deletion' : error.message };
            return createHighRiskResult(false, deleteErrorFacts, `Failed to delete Contract: ${deleteErrorFacts.block_reason}`, undefined, error.message);
          }
        }

        // CAMPAIGN OPERATIONS
        case 'search_campaigns': {
          const campaigns = await this.campaignsService.listCampaigns({
            status: toolInput.status,
            campaignType: toolInput.campaignType,
            ownerId: userId,
          }, organizationId, false);

          const limit = toolInput.limit || 10;
          return {
            success: true,
            count: campaigns.length,
            showing: Math.min(campaigns.length, limit),
            data: campaigns.slice(0, limit).map((c: any) => ({
              id: c.id,
              name: c.name,
              campaignType: c.campaignType,
              status: c.status,
              startDate: c.startDate,
              endDate: c.endDate,
              budgetedCost: c.budgetedCost,
              actualCost: c.actualCost,
              expectedRevenue: c.expectedRevenue,
              numSent: c.numSent,
              numResponses: c.numResponses,
              numConverted: c.numConverted,
            })),
          };
        }

        case 'get_campaign_details': {
          const campaign = await this.campaignsService.getCampaign(toolInput.campaignId, userId, organizationId, false);

          return {
            success: true,
            data: {
              id: campaign.id,
              name: campaign.name,
              campaignType: campaign.campaignType,
              status: campaign.status,
              startDate: campaign.startDate,
              endDate: campaign.endDate,
              budgetedCost: campaign.budgetedCost,
              actualCost: campaign.actualCost,
              expectedRevenue: campaign.expectedRevenue,
              description: campaign.description,
              numSent: campaign.numSent,
              numResponses: campaign.numResponses,
              numConverted: campaign.numConverted,
              metrics: campaign.metrics,
              opportunities: campaign.opportunities,
            },
          };
        }

        case 'get_campaign_roi': {
          const campaign = await this.campaignsService.getCampaign(toolInput.campaignId, userId, organizationId, false);

          const actualCost = campaign.actualCost || campaign.budgetedCost || 0;
          const wonOpportunities = campaign.opportunities?.filter((o: any) => o.isWon) || [];
          const totalWonRevenue = wonOpportunities.reduce((sum: number, o: any) => sum + (o.amount || 0), 0);
          const roi = actualCost > 0 ? ((totalWonRevenue - actualCost) / actualCost * 100) : 0;
          const costPerLead = campaign.numResponses > 0 ? actualCost / campaign.numResponses : 0;
          const costPerConversion = campaign.numConverted > 0 ? actualCost / campaign.numConverted : 0;
          const conversionRate = campaign.numSent > 0 ? (campaign.numConverted / campaign.numSent * 100) : 0;

          return {
            success: true,
            data: {
              campaignName: campaign.name,
              actualCost,
              totalWonRevenue,
              roi: roi.toFixed(2) + '%',
              costPerLead: costPerLead.toFixed(2),
              costPerConversion: costPerConversion.toFixed(2),
              conversionRate: conversionRate.toFixed(2) + '%',
              opportunitiesGenerated: campaign._count?.opportunities || 0,
              opportunitiesWon: wonOpportunities.length,
            },
          };
        }

        // ACCOUNT CRUD
        case 'create_account': {
          try {
            const accountDto = {
              name: toolInput.name,
              type: toolInput.type || 'PROSPECT',
              industry: toolInput.industry,
              website: toolInput.website,
              phone: toolInput.phone,
              annualRevenue: toolInput.annualRevenue,
              numberOfEmployees: toolInput.employees,
              description: toolInput.description,
              billingCity: toolInput.billingCity,
              billingState: toolInput.billingState,
              billingCountry: toolInput.billingCountry,
            };

            const account = await this.accountsService.createAccount(accountDto, userId, organizationId);

            const fieldsSet = Object.keys(accountDto).filter(k => accountDto[k] !== undefined && accountDto[k] !== null);

            const facts: RecordCreateFacts = {
              action_completed: true,
              record_created: true,
              record_id: account.id,
              record_type: 'Account',
              record_name: account.name,
              fields_set: fieldsSet,
              duplicate_detected: false,
            };

            const verified_response = `Account "${account.name}" created successfully.
- ID: ${account.id}
- Type: ${account.type}
- Fields set: ${fieldsSet.join(', ')}`;

            return createHighRiskResult(true, facts, verified_response, {
              accountId: account.id,
              name: account.name,
              type: account.type,
            });
          } catch (error) {
            const facts: RecordCreateFacts = {
              action_completed: false,
              record_created: false,
              record_type: 'Account',
              fields_set: [],
              validation_errors: [error.message],
            };
            return createHighRiskResult(false, facts, `Failed to create Account: ${error.message}`);
          }
        }

        case 'update_account': {
          // First get the current values for comparison
          const beforeAccount = await this.prisma.account.findUnique({ where: { id: toolInput.accountId } });

          if (!beforeAccount) {
            const notFoundFacts: RecordUpdateFacts = {
              action_completed: false,
              record_updated: false,
              record_id: toolInput.accountId,
              record_type: 'Account',
              fields_changed: [],
              previous_values: {},
              new_values: {},
              validation_errors: ['Account not found'],
            };
            return createHighRiskResult(false, notFoundFacts, `Account with ID "${toolInput.accountId}" not found.`, undefined, 'Account not found');
          }

          const updateAccountData: any = {};
          if (toolInput.name) updateAccountData.name = toolInput.name;
          if (toolInput.type) updateAccountData.type = toolInput.type;
          if (toolInput.industry) updateAccountData.industry = toolInput.industry;
          if (toolInput.website) updateAccountData.website = toolInput.website;
          if (toolInput.phone) updateAccountData.phone = toolInput.phone;
          if (toolInput.annualRevenue) updateAccountData.annualRevenue = toolInput.annualRevenue;
          if (toolInput.employees) updateAccountData.numberOfEmployees = toolInput.employees;

          if (Object.keys(updateAccountData).length === 0) {
            const noFieldsFacts: RecordUpdateFacts = {
              action_completed: false,
              record_updated: false,
              record_id: toolInput.accountId,
              record_type: 'Account',
              record_name: beforeAccount.name,
              fields_changed: [],
              previous_values: {},
              new_values: {},
              validation_errors: ['No fields provided to update'],
            };
            return createHighRiskResult(false, noFieldsFacts, `No fields provided to update Account "${beforeAccount.name}".`, undefined, 'No fields provided to update');
          }

          const account = await this.accountsService.updateAccount(toolInput.accountId, userId, updateAccountData, organizationId, false);

          // Determine what actually changed
          const accountChangedFields: string[] = [];
          const accountPreviousValues: Record<string, any> = {};
          const accountNewValues: Record<string, any> = {};

          Object.keys(updateAccountData).forEach(field => {
            if (updateAccountData[field] !== undefined && beforeAccount[field] !== updateAccountData[field]) {
              accountChangedFields.push(field);
              accountPreviousValues[field] = beforeAccount[field] || 'Not set';
              accountNewValues[field] = updateAccountData[field];
            }
          });

          const accountFacts: RecordUpdateFacts = {
            action_completed: true,
            record_updated: accountChangedFields.length > 0,
            record_id: account.id,
            record_type: 'Account',
            record_name: account.name,
            fields_changed: accountChangedFields,
            previous_values: accountPreviousValues,
            new_values: accountNewValues,
          };

          let accountVerifiedResponse: string;
          if (accountChangedFields.length > 0) {
            const changes = accountChangedFields.map(f => `${f}: "${accountPreviousValues[f]}" -> "${accountNewValues[f]}"`).join(', ');
            accountVerifiedResponse = `Account "${account.name}" updated successfully.\nChanges made:\n  - ${changes}`;
          } else {
            accountVerifiedResponse = `No changes made to Account "${account.name}" - values were already set to the requested values.`;
          }

          return createHighRiskResult(true, accountFacts, accountVerifiedResponse, {
            accountId: account.id,
            name: account.name,
            type: account.type,
            industry: account.industry,
            source: 'local',
          });
        }

        case 'delete_account': {
          if (!toolInput.confirm) {
            const deleteAccountFacts: RecordDeleteFacts = {
              action_completed: false,
              record_deleted: false,
              record_id: toolInput.accountId,
              record_type: 'Account',
              cascade_deleted: [],
              deletion_blocked: true,
              block_reason: 'Deletion requires explicit confirmation. Set confirm: true to proceed.',
            };
            return createHighRiskResult(false, deleteAccountFacts, `Cannot delete Account: ${deleteAccountFacts.block_reason}`, undefined, deleteAccountFacts.block_reason);
          }

          const { target: deleteAccountTarget } = determineOperationTarget(toolInput.accountId);

          if (deleteAccountTarget === 'salesforce') {
            try {
              let sfAccountName: string | undefined;
              try {
                const sfAccount = await this.salesforceService.query(userId, `SELECT Id, Name FROM Account WHERE Id = '${toolInput.accountId}'`);
                sfAccountName = sfAccount.records?.[0]?.Name;
              } catch { /* ignore */ }
              await this.salesforceService.delete(userId, 'Account', toolInput.accountId);
              const sfDeleteFacts: RecordDeleteFacts = {
                action_completed: true,
                record_deleted: true,
                record_id: toolInput.accountId,
                record_type: 'Account',
                record_name: sfAccountName,
                cascade_deleted: [],
              };
              return createHighRiskResult(true, sfDeleteFacts, `Account "${sfAccountName || toolInput.accountId}" deleted successfully from Salesforce.\n\u26A0\uFE0F Note: Salesforce may have cascade deleted related Contacts, Opportunities, and other records.`, { accountId: toolInput.accountId, source: 'salesforce' });
            } catch (error) {
              const isBlocked = error.message?.includes('ENTITY_IS_DELETED') || error.message?.includes('insufficient access') || error.message?.includes('DELETE_FAILED');
              const sfDeleteFailFacts: RecordDeleteFacts = {
                action_completed: false,
                record_deleted: false,
                record_id: toolInput.accountId,
                record_type: 'Account',
                cascade_deleted: [],
                deletion_blocked: isBlocked,
                block_reason: isBlocked ? 'Insufficient access, record already deleted, or has dependent records' : error.message,
              };
              return createHighRiskResult(false, sfDeleteFailFacts, `Failed to delete Salesforce Account: ${sfDeleteFailFacts.block_reason}`, undefined, error.message);
            }
          }

          try {
            const accountToDelete = await this.prisma.account.findFirst({
              where: { id: toolInput.accountId, ownerId: userId },
              include: {
                contacts: { select: { id: true, firstName: true, lastName: true } },
                opportunities: { select: { id: true, name: true } },
                tasks: { select: { id: true, subject: true } },
                notes: { select: { id: true, title: true } },
                quotes: { select: { id: true, name: true } },
                contracts: { select: { id: true, contractName: true } },
              },
            });
            if (!accountToDelete) {
              const notFoundFacts: RecordDeleteFacts = {
                action_completed: false,
                record_deleted: false,
                record_id: toolInput.accountId,
                record_type: 'Account',
                cascade_deleted: [],
                deletion_blocked: true,
                block_reason: 'Account not found or access denied',
              };
              return createHighRiskResult(false, notFoundFacts, `Account with ID "${toolInput.accountId}" not found.`, undefined, 'Account not found or access denied');
            }
            const accountCascadeDeleted = [
              ...accountToDelete.contacts.map((c: any) => ({ type: 'Contact', id: c.id, name: `${c.firstName} ${c.lastName}` })),
              ...accountToDelete.opportunities.map((o: any) => ({ type: 'Opportunity', id: o.id, name: o.name })),
              ...accountToDelete.tasks.map((t: any) => ({ type: 'Task', id: t.id, name: t.subject })),
              ...accountToDelete.notes.map((n: any) => ({ type: 'Note', id: n.id, name: n.title || 'Untitled Note' })),
              ...accountToDelete.quotes.map((q: any) => ({ type: 'Quote', id: q.id, name: q.name })),
              ...accountToDelete.contracts.map((c: any) => ({ type: 'Contract', id: c.id, name: c.contractName })),
            ];
            await this.prisma.account.delete({ where: { id: toolInput.accountId } });
            const deleteSuccessFacts: RecordDeleteFacts = {
              action_completed: true,
              record_deleted: true,
              record_id: toolInput.accountId,
              record_type: 'Account',
              record_name: accountToDelete.name,
              cascade_deleted: accountCascadeDeleted,
            };
            let accountDeleteResponse = `Account "${deleteSuccessFacts.record_name}" deleted successfully.`;
            if (accountCascadeDeleted.length > 0) {
              accountDeleteResponse += `\n\u26A0\uFE0F Also deleted (cascade):`;
              if (accountToDelete.contacts.length > 0) accountDeleteResponse += `\n  - ${accountToDelete.contacts.length} Contact(s): ${accountToDelete.contacts.map((c: any) => `"${c.firstName} ${c.lastName}"`).join(', ')}`;
              if (accountToDelete.opportunities.length > 0) accountDeleteResponse += `\n  - ${accountToDelete.opportunities.length} Opportunity(ies): ${accountToDelete.opportunities.map((o: any) => `"${o.name}"`).join(', ')}`;
              if (accountToDelete.tasks.length > 0) accountDeleteResponse += `\n  - ${accountToDelete.tasks.length} Task(s)`;
              if (accountToDelete.notes.length > 0) accountDeleteResponse += `\n  - ${accountToDelete.notes.length} Note(s)`;
              if (accountToDelete.quotes.length > 0) accountDeleteResponse += `\n  - ${accountToDelete.quotes.length} Quote(s)`;
              if (accountToDelete.contracts.length > 0) accountDeleteResponse += `\n  - ${accountToDelete.contracts.length} Contract(s)`;
            }
            return createHighRiskResult(true, deleteSuccessFacts, accountDeleteResponse);
          } catch (error) {
            const isBlocked = error.code === 'P2003' || error.message?.includes('constraint');
            const deleteErrorFacts: RecordDeleteFacts = {
              action_completed: false,
              record_deleted: false,
              record_id: toolInput.accountId,
              record_type: 'Account',
              cascade_deleted: [],
              deletion_blocked: isBlocked,
              block_reason: isBlocked ? 'Has dependent records that prevent deletion' : error.message,
            };
            return createHighRiskResult(false, deleteErrorFacts, `Failed to delete Account: ${deleteErrorFacts.block_reason}`, undefined, error.message);
          }
        }

        // CONTACT CRUD
        case 'create_contact': {
          // If accountId is provided, check if it's a Salesforce ID
          if (toolInput.accountId) {
            const { target: accountTarget } = determineOperationTarget(toolInput.accountId);
            if (accountTarget === 'salesforce') {
              // Route to Salesforce contact creation
              try {
                const sfContactData: any = {
                  FirstName: toolInput.firstName,
                  LastName: toolInput.lastName,
                  AccountId: toolInput.accountId,
                  Email: toolInput.email,
                  Phone: toolInput.phone,
                  MobilePhone: toolInput.mobilePhone,
                  Title: toolInput.title,
                  Department: toolInput.department,
                };
                const result = await this.salesforceService.create(userId, 'Contact', sfContactData);

                const sfFieldsSet = Object.keys(sfContactData).filter(k => sfContactData[k] !== undefined && sfContactData[k] !== null);
                const sfRecordName = `${toolInput.firstName} ${toolInput.lastName}`;

                const sfFacts: RecordCreateFacts = {
                  action_completed: true,
                  record_created: true,
                  record_id: result.id,
                  record_type: 'Contact',
                  record_name: sfRecordName,
                  fields_set: sfFieldsSet,
                  duplicate_detected: false,
                };

                const sfVerified = `Salesforce Contact "${sfRecordName}" created successfully.
- ID: ${result.id}
- Account ID: ${toolInput.accountId}
- Fields set: ${sfFieldsSet.join(', ')}`;

                return createHighRiskResult(true, sfFacts, sfVerified, {
                  contactId: result.id,
                  name: sfRecordName,
                  email: toolInput.email,
                  source: 'salesforce',
                });
              } catch (error) {
                const sfFacts: RecordCreateFacts = {
                  action_completed: false,
                  record_created: false,
                  record_type: 'Contact',
                  fields_set: [],
                  validation_errors: [error.message],
                };
                return createHighRiskResult(false, sfFacts, `Failed to create Salesforce Contact: ${error.message}`);
              }
            }
          }

          try {
            const contactDto = {
              firstName: toolInput.firstName,
              lastName: toolInput.lastName,
              accountId: toolInput.accountId,
              email: toolInput.email,
              phone: toolInput.phone,
              mobilePhone: toolInput.mobilePhone,
              title: toolInput.title,
              department: toolInput.department,
              role: toolInput.role,
            };

            const contact = await this.prisma.contact.create({
              data: {
                ownerId: userId,
                ...contactDto,
              },
              include: { account: true },
            });

            const fieldsSet = Object.keys(contactDto).filter(k => contactDto[k] !== undefined && contactDto[k] !== null);
            const recordName = `${contact.firstName} ${contact.lastName}`;

            const facts: RecordCreateFacts = {
              action_completed: true,
              record_created: true,
              record_id: contact.id,
              record_type: 'Contact',
              record_name: recordName,
              fields_set: fieldsSet,
              duplicate_detected: false,
            };

            const verified_response = `Contact "${recordName}" created successfully.
- ID: ${contact.id}
- Email: ${contact.email || 'Not provided'}
- Account: ${contact.account?.name || 'None'}
- Fields set: ${fieldsSet.join(', ')}`;

            return createHighRiskResult(true, facts, verified_response, {
              contactId: contact.id,
              name: recordName,
              email: contact.email,
              accountName: contact.account?.name,
              source: 'local',
            });
          } catch (error) {
            const facts: RecordCreateFacts = {
              action_completed: false,
              record_created: false,
              record_type: 'Contact',
              fields_set: [],
              validation_errors: [error.message],
            };
            return createHighRiskResult(false, facts, `Failed to create Contact: ${error.message}`);
          }
        }

        case 'update_contact': {
          // Detect if the contactId is a Salesforce ID and route appropriately
          const { target: updateContactTarget } = determineOperationTarget(toolInput.contactId);

          if (updateContactTarget === 'salesforce') {
            try {
              const sfContactData: any = {};
              if (toolInput.firstName) sfContactData.FirstName = toolInput.firstName;
              if (toolInput.lastName) sfContactData.LastName = toolInput.lastName;
              if (toolInput.email) sfContactData.Email = toolInput.email;
              if (toolInput.phone) sfContactData.Phone = toolInput.phone;
              if (toolInput.title) sfContactData.Title = toolInput.title;
              if (toolInput.department) sfContactData.Department = toolInput.department;

              if (Object.keys(sfContactData).length === 0) {
                return { success: false, error: 'No fields provided to update' };
              }

              // Get current values before update for comparison
              const beforeContactQuery = `SELECT Id, FirstName, LastName, Email, Phone, Title, Department FROM Contact WHERE Id = '${toolInput.contactId}'`;
              const beforeContactResult = await this.salesforceService.query(userId, beforeContactQuery);
              const beforeSfContact = beforeContactResult.records?.[0];

              await this.salesforceService.update(userId, 'Contact', toolInput.contactId, sfContactData);

              // Determine what actually changed
              const sfContactChangedFields: string[] = [];
              const sfContactPreviousValues: Record<string, any> = {};
              const sfContactNewValues: Record<string, any> = {};

              Object.keys(sfContactData).forEach(field => {
                if (beforeSfContact?.[field] !== sfContactData[field]) {
                  sfContactChangedFields.push(field);
                  sfContactPreviousValues[field] = beforeSfContact?.[field] || 'Not set';
                  sfContactNewValues[field] = sfContactData[field];
                }
              });

              const sfContactName = beforeSfContact ? `${beforeSfContact.FirstName || ''} ${beforeSfContact.LastName || ''}`.trim() : toolInput.contactId;

              const sfContactFacts: RecordUpdateFacts = {
                action_completed: true,
                record_updated: sfContactChangedFields.length > 0,
                record_id: toolInput.contactId,
                record_type: 'Contact',
                record_name: sfContactName,
                fields_changed: sfContactChangedFields,
                previous_values: sfContactPreviousValues,
                new_values: sfContactNewValues,
              };

              let sfContactVerifiedResponse: string;
              if (sfContactChangedFields.length > 0) {
                const changes = sfContactChangedFields.map(f => `${f}: "${sfContactPreviousValues[f]}" -> "${sfContactNewValues[f]}"`).join(', ');
                sfContactVerifiedResponse = `Salesforce Contact "${sfContactName}" updated.\n- Changes: ${changes}`;
              } else {
                sfContactVerifiedResponse = `No changes made to Salesforce Contact "${sfContactName}" - values were already set.`;
              }

              return createHighRiskResult(true, sfContactFacts, sfContactVerifiedResponse, {
                contactId: toolInput.contactId,
                updatedFields: sfContactChangedFields,
                values: sfContactData,
                source: 'salesforce',
              });
            } catch (error) {
              const errorContactFacts: RecordUpdateFacts = {
                action_completed: false,
                record_updated: false,
                record_id: toolInput.contactId,
                record_type: 'Contact',
                fields_changed: [],
                previous_values: {},
                new_values: {},
              };
              return createHighRiskResult(false, errorContactFacts, `Failed to update Salesforce Contact: ${error.message}`, undefined, error.message);
            }
          }

          // Local database update (original behavior)
          // First get the current values for comparison
          const beforeContact = await this.prisma.contact.findUnique({ where: { id: toolInput.contactId } });

          const updateContactData: any = {};
          if (toolInput.firstName) updateContactData.firstName = toolInput.firstName;
          if (toolInput.lastName) updateContactData.lastName = toolInput.lastName;
          if (toolInput.email) updateContactData.email = toolInput.email;
          if (toolInput.phone) updateContactData.phone = toolInput.phone;
          if (toolInput.title) updateContactData.title = toolInput.title;
          if (toolInput.department) updateContactData.department = toolInput.department;
          if (toolInput.role) updateContactData.role = toolInput.role;

          const contact = await this.prisma.contact.update({
            where: { id: toolInput.contactId },
            data: updateContactData,
          });

          // Determine what actually changed
          const contactChangedFields = Object.keys(updateContactData).filter(k =>
            updateContactData[k] !== undefined && beforeContact && beforeContact[k] !== updateContactData[k]
          );

          const contactName = `${contact.firstName} ${contact.lastName}`;

          // Build contactFacts for grounded response
          const contactPreviousValues: Record<string, any> = {};
          const contactNewValues: Record<string, any> = {};
          contactChangedFields.forEach(field => {
            contactPreviousValues[field] = beforeContact?.[field] || 'Not set';
            contactNewValues[field] = updateContactData[field];
          });

          const contactFacts: RecordUpdateFacts = {
            action_completed: true,
            record_updated: contactChangedFields.length > 0,
            record_id: contact.id,
            record_type: 'Contact',
            record_name: contactName,
            fields_changed: contactChangedFields,
            previous_values: contactPreviousValues,
            new_values: contactNewValues,
          };

          let contactVerifiedResponse: string;
          if (contactChangedFields.length > 0) {
            const changes = contactChangedFields.map(f => `${f}: "${contactFacts.previous_values[f]}" -> "${contactFacts.new_values[f]}"`).join(', ');
            contactVerifiedResponse = `Contact "${contactName}" updated.\n- Changes: ${changes}`;
          } else {
            contactVerifiedResponse = `No changes made to Contact "${contactName}" - values were already set.`;
          }

          return createHighRiskResult(true, contactFacts, contactVerifiedResponse, {
            contactId: contact.id,
            name: contactName,
            source: 'local',
          });
        }

        case 'delete_contact': {
          const { target: deleteContactTarget } = determineOperationTarget(toolInput.contactId);

          if (deleteContactTarget === 'salesforce') {
            try {
              let sfContactName: string | undefined;
              try {
                const sfContact = await this.salesforceService.query(userId, `SELECT Id, FirstName, LastName FROM Contact WHERE Id = '${toolInput.contactId}'`);
                if (sfContact.records?.[0]) sfContactName = `${sfContact.records[0].FirstName || ''} ${sfContact.records[0].LastName || ''}`.trim();
              } catch { /* ignore */ }
              await this.salesforceService.delete(userId, 'Contact', toolInput.contactId);
              const sfDeleteContactFacts: RecordDeleteFacts = { action_completed: true, record_deleted: true, record_id: toolInput.contactId, record_type: 'Contact', record_name: sfContactName, cascade_deleted: [] };
              return createHighRiskResult(true, sfDeleteContactFacts, `Contact "${sfContactName || toolInput.contactId}" deleted successfully from Salesforce.`, { contactId: toolInput.contactId, source: 'salesforce' });
            } catch (error) {
              const isBlocked = error.message?.includes('ENTITY_IS_DELETED') || error.message?.includes('insufficient access') || error.message?.includes('DELETE_FAILED');
              const sfDeleteContactFailFacts: RecordDeleteFacts = { action_completed: false, record_deleted: false, record_id: toolInput.contactId, record_type: 'Contact', cascade_deleted: [], deletion_blocked: isBlocked, block_reason: isBlocked ? 'Insufficient access, record already deleted, or has dependent records' : error.message };
              return createHighRiskResult(false, sfDeleteContactFailFacts, `Failed to delete Salesforce Contact: ${sfDeleteContactFailFacts.block_reason}`, undefined, error.message);
            }
          }

          try {
            const contactToDelete = await this.prisma.contact.findFirst({
              where: { id: toolInput.contactId, ownerId: userId },
              include: { tasks: { select: { id: true, subject: true } }, notes: { select: { id: true, title: true } }, opportunityRoles: { select: { id: true, opportunityId: true } } },
            });
            if (!contactToDelete) {
              const notFoundContactFacts: RecordDeleteFacts = { action_completed: false, record_deleted: false, record_id: toolInput.contactId, record_type: 'Contact', cascade_deleted: [], deletion_blocked: true, block_reason: 'Contact not found or access denied' };
              return createHighRiskResult(false, notFoundContactFacts, `Contact with ID "${toolInput.contactId}" not found.`, undefined, 'Contact not found or access denied');
            }
            const contactCascadeDeleted = [
              ...contactToDelete.tasks.map((t: any) => ({ type: 'Task', id: t.id, name: t.subject })),
              ...contactToDelete.notes.map((n: any) => ({ type: 'Note', id: n.id, name: n.title || 'Untitled Note' })),
              ...contactToDelete.opportunityRoles.map((r: any) => ({ type: 'OpportunityContactRole', id: r.id, name: `Role on Opportunity ${r.opportunityId}` })),
            ];
            await this.prisma.contact.delete({ where: { id: toolInput.contactId } });
            const deleteContactSuccessFacts: RecordDeleteFacts = { action_completed: true, record_deleted: true, record_id: toolInput.contactId, record_type: 'Contact', record_name: `${contactToDelete.firstName} ${contactToDelete.lastName}`, cascade_deleted: contactCascadeDeleted };
            let contactDeleteResponse = `Contact "${deleteContactSuccessFacts.record_name}" deleted successfully.`;
            if (contactCascadeDeleted.length > 0) {
              contactDeleteResponse += `\n\u26A0\uFE0F Also deleted (cascade):`;
              if (contactToDelete.tasks.length > 0) contactDeleteResponse += `\n  - ${contactToDelete.tasks.length} Task(s)`;
              if (contactToDelete.notes.length > 0) contactDeleteResponse += `\n  - ${contactToDelete.notes.length} Note(s)`;
              if (contactToDelete.opportunityRoles.length > 0) contactDeleteResponse += `\n  - ${contactToDelete.opportunityRoles.length} Opportunity Contact Role(s)`;
            }
            return createHighRiskResult(true, deleteContactSuccessFacts, contactDeleteResponse);
          } catch (error) {
            const isBlocked = error.code === 'P2003' || error.message?.includes('constraint');
            const deleteContactErrorFacts: RecordDeleteFacts = { action_completed: false, record_deleted: false, record_id: toolInput.contactId, record_type: 'Contact', cascade_deleted: [], deletion_blocked: isBlocked, block_reason: isBlocked ? 'Has dependent records that prevent deletion' : error.message };
            return createHighRiskResult(false, deleteContactErrorFacts, `Failed to delete Contact: ${deleteContactErrorFacts.block_reason}`, undefined, error.message);
          }
        }

        // NOTE OPERATIONS
        case 'create_note': {
          try {
            const noteDto = {
              title: toolInput.title,
              body: toolInput.body,
              leadId: toolInput.leadId,
              accountId: toolInput.accountId,
              contactId: toolInput.contactId,
              opportunityId: toolInput.opportunityId,
              isPrivate: toolInput.isPrivate,
            };

            const note = await this.notesService.createNote(noteDto, userId, organizationId);

            const fieldsSet = Object.keys(noteDto).filter(k => noteDto[k] !== undefined && noteDto[k] !== null);

            const facts: RecordCreateFacts = {
              action_completed: true,
              record_created: true,
              record_id: note.id,
              record_type: 'Note',
              record_name: note.title ?? undefined,
              fields_set: fieldsSet,
              duplicate_detected: false,
            };

            const verified_response = `Note "${note.title}" created successfully.
- ID: ${note.id}
- Fields set: ${fieldsSet.join(', ')}`;

            return createHighRiskResult(true, facts, verified_response, {
              noteId: note.id,
              title: note.title,
            });
          } catch (error) {
            const facts: RecordCreateFacts = {
              action_completed: false,
              record_created: false,
              record_type: 'Note',
              fields_set: [],
              validation_errors: [error.message],
            };
            return createHighRiskResult(false, facts, `Failed to create Note: ${error.message}`);
          }
        }

        case 'get_notes': {
          const where: any = { userId };
          if (toolInput.leadId) where.leadId = toolInput.leadId;
          if (toolInput.accountId) where.accountId = toolInput.accountId;
          if (toolInput.contactId) where.contactId = toolInput.contactId;
          if (toolInput.opportunityId) where.opportunityId = toolInput.opportunityId;

          const notes = await this.prisma.note.findMany({
            where,
            orderBy: { createdAt: 'desc' },
            take: toolInput.limit || 10,
            include: {
              user: { select: { name: true } },
            },
          });

          return {
            success: true,
            count: notes.length,
            data: notes.map(n => ({
              id: n.id,
              title: n.title,
              body: n.body,
              createdAt: n.createdAt,
              createdBy: n.user?.name,
              isPrivate: n.isPrivate,
            })),
          };
        }

        case 'delete_note': {
          const { target: deleteNoteTarget } = determineOperationTarget(toolInput.noteId);
          if (deleteNoteTarget === 'salesforce') {
            try {
              // Try ContentNote first (newer), fall back to Note (classic)
              try {
                await this.salesforceService.delete(userId, 'ContentNote', toolInput.noteId);
              } catch {
                await this.salesforceService.delete(userId, 'Note', toolInput.noteId);
              }
              const sfDeleteNoteFacts: RecordDeleteFacts = { action_completed: true, record_deleted: true, record_id: toolInput.noteId, record_type: 'Note', cascade_deleted: [] };
              return createHighRiskResult(true, sfDeleteNoteFacts, `Note "${toolInput.noteId}" deleted successfully from Salesforce.`, { noteId: toolInput.noteId, source: 'salesforce' });
            } catch (error) {
              const isBlocked = error.message?.includes('ENTITY_IS_DELETED') || error.message?.includes('insufficient access') || error.message?.includes('DELETE_FAILED');
              const sfDeleteNoteFailFacts: RecordDeleteFacts = { action_completed: false, record_deleted: false, record_id: toolInput.noteId, record_type: 'Note', cascade_deleted: [], deletion_blocked: isBlocked, block_reason: isBlocked ? 'Insufficient access, record already deleted, or has dependent records' : error.message };
              return createHighRiskResult(false, sfDeleteNoteFailFacts, `Failed to delete Salesforce Note: ${sfDeleteNoteFailFacts.block_reason}`, undefined, error.message);
            }
          }
          try {
            const note = await this.prisma.note.findFirst({ where: { id: toolInput.noteId, userId } });
            if (!note) {
              const notFoundFacts: RecordDeleteFacts = { action_completed: false, record_deleted: false, record_id: toolInput.noteId, record_type: 'Note', cascade_deleted: [], deletion_blocked: true, block_reason: 'Note not found or access denied' };
              return createHighRiskResult(false, notFoundFacts, `Note with ID "${toolInput.noteId}" not found.`, undefined, 'Note not found or access denied');
            }
            await this.prisma.note.delete({ where: { id: toolInput.noteId } });
            const deleteSuccessFacts: RecordDeleteFacts = { action_completed: true, record_deleted: true, record_id: toolInput.noteId, record_type: 'Note', record_name: note.title || 'Untitled Note', cascade_deleted: [] };
            return createHighRiskResult(true, deleteSuccessFacts, `Note "${note.title || 'Untitled Note'}" deleted successfully.`, { noteId: toolInput.noteId, source: 'local' });
          } catch (error) {
            const deleteErrorFacts: RecordDeleteFacts = { action_completed: false, record_deleted: false, record_id: toolInput.noteId, record_type: 'Note', cascade_deleted: [], deletion_blocked: false, block_reason: error.message };
            return createHighRiskResult(false, deleteErrorFacts, `Failed to delete Note: ${deleteErrorFacts.block_reason}`, undefined, error.message);
          }
        }

        // TASK EXTENDED OPERATIONS
        case 'update_task': {
          // Detect if the taskId is a Salesforce ID and route appropriately
          const { target: operationTarget } = determineOperationTarget(toolInput.taskId);

          if (operationTarget === 'salesforce') {
            // Route to Salesforce update
            try {
              const sfUpdateData: any = {};
              if (toolInput.status) {
                // Map local status values to Salesforce Task Status values
                const statusMap: Record<string, string> = {
                  'NOT_STARTED': 'Not Started',
                  'IN_PROGRESS': 'In Progress',
                  'COMPLETED': 'Completed',
                  'WAITING': 'Waiting on someone else',
                  'DEFERRED': 'Deferred',
                };
                sfUpdateData.Status = statusMap[toolInput.status] || toolInput.status;
              }
              if (toolInput.priority) {
                // Map local priority values to Salesforce Priority values
                const priorityMap: Record<string, string> = {
                  'HIGH': 'High',
                  'NORMAL': 'Normal',
                  'LOW': 'Low',
                };
                sfUpdateData.Priority = priorityMap[toolInput.priority] || toolInput.priority;
              }
              if (toolInput.dueDate) sfUpdateData.ActivityDate = toolInput.dueDate;
              if (toolInput.subject) sfUpdateData.Subject = toolInput.subject;
              if (toolInput.description) sfUpdateData.Description = toolInput.description;

              if (Object.keys(sfUpdateData).length === 0) {
                const noFieldsFacts: RecordUpdateFacts = { action_completed: false, record_updated: false, record_id: toolInput.taskId, record_type: 'Task', fields_changed: [], previous_values: {}, new_values: {}, validation_errors: ['No fields provided to update'] };
                return createHighRiskResult(false, noFieldsFacts, `No fields provided to update Salesforce Task.`, undefined, 'No fields provided to update');
              }
              const beforeTaskQuery = `SELECT Id, Subject, Status, Priority, ActivityDate, Description FROM Task WHERE Id = '${toolInput.taskId}'`;
              const beforeTaskResult = await this.salesforceService.query(userId, beforeTaskQuery);
              const beforeSfTask = beforeTaskResult.records?.[0];

              // Check if task exists in Salesforce before attempting update
              if (!beforeSfTask) {
                const notFoundFacts: RecordUpdateFacts = { action_completed: false, record_updated: false, record_id: toolInput.taskId, record_type: 'Task', fields_changed: [], previous_values: {}, new_values: {}, validation_errors: ['Task not found in Salesforce'] };
                return createHighRiskResult(false, notFoundFacts, `Salesforce Task with ID "${toolInput.taskId}" not found. It may have been deleted or you may not have access to it.`, undefined, 'Task not found in Salesforce');
              }

              await this.salesforceService.update(userId, 'Task', toolInput.taskId, sfUpdateData);
              const sfTaskChangedFields: string[] = [];
              const sfTaskPreviousValues: Record<string, any> = {};
              const sfTaskNewValues: Record<string, any> = {};
              Object.keys(sfUpdateData).forEach(field => {
                if (beforeSfTask?.[field] !== sfUpdateData[field]) { sfTaskChangedFields.push(field); sfTaskPreviousValues[field] = beforeSfTask?.[field] || 'Not set'; sfTaskNewValues[field] = sfUpdateData[field]; }
              });
              const sfTaskName = beforeSfTask?.Subject || toolInput.taskId;
              const sfTaskFacts: RecordUpdateFacts = { action_completed: true, record_updated: sfTaskChangedFields.length > 0, record_id: toolInput.taskId, record_type: 'Task', record_name: sfTaskName, fields_changed: sfTaskChangedFields, previous_values: sfTaskPreviousValues, new_values: sfTaskNewValues };
              const sfTaskVerifiedResponse = sfTaskChangedFields.length > 0 ? `Salesforce Task "${sfTaskName}" updated successfully.\nChanges made:\n  - ${sfTaskChangedFields.map(f => `${f}: "${sfTaskPreviousValues[f]}" -> "${sfTaskNewValues[f]}"`).join(', ')}` : `No changes made to Salesforce Task "${sfTaskName}" - values were already set.`;
              return createHighRiskResult(true, sfTaskFacts, sfTaskVerifiedResponse, { taskId: toolInput.taskId, subject: sfTaskName, updatedFields: sfTaskChangedFields, source: 'salesforce' });
            } catch (error) {
              const errorTaskFacts: RecordUpdateFacts = { action_completed: false, record_updated: false, record_id: toolInput.taskId, record_type: 'Task', fields_changed: [], previous_values: {}, new_values: {} };
              return createHighRiskResult(false, errorTaskFacts, `Failed to update Salesforce Task: ${error.message}`, undefined, error.message);
            }
          }

          // Local database update
          const beforeTask = await this.prisma.task.findUnique({ where: { id: toolInput.taskId } });
          if (!beforeTask) {
            const notFoundFacts: RecordUpdateFacts = { action_completed: false, record_updated: false, record_id: toolInput.taskId, record_type: 'Task', fields_changed: [], previous_values: {}, new_values: {}, validation_errors: ['Task not found'] };
            return createHighRiskResult(false, notFoundFacts, `Task with ID "${toolInput.taskId}" not found.`, undefined, 'Task not found');
          }
          const updateData: any = {};
          if (toolInput.status) updateData.status = toolInput.status;
          if (toolInput.priority) updateData.priority = toolInput.priority;
          if (toolInput.dueDate) updateData.dueDate = new Date(toolInput.dueDate);
          if (toolInput.subject) updateData.subject = toolInput.subject;
          if (toolInput.description) updateData.description = toolInput.description;
          if (Object.keys(updateData).length === 0) {
            const noFieldsFacts: RecordUpdateFacts = { action_completed: false, record_updated: false, record_id: toolInput.taskId, record_type: 'Task', record_name: beforeTask.subject, fields_changed: [], previous_values: {}, new_values: {}, validation_errors: ['No fields provided to update'] };
            return createHighRiskResult(false, noFieldsFacts, `No fields provided to update Task "${beforeTask.subject}".`, undefined, 'No fields provided to update');
          }
          const task = await this.prisma.task.update({ where: { id: toolInput.taskId }, data: updateData });
          const taskChangedFields: string[] = [];
          const taskPreviousValues: Record<string, any> = {};
          const taskNewValues: Record<string, any> = {};
          Object.keys(updateData).forEach(field => {
            const beforeValue = field === 'dueDate' ? beforeTask[field]?.toISOString() : beforeTask[field];
            const afterValue = field === 'dueDate' ? updateData[field]?.toISOString() : updateData[field];
            if (beforeValue !== afterValue) { taskChangedFields.push(field); taskPreviousValues[field] = beforeTask[field] || 'Not set'; taskNewValues[field] = updateData[field]; }
          });
          const taskFacts: RecordUpdateFacts = { action_completed: true, record_updated: taskChangedFields.length > 0, record_id: task.id, record_type: 'Task', record_name: task.subject, fields_changed: taskChangedFields, previous_values: taskPreviousValues, new_values: taskNewValues };
          const taskVerifiedResponse = taskChangedFields.length > 0 ? `Task "${task.subject}" updated successfully.\nChanges made:\n  - ${taskChangedFields.map(f => `${f}: "${taskPreviousValues[f]}" -> "${taskNewValues[f]}"`).join(', ')}` : `No changes made to Task "${task.subject}" - values were already set.`;
          return createHighRiskResult(true, taskFacts, taskVerifiedResponse, { taskId: task.id, subject: task.subject, status: task.status, priority: task.priority, dueDate: task.dueDate, source: 'local' });
        }

        case 'complete_task': {
          // Detect if the taskId is a Salesforce ID and route appropriately
          const { target: completeTarget } = determineOperationTarget(toolInput.taskId);

          if (completeTarget === 'salesforce') {
            try {
              // First verify the task exists in Salesforce
              const taskCheckQuery = `SELECT Id, Subject, Status, OwnerId, Owner.Name FROM Task WHERE Id = '${toolInput.taskId}'`;
              const taskCheckResult = await this.salesforceService.query(userId, taskCheckQuery);
              const existingTask = taskCheckResult.records?.[0];

              if (!existingTask) {
                return {
                  success: false,
                  error: `Salesforce Task with ID "${toolInput.taskId}" not found. It may have been deleted or you may not have access to it.`,
                  hint: 'Try searching for tasks again to find the current task list.',
                };
              }

              // Check if already completed
              if (existingTask.Status === 'Completed') {
                return {
                  success: true,
                  message: `Salesforce Task "${existingTask.Subject}" is already marked as completed.`,
                  data: {
                    taskId: toolInput.taskId,
                    subject: existingTask.Subject,
                    status: 'Completed',
                    source: 'salesforce',
                  },
                };
              }

              await this.salesforceService.update(userId, 'Task', toolInput.taskId, {
                Status: 'Completed',
              });

              return {
                success: true,
                message: `Salesforce Task "${existingTask.Subject}" marked as completed`,
                data: {
                  taskId: toolInput.taskId,
                  subject: existingTask.Subject,
                  status: 'Completed',
                  completedDate: new Date().toISOString(),
                  source: 'salesforce',
                },
              };
            } catch (error) {
              // If permission error, fetch task details and provide actionable next steps
              const isPermissionError = error.message?.includes('INSUFFICIENT_ACCESS') ||
                                        error.message?.includes('insufficient access');

              if (isPermissionError) {
                try {
                  // Fetch task details to provide context
                  const taskQuery = `SELECT Id, Subject, Description, WhoId, WhatId, OwnerId, Owner.Name, ActivityDate, Status, Priority FROM Task WHERE Id = '${toolInput.taskId}'`;
                  const taskResult = await this.salesforceService.query(userId, taskQuery);
                  const task = taskResult.records?.[0];

                  if (task) {
                    // Get related contact/lead info if available
                    let relatedRecord: any = null;
                    if (task.WhoId) {
                      const whoPrefix = task.WhoId.substring(0, 3);
                      const whoType = whoPrefix === '00Q' ? 'Lead' : 'Contact';
                      const whoQuery = `SELECT Id, FirstName, LastName, Email, Phone, ${whoType === 'Lead' ? 'Company, Title' : 'Account.Name, Title'} FROM ${whoType} WHERE Id = '${task.WhoId}'`;
                      const whoResult = await this.salesforceService.query(userId, whoQuery);
                      relatedRecord = whoResult.records?.[0];
                    }

                    return {
                      success: false,
                      error: `Cannot update this task - it's owned by "${task.Owner?.Name || 'another user'}" and you don't have edit permissions.`,
                      taskDetails: {
                        id: task.Id,
                        subject: task.Subject,
                        description: task.Description,
                        status: task.Status,
                        priority: task.Priority,
                        dueDate: task.ActivityDate,
                        ownerName: task.Owner?.Name,
                      },
                      relatedPerson: relatedRecord ? {
                        id: relatedRecord.Id,
                        name: `${relatedRecord.FirstName || ''} ${relatedRecord.LastName || ''}`.trim(),
                        email: relatedRecord.Email,
                        phone: relatedRecord.Phone,
                        company: relatedRecord.Company || relatedRecord.Account?.Name,
                        title: relatedRecord.Title,
                        type: task.WhoId?.substring(0, 3) === '00Q' ? 'Lead' : 'Contact',
                      } : null,
                      suggestedActions: [
                        relatedRecord?.Email ? `Draft and send a follow-up email to ${relatedRecord.FirstName || 'them'} at ${relatedRecord.Email}` : null,
                        relatedRecord?.Phone ? `Call ${relatedRecord.FirstName || 'them'} at ${relatedRecord.Phone}` : null,
                        `Create a new task assigned to you to track this follow-up`,
                        `Log an activity note documenting the completed action`,
                        `Ask the task owner (${task.Owner?.Name}) to mark it as completed`,
                      ].filter(Boolean),
                      hint: 'I can help you complete the actual follow-up action (send email, make call, create note) even though I cannot mark this specific task as completed.',
                    };
                  }
                } catch (detailError) {
                  this.logger.warn(`[complete_task] Failed to fetch task details for permission error context: ${detailError.message}`);
                }
              }

              return {
                success: false,
                error: `Failed to complete Salesforce Task: ${error.message}`,
                hint: 'The task ID appears to be a Salesforce ID. Make sure you have Salesforce connected and you have permission to edit this task.',
              };
            }
          }

          // Local database update (original behavior)
          const task = await this.prisma.task.update({
            where: { id: toolInput.taskId },
            data: {
              status: 'COMPLETED',
              completedDate: new Date(),
            },
          });

          // Log completion note if provided
          if (toolInput.completionNotes) {
            await this.prisma.note.create({
              data: {
                userId,
                title: 'Task Completion Note',
                body: toolInput.completionNotes,
              },
            });
          }

          return {
            success: true,
            message: `Task "${task.subject}" marked as completed`,
            data: {
              taskId: task.id,
              subject: task.subject,
              completedDate: task.completedDate,
              source: 'local',
            },
          };
        }

        case 'delete_task': {
          const { target: deleteTaskTarget } = determineOperationTarget(toolInput.taskId);
          if (deleteTaskTarget === 'salesforce') {
            try {
              let sfTaskSubject: string | undefined;
              try {
                const sfTask = await this.salesforceService.query(userId, `SELECT Id, Subject FROM Task WHERE Id = '${toolInput.taskId}'`);
                sfTaskSubject = sfTask.records?.[0]?.Subject;
              } catch { /* ignore */ }
              await this.salesforceService.delete(userId, 'Task', toolInput.taskId);
              const sfDeleteTaskFacts: RecordDeleteFacts = { action_completed: true, record_deleted: true, record_id: toolInput.taskId, record_type: 'Task', record_name: sfTaskSubject, cascade_deleted: [] };
              return createHighRiskResult(true, sfDeleteTaskFacts, `Task "${sfTaskSubject || toolInput.taskId}" deleted successfully from Salesforce.`, { taskId: toolInput.taskId, source: 'salesforce' });
            } catch (error) {
              const isBlocked = error.message?.includes('ENTITY_IS_DELETED') || error.message?.includes('insufficient access') || error.message?.includes('DELETE_FAILED');
              const sfDeleteTaskFailFacts: RecordDeleteFacts = { action_completed: false, record_deleted: false, record_id: toolInput.taskId, record_type: 'Task', cascade_deleted: [], deletion_blocked: isBlocked, block_reason: isBlocked ? 'Insufficient access, record already deleted, or has dependent records' : error.message };
              return createHighRiskResult(false, sfDeleteTaskFailFacts, `Failed to delete Salesforce Task: ${sfDeleteTaskFailFacts.block_reason}`, undefined, error.message);
            }
          }
          try {
            const task = await this.prisma.task.findFirst({ where: { id: toolInput.taskId, ownerId: userId } });
            if (!task) {
              const notFoundFacts: RecordDeleteFacts = { action_completed: false, record_deleted: false, record_id: toolInput.taskId, record_type: 'Task', cascade_deleted: [], deletion_blocked: true, block_reason: 'Task not found or access denied' };
              return createHighRiskResult(false, notFoundFacts, `Task with ID "${toolInput.taskId}" not found.`, undefined, 'Task not found or access denied');
            }
            await this.prisma.task.delete({ where: { id: toolInput.taskId } });
            const deleteSuccessFacts: RecordDeleteFacts = { action_completed: true, record_deleted: true, record_id: toolInput.taskId, record_type: 'Task', record_name: task.subject, cascade_deleted: [] };
            return createHighRiskResult(true, deleteSuccessFacts, `Task "${task.subject}" deleted successfully.`, { taskId: toolInput.taskId, source: 'local' });
          } catch (error) {
            const deleteErrorFacts: RecordDeleteFacts = { action_completed: false, record_deleted: false, record_id: toolInput.taskId, record_type: 'Task', cascade_deleted: [], deletion_blocked: false, block_reason: error.message };
            return createHighRiskResult(false, deleteErrorFacts, `Failed to delete Task: ${deleteErrorFacts.block_reason}`, undefined, error.message);
          }
        }

        // LEAD DELETE
        case 'delete_lead': {
          const { target: deleteLeadTarget } = determineOperationTarget(toolInput.leadId);
          if (deleteLeadTarget === 'salesforce') {
            try {
              let sfLeadName: string | undefined;
              try {
                const sfLead = await this.salesforceService.query(userId, `SELECT Id, FirstName, LastName FROM Lead WHERE Id = '${toolInput.leadId}'`);
                if (sfLead.records?.[0]) sfLeadName = `${sfLead.records[0].FirstName || ''} ${sfLead.records[0].LastName || ''}`.trim();
              } catch { /* ignore */ }
              await this.salesforceService.delete(userId, 'Lead', toolInput.leadId);
              const sfDeleteLeadFacts: RecordDeleteFacts = { action_completed: true, record_deleted: true, record_id: toolInput.leadId, record_type: 'Lead', record_name: sfLeadName, cascade_deleted: [] };
              return createHighRiskResult(true, sfDeleteLeadFacts, `Lead "${sfLeadName || toolInput.leadId}" deleted successfully from Salesforce.`, { leadId: toolInput.leadId, source: 'salesforce' });
            } catch (error) {
              const isBlocked = error.message?.includes('ENTITY_IS_DELETED') || error.message?.includes('insufficient access') || error.message?.includes('DELETE_FAILED');
              const sfDeleteLeadFailFacts: RecordDeleteFacts = { action_completed: false, record_deleted: false, record_id: toolInput.leadId, record_type: 'Lead', cascade_deleted: [], deletion_blocked: isBlocked, block_reason: isBlocked ? 'Insufficient access, record already deleted, or has dependent records' : error.message };
              return createHighRiskResult(false, sfDeleteLeadFailFacts, `Failed to delete Salesforce Lead: ${sfDeleteLeadFailFacts.block_reason}`, undefined, error.message);
            }
          }
          try {
            const lead = await this.prisma.lead.findFirst({
              where: { id: toolInput.leadId, ownerId: userId },
              include: { tasks: { select: { id: true, subject: true } }, notes: { select: { id: true, title: true } } },
            });
            if (!lead) {
              const notFoundFacts: RecordDeleteFacts = { action_completed: false, record_deleted: false, record_id: toolInput.leadId, record_type: 'Lead', cascade_deleted: [], deletion_blocked: true, block_reason: 'Lead not found or access denied' };
              return createHighRiskResult(false, notFoundFacts, `Lead with ID "${toolInput.leadId}" not found.`, undefined, 'Lead not found or access denied');
            }
            const leadCascadeDeleted = [
              ...lead.tasks.map((t: any) => ({ type: 'Task', id: t.id, name: t.subject })),
              ...lead.notes.map((n: any) => ({ type: 'Note', id: n.id, name: n.title || 'Untitled Note' })),
            ];
            await this.prisma.lead.delete({ where: { id: toolInput.leadId } });
            const leadName = `${lead.firstName} ${lead.lastName}`;
            const deleteSuccessFacts: RecordDeleteFacts = { action_completed: true, record_deleted: true, record_id: toolInput.leadId, record_type: 'Lead', record_name: leadName, cascade_deleted: leadCascadeDeleted };
            let leadDeleteResponse = `Lead "${leadName}" deleted successfully.`;
            if (leadCascadeDeleted.length > 0) {
              leadDeleteResponse += `\n\u26A0\uFE0F Also deleted (cascade):`;
              if (lead.tasks.length > 0) leadDeleteResponse += `\n  - ${lead.tasks.length} Task(s)`;
              if (lead.notes.length > 0) leadDeleteResponse += `\n  - ${lead.notes.length} Note(s)`;
            }
            return createHighRiskResult(true, deleteSuccessFacts, leadDeleteResponse, { leadId: toolInput.leadId, source: 'local' });
          } catch (error) {
            const isBlocked = error.code === 'P2003' || error.message?.includes('constraint');
            const deleteErrorFacts: RecordDeleteFacts = { action_completed: false, record_deleted: false, record_id: toolInput.leadId, record_type: 'Lead', cascade_deleted: [], deletion_blocked: isBlocked, block_reason: isBlocked ? 'Has dependent records that prevent deletion' : error.message };
            return createHighRiskResult(false, deleteErrorFacts, `Failed to delete Lead: ${deleteErrorFacts.block_reason}`, undefined, error.message);
          }
        }

        // OPPORTUNITY DELETE
        case 'delete_opportunity': {
          // Detect if the opportunityId is a Salesforce ID and route appropriately
          const { target: deleteOppTarget } = determineOperationTarget(toolInput.opportunityId);

          if (deleteOppTarget === 'salesforce') {
            try {
              await this.salesforceService.delete(userId, 'Opportunity', toolInput.opportunityId);
              return {
                success: true,
                message: `Salesforce Opportunity deleted successfully`,
                data: { opportunityId: toolInput.opportunityId, source: 'salesforce' },
              };
            } catch (error) {
              return {
                success: false,
                error: `Failed to delete Salesforce Opportunity: ${error.message}`,
                hint: 'The opportunity ID appears to be a Salesforce ID. Make sure you have Salesforce connected.',
              };
            }
          }

          // Local database delete (original behavior)
          const opp = await this.prisma.opportunity.findFirst({
            where: { id: toolInput.opportunityId, ownerId: userId },
          });
          if (!opp) {
            throw new Error('Opportunity not found or access denied');
          }
          if (opp.isWon) {
            throw new Error('Cannot delete won opportunities');
          }

          await this.prisma.opportunity.delete({ where: { id: toolInput.opportunityId } });

          return {
            success: true,
            message: `Opportunity "${opp.name}" deleted successfully`,
          };
        }

        // TASK OPERATIONS
        case 'create_task': {
          this.logger.warn(`[CREATE_TASK] Input received: ${JSON.stringify(toolInput)}`);

          // Validate required field
          if (!toolInput.subject || toolInput.subject.trim() === '') {
            this.logger.warn(`[CREATE_TASK] Validation failed - subject missing or empty`);
            const facts: RecordCreateFacts = {
              action_completed: false,
              record_created: false,
              record_type: 'Task',
              fields_set: [],
              validation_errors: ['Task subject is required. Please provide a subject/title for the task.'],
            };
            return createHighRiskResult(false, facts, 'Failed to create Task: Task subject is required. Please provide a subject/title for the task.');
          }

          // Check if relatedTo contains a Salesforce ID - if so, route to Salesforce
          if (toolInput.relatedTo) {
            const [entityType, entityId] = toolInput.relatedTo.split(':');
            const { target: relatedTarget } = determineOperationTarget(entityId);

            if (relatedTarget === 'salesforce') {
              // Create task in Salesforce instead
              try {
                const sfTaskData: any = {
                  Subject: toolInput.subject,
                  Description: toolInput.description,
                  Status: 'Not Started',
                  Priority: toolInput.priority === 'HIGH' ? 'High' : toolInput.priority === 'LOW' ? 'Low' : 'Normal',
                };

                if (toolInput.dueDate) {
                  sfTaskData.ActivityDate = toolInput.dueDate;
                }

                // Set WhoId (Lead or Contact) or WhatId (Account or Opportunity) based on entity type
                if (entityType === 'lead' || entityType === 'contact') {
                  sfTaskData.WhoId = entityId;
                } else if (entityType === 'account' || entityType === 'opportunity') {
                  sfTaskData.WhatId = entityId;
                }

                const result = await this.salesforceService.create(userId, 'Task', sfTaskData);

                const sfFieldsSet = Object.keys(sfTaskData).filter(k => sfTaskData[k] !== undefined && sfTaskData[k] !== null);

                const sfFacts: RecordCreateFacts = {
                  action_completed: true,
                  record_created: true,
                  record_id: result.id,
                  record_type: 'Task',
                  record_name: sfTaskData.Subject,
                  fields_set: sfFieldsSet,
                  duplicate_detected: false,
                };

                const sfVerified = `Salesforce Task created successfully.
- ID: ${result.id}
- Subject: ${sfTaskData.Subject}
- Due Date: ${sfTaskData.ActivityDate || 'Not set'}
- Priority: ${sfTaskData.Priority}
- Related To: ${toolInput.relatedTo}
- Fields set: ${sfFieldsSet.join(', ')}`;

                return createHighRiskResult(true, sfFacts, sfVerified, {
                  taskId: result.id,
                  subject: sfTaskData.Subject,
                  dueDate: sfTaskData.ActivityDate,
                  priority: sfTaskData.Priority,
                  relatedTo: toolInput.relatedTo,
                  source: 'salesforce',
                });
              } catch (error) {
                const sfFacts: RecordCreateFacts = {
                  action_completed: false,
                  record_created: false,
                  record_type: 'Task',
                  fields_set: [],
                  validation_errors: [error.message],
                };
                return createHighRiskResult(false, sfFacts, `Failed to create Salesforce Task: ${error.message}`);
              }
            }
          }

          // Local database task creation (original behavior)
          const taskData: any = {
            ownerId: userId,
            assignedToId: userId,
            subject: toolInput.subject,
            description: toolInput.description,
            status: 'NOT_STARTED',
            priority: toolInput.priority || 'NORMAL',
          };

          if (toolInput.dueDate) {
            taskData.dueDate = new Date(toolInput.dueDate);
          }

          if (toolInput.relatedTo) {
            const [entityType, entityId] = toolInput.relatedTo.split(':');
            // Validate that the entityId is a local CUID before assigning
            if (IdValidator.isCUID(entityId)) {
              if (entityType === 'lead') taskData.leadId = entityId;
              else if (entityType === 'account') taskData.accountId = entityId;
              else if (entityType === 'contact') taskData.contactId = entityId;
              else if (entityType === 'opportunity') taskData.opportunityId = entityId;
            } else {
              const invalidIdFacts: RecordCreateFacts = {
                action_completed: false,
                record_created: false,
                record_type: 'Task',
                fields_set: [],
                validation_errors: [`Invalid ${entityType} ID format: "${entityId}". For Salesforce entities, ensure you have Salesforce connected.`],
              };
              return createHighRiskResult(false, invalidIdFacts, `Failed to create Task: Invalid ${entityType} ID format: "${entityId}". For Salesforce entities, ensure you have Salesforce connected.`);
            }
          }

          try {
            this.logger.warn(`[CREATE_TASK] Creating task with data: ${JSON.stringify(taskData)}`);
            const task = await this.prisma.task.create({ data: taskData });
            this.logger.warn(`[CREATE_TASK] Task created successfully: ${task.id}`);

            const fieldsSet = Object.keys(taskData).filter(k => taskData[k] !== undefined && taskData[k] !== null && k !== 'ownerId' && k !== 'assignedToId');

            const facts: RecordCreateFacts = {
              action_completed: true,
              record_created: true,
              record_id: task.id,
              record_type: 'Task',
              record_name: task.subject,
              fields_set: fieldsSet,
              duplicate_detected: false,
            };

            const verified_response = `Task "${task.subject}" created successfully.
- ID: ${task.id}
- Due Date: ${task.dueDate?.toISOString().split('T')[0] || 'Not set'}
- Priority: ${task.priority}
- Status: ${task.status}
- Fields set: ${fieldsSet.join(', ')}`;

            return createHighRiskResult(true, facts, verified_response, {
              taskId: task.id,
              subject: task.subject,
              dueDate: task.dueDate,
              priority: task.priority,
              source: 'local',
            });
          } catch (error) {
            const facts: RecordCreateFacts = {
              action_completed: false,
              record_created: false,
              record_type: 'Task',
              fields_set: [],
              validation_errors: [error.message],
            };
            return createHighRiskResult(false, facts, `Failed to create Task: ${error.message}`);
          }
        }

        case 'get_my_tasks': {
          // RESPECT dataSource parameter - only use Salesforce if explicitly requested
          const shouldUseSalesforceTasks = dataSource === 'salesforce';
          const sfStatusTasks = shouldUseSalesforceTasks
            ? await this.salesforceService.getConnectionStatus(userId)
            : { connected: false };

          if (shouldUseSalesforceTasks && sfStatusTasks.connected) {
            try {
              // Build SOQL WHERE clause based on filters
              const conditions: string[] = ['IsClosed = false'];

              // Map local status values to Salesforce Task Status values
              if (toolInput.status) {
                const statusMap: Record<string, string> = {
                  'NOT_STARTED': 'Not Started',
                  'IN_PROGRESS': 'In Progress',
                  'COMPLETED': 'Completed',
                  'WAITING': 'Waiting on someone else',
                  'DEFERRED': 'Deferred',
                };
                const sfStatus = statusMap[toolInput.status] || toolInput.status;
                conditions.push(`Status = '${sfStatus}'`);
              }

              // Map priority
              if (toolInput.priority) {
                const priorityMap: Record<string, string> = {
                  'HIGH': 'High',
                  'NORMAL': 'Normal',
                  'LOW': 'Low',
                };
                const sfPriority = priorityMap[toolInput.priority] || toolInput.priority;
                conditions.push(`Priority = '${sfPriority}'`);
              }

              // Due today filter
              if (toolInput.dueToday) {
                const today = new Date().toISOString().split('T')[0];
                conditions.push(`ActivityDate = ${today}`);
              }

              const soql = `SELECT Id, Subject, Status, Priority, ActivityDate, Description, Who.Name, What.Name
                            FROM Task
                            ${conditions.length > 0 ? 'WHERE ' + conditions.join(' AND ') : ''}
                            ORDER BY ActivityDate ASC NULLS LAST
                            LIMIT 20`;

              const result = await this.salesforceService.query(userId, soql);
              const sfTasks = result.records || [];

              const mappedTasks = sfTasks.map((t: any) => ({
                id: t.Id,
                subject: t.Subject,
                status: t.Status,
                priority: t.Priority,
                dueDate: t.ActivityDate,
                description: t.Description,
                relatedTo: t.What?.Name,
                whoName: t.Who?.Name,
              }));

              return {
                success: true,
                count: mappedTasks.length,
                data: mappedTasks,
                source: 'salesforce',
              };
            } catch (sfError) {
              this.logger.warn(`Salesforce get_my_tasks query failed, falling back to local: ${sfError.message}`);
              // Fall through to local database query
            }
          }

          // Local database fallback
          const where: any = {
            assignedToId: userId,
          };

          if (toolInput.status) where.status = toolInput.status;
          if (toolInput.priority) where.priority = toolInput.priority;
          if (toolInput.dueToday) {
            const today = new Date();
            today.setHours(0, 0, 0, 0);
            const tomorrow = new Date(today);
            tomorrow.setDate(tomorrow.getDate() + 1);
            where.dueDate = {
              gte: today,
              lt: tomorrow,
            };
          }

          const tasks = await this.prisma.task.findMany({
            where,
            orderBy: { dueDate: 'asc' },
          });

          return {
            success: true,
            count: tasks.length,
            data: tasks.map(t => ({
              id: t.id,
              subject: t.subject,
              status: t.status,
              priority: t.priority,
              dueDate: t.dueDate,
            })),
            source: 'local',
          };
        }

        // ACTIVITY OPERATIONS
        case 'log_activity': {
          try {
            const activityData: any = {
              userId: userId,
              type: toolInput.type,
              subject: toolInput.subject,
              description: toolInput.description,
              outcome: toolInput.outcome,
              activityDate: new Date(),
            };

            let relatedEntityType: string | undefined;
            let relatedEntityId: string | undefined;

            if (toolInput.relatedTo) {
              const [entityType, entityId] = toolInput.relatedTo.split(':');
              relatedEntityType = entityType;
              relatedEntityId = entityId;
              if (entityType === 'lead') activityData.leadId = entityId;
              else if (entityType === 'account') activityData.accountId = entityId;
              else if (entityType === 'contact') activityData.contactId = entityId;
              else if (entityType === 'opportunity') activityData.opportunityId = entityId;
            }

            const activity = await this.prisma.activity.create({ data: activityData });

            const activityFieldsSet = Object.keys(activityData).filter(k =>
              activityData[k] !== undefined && activityData[k] !== null && k !== 'userId'
            );

            const activityFacts: RecordCreateFacts = {
              action_completed: true,
              record_created: true,
              record_id: activity.id,
              record_type: 'Activity',
              record_name: activity.subject,
              fields_set: activityFieldsSet,
              duplicate_detected: false,
            };

            const activityVerifiedResponse = `Activity logged successfully.
- ID: ${activity.id}
- Type: ${activity.type}
- Subject: ${activity.subject}
- Date: ${activity.activityDate?.toISOString().split('T')[0] || 'Today'}${relatedEntityType ? `\n- Related To: ${relatedEntityType}:${relatedEntityId}` : ''}${activity.outcome ? `\n- Outcome: ${activity.outcome}` : ''}
- Fields set: ${activityFieldsSet.join(', ')}`;

            return createHighRiskResult(true, activityFacts, activityVerifiedResponse, {
              activityId: activity.id,
              type: activity.type,
              subject: activity.subject,
              relatedTo: toolInput.relatedTo,
            });
          } catch (error) {
            const activityFacts: RecordCreateFacts = {
              action_completed: false,
              record_created: false,
              record_type: 'Activity',
              fields_set: [],
              validation_errors: [error.message],
            };
            return createHighRiskResult(false, activityFacts, `Failed to log Activity: ${error.message}`);
          }
        }

        case 'get_activity_timeline': {
          const where: any = {};
          if (toolInput.entityType === 'lead') where.leadId = toolInput.entityId;
          else if (toolInput.entityType === 'account') where.accountId = toolInput.entityId;
          else if (toolInput.entityType === 'contact') where.contactId = toolInput.entityId;
          else if (toolInput.entityType === 'opportunity') where.opportunityId = toolInput.entityId;

          const activities = await this.prisma.activity.findMany({
            where,
            orderBy: { activityDate: 'desc' },
            take: 20,
          });

          return {
            success: true,
            count: activities.length,
            data: activities.map(a => ({
              id: a.id,
              type: a.type,
              subject: a.subject,
              outcome: a.outcome,
              date: a.activityDate,
              sentiment: a.sentiment,
            })),
          };
        }

        // ANALYTICS & INSIGHTS
        case 'get_forecast': {
          const forecast = await this.opportunitiesService.getForecast(organizationId, userId, false);

          // Build grounded result for forecast analysis
          // New API structure: { quarterRevenue, quarterBestCase, quarterCommit, confidence, quarterName, opportunityCount, monthly: [...] }
          const monthlyData = forecast.monthly || [];
          const forecastCaveats: string[] = [];

          // Use pre-calculated totals from API
          const totalBestCase = forecast.quarterBestCase || 0;
          const totalMostLikely = forecast.quarterRevenue || 0;
          const totalCommit = forecast.quarterCommit || 0;
          const quarterName = forecast.quarterName || `Q${Math.floor(new Date().getMonth() / 3) + 1} ${new Date().getFullYear()}`;
          const oppCount = forecast.opportunityCount || 0;

          if (oppCount === 0) {
            forecastCaveats.push('No open opportunities with close dates in this quarter');
          }
          if (totalMostLikely === 0 && totalBestCase > 0) {
            forecastCaveats.push('Expected revenue not set on opportunities - mostLikely values may be inaccurate');
          }

          const forecastConfidence: 'high' | 'medium' | 'low' =
            (forecast.confidence?.toLowerCase() as 'high' | 'medium' | 'low') || 'low';

          const forecastFacts: AnalysisFacts = {
            action_completed: true,
            analysis_completed: true,
            data_sources_used: ['opportunity_pipeline'],
            records_analyzed: oppCount,
            confidence_level: forecastConfidence,
            data_freshness: `as of ${new Date().toISOString().split('T')[0]}`,
            caveats: forecastCaveats,
            methodology: 'Opportunity-based forecast: bestCase=sum of all amounts, mostLikely=sum of expected revenue, commit=high-probability deals (>=75%)',
          };

          // Build verified response - prevents AI from inventing forecast numbers
          let forecastVerifiedResponse = `## ${quarterName} Sales Forecast\n`;
          forecastVerifiedResponse += `**Confidence:** ${forecastConfidence.toUpperCase()}\n`;
          forecastVerifiedResponse += `**Data as of:** ${forecastFacts.data_freshness}\n`;
          forecastVerifiedResponse += `**Opportunities:** ${oppCount}\n\n`;

          forecastVerifiedResponse += `### ${quarterName} Totals\n`;
          forecastVerifiedResponse += `- **Forecast (Most Likely):** $${totalMostLikely.toLocaleString()}\n`;
          forecastVerifiedResponse += `- Best Case: $${totalBestCase.toLocaleString()}\n`;
          forecastVerifiedResponse += `- Commit (High Probability): $${totalCommit.toLocaleString()}\n\n`;

          if (monthlyData.length > 0) {
            forecastVerifiedResponse += `### By Month\n`;
            monthlyData.slice(0, 6).forEach((m: any) => {
              forecastVerifiedResponse += `- ${m.month}: Best $${(m.bestCase || 0).toLocaleString()} | Likely $${(m.mostLikely || 0).toLocaleString()} | Commit $${(m.commit || 0).toLocaleString()}\n`;
            });
          }

          if (forecastCaveats.length > 0) {
            forecastVerifiedResponse += `\n### Limitations\n`;
            forecastCaveats.forEach(c => {
              forecastVerifiedResponse += `- ${c}\n`;
            });
          }

          return createMediumRiskResult(true, forecastFacts, forecastVerifiedResponse, forecast);
        }

        case 'get_recommended_actions': {
          // Get high-scoring leads that haven't been contacted recently
          const topLeadsResult = await this.leadsService.findAll(userId, organizationId, {
            minScore: 75,
          }, false);
          const topLeads = Array.isArray(topLeadsResult) ? topLeadsResult : topLeadsResult.data;

          // Get opportunities closing soon
          const opportunitiesResult = await this.opportunitiesService.listOpportunities({ ownerId: userId }, organizationId, false);
          const opportunities = Array.isArray(opportunitiesResult) ? opportunitiesResult : opportunitiesResult.data;
          const closingSoon = opportunities.filter(o => {
            if (!o.closeDate || o.isClosed) return false;
            const daysUntilClose = Math.floor((new Date(o.closeDate).getTime() - Date.now()) / (1000 * 60 * 60 * 24));
            return daysUntilClose <= 30 && daysUntilClose > 0;
          });

          // Get overdue tasks
          const overdueTasks = await this.prisma.task.findMany({
            where: {
              assignedToId: userId,
              status: { not: 'COMPLETED' },
              dueDate: { lt: new Date() },
            },
            take: 5,
          });

          const recommendations: Array<{
            type: string;
            priority: string;
            action: string;
            reason: string;
            data: Record<string, any>;
          }> = [];

          if (topLeads.length > 0) {
            recommendations.push({
              type: 'high_priority_lead',
              priority: 'HIGH',
              action: `Reach out to ${topLeads[0].firstName} ${topLeads[0].lastName} at ${topLeads[0].company}`,
              reason: `High lead score (${topLeads[0].leadScore}/100) and ${topLeads[0].buyingIntent} buying intent`,
              data: { leadId: topLeads[0].id },
            });
          }

          if (closingSoon.length > 0 && closingSoon[0].closeDate) {
            recommendations.push({
              type: 'opportunity_closing_soon',
              priority: 'URGENT',
              action: `Follow up on ${closingSoon[0].name}`,
              reason: `Closes in ${Math.floor((new Date(closingSoon[0].closeDate).getTime() - Date.now()) / (1000 * 60 * 60 * 24))} days`,
              data: { opportunityId: closingSoon[0].id },
            });
          }

          if (overdueTasks.length > 0 && overdueTasks[0].dueDate) {
            recommendations.push({
              type: 'overdue_task',
              priority: 'HIGH',
              action: `Complete overdue task: ${overdueTasks[0].subject}`,
              reason: `Due ${Math.floor((Date.now() - new Date(overdueTasks[0].dueDate).getTime()) / (1000 * 60 * 60 * 24))} days ago`,
              data: { taskId: overdueTasks[0].id },
            });
          }

          return {
            success: true,
            count: recommendations.length,
            data: recommendations,
          };
        }

        // WEB RESEARCH TOOL HANDLERS
        case 'web_search': {
          if (!this.searchService.isEnabled()) {
            return {
              success: false,
              error: 'Web search is not configured. Please set GOOGLE_SEARCH_API_KEY and GOOGLE_SEARCH_ENGINE_ID environment variables.',
            };
          }

          const searchResult = await this.searchService.webSearch(toolInput.query);
          return {
            success: true,
            message: `Found ${searchResult.totalResults} results for "${toolInput.query}"`,
            data: {
              query: searchResult.query,
              totalResults: searchResult.totalResults,
              searchTime: searchResult.searchTime,
              results: searchResult.searchResults.slice(0, 5).map(r => ({
                title: r.title,
                link: r.link,
                snippet: r.snippet,
                source: r.displayLink,
              })),
            },
          };
        }

        case 'research_company': {
          if (!this.searchService.isEnabled()) {
            return {
              success: false,
              error: 'Web search is not configured. Please set GOOGLE_SEARCH_API_KEY and GOOGLE_SEARCH_ENGINE_ID environment variables.',
            };
          }

          // Handle various parameter name variations the AI might use
          const companyInput = toolInput.companyUrlOrName || toolInput.company || toolInput.name || toolInput.companyName || toolInput.query;

          if (!companyInput) {
            return {
              success: false,
              error: 'Company name or URL is required. Please provide the company to research.',
            };
          }

          const includeNews = toolInput.includeNews !== false;
          const includeLeadership = toolInput.includeLeadership !== false;
          const includeJobs = toolInput.includeJobs !== false;
          const includeCompetitors = toolInput.includeCompetitors === true;

          // Extract company name
          let companyName = companyInput;
          try {
            const url = new URL(
              companyInput.startsWith('http')
                ? companyInput
                : `https://${companyInput}`
            );
            companyName = url.hostname.replace('www.', '').split('.')[0];
          } catch {
            // Use as-is
          }

          // Gather research in parallel (including financial data)
          const researchPromises: Promise<any>[] = [
            this.searchService.researchCompany(companyInput),
          ];

          if (includeNews) researchPromises.push(this.searchService.searchCompanyNews(companyName));
          if (includeLeadership) researchPromises.push(this.searchService.searchLeadership(companyName));
          if (includeCompetitors) researchPromises.push(this.searchService.searchCompetitors(companyName));
          if (includeJobs) researchPromises.push(this.searchService.searchJobPostings(companyName));

          // Fetch financial data in parallel (non-blocking, optional)
          const financialPromise = this.financialDataService.isEnabled()
            ? this.financialDataService.getFinancialData(companyName).catch((err) => {
                this.logger.warn(`[research_company] Financial data fetch failed: ${err.message}`);
                return null;
              })
            : Promise.resolve(null);

          const [results, financialData] = await Promise.all([
            Promise.all(researchPromises),
            financialPromise,
          ]);

          const companyResearch = results[0];
          let idx = 1;
          const newsResearch = includeNews ? results[idx++] : null;
          const leadershipResearch = includeLeadership ? results[idx++] : null;
          const competitorResearch = includeCompetitors ? results[idx++] : null;
          const jobsResearch = includeJobs ? results[idx++] : null;

          // === AUTO-SEARCH CRM for existing records ===
          let crmRecords: any = null;
          try {
            if (dataSource === 'salesforce') {
              // Search Salesforce for matching accounts, leads, contacts using the service query method
              const searchTerm = companyName.replace(/['"]/g, '').replace(/\\/g, '');
              const [accounts, leads, contacts] = await Promise.all([
                this.salesforceService.query(userId, `SELECT Id, Name, Industry, Website, Phone, BillingCity FROM Account WHERE Name LIKE '%${searchTerm}%' LIMIT 5`).catch(() => ({ records: [] })),
                this.salesforceService.query(userId, `SELECT Id, FirstName, LastName, Company, Email, Phone, Status FROM Lead WHERE Company LIKE '%${searchTerm}%' LIMIT 5`).catch(() => ({ records: [] })),
                this.salesforceService.query(userId, `SELECT Id, FirstName, LastName, Email, Phone, Account.Name FROM Contact WHERE Account.Name LIKE '%${searchTerm}%' LIMIT 5`).catch(() => ({ records: [] })),
              ]);
              crmRecords = {
                source: 'Salesforce',
                accounts: accounts.records || [],
                leads: leads.records || [],
                contacts: contacts.records || [],
                hasExistingRecords: (accounts.records?.length > 0 || leads.records?.length > 0 || contacts.records?.length > 0),
              };
            } else {
              // Search local IRIS database
              const [accounts, leads, contacts] = await Promise.all([
                this.prisma.account.findMany({ where: { ownerId: userId, name: { contains: companyName, mode: 'insensitive' } }, take: 5 }).catch(() => []),
                this.prisma.lead.findMany({ where: { ownerId: userId, company: { contains: companyName, mode: 'insensitive' } }, take: 5 }).catch(() => []),
                this.prisma.contact.findMany({ where: { ownerId: userId, OR: [{ firstName: { contains: companyName, mode: 'insensitive' } }, { lastName: { contains: companyName, mode: 'insensitive' } }] }, take: 5 }).catch(() => []),
              ]);
              crmRecords = {
                source: 'IRIS (Local)',
                accounts: accounts || [],
                leads: leads || [],
                contacts: contacts || [],
                hasExistingRecords: (accounts?.length > 0 || leads?.length > 0 || contacts?.length > 0),
              };
            }
          } catch (crmError) {
            this.logger.warn(`[research_company] CRM lookup failed: ${crmError.message}`);
          }

          return {
            success: true,
            message: `Completed research on ${companyName}`,
            data: {
              company: {
                name: companyResearch.companyInfo?.name || companyName,
                website: companyResearch.companyInfo?.website || companyInput,
                description: companyResearch.companyInfo?.description,
                industry: companyResearch.companyInfo?.industry,
                socialLinks: companyResearch.companyInfo?.socialLinks,
                topResults: companyResearch.searchResults.slice(0, 3).map((r: any) => ({
                  title: r.title,
                  snippet: r.snippet,
                  link: r.link,
                })),
              },
              ...(newsResearch && {
                recentNews: newsResearch.searchResults.slice(0, 3).map((r: any) => ({
                  title: r.title,
                  snippet: r.snippet,
                  link: r.link,
                })),
              }),
              ...(leadershipResearch && {
                leadership: leadershipResearch.searchResults.slice(0, 3).map((r: any) => ({
                  title: r.title,
                  snippet: r.snippet,
                  link: r.link,
                })),
              }),
              ...(competitorResearch && {
                competitors: competitorResearch.searchResults.slice(0, 3).map((r: any) => ({
                  title: r.title,
                  snippet: r.snippet,
                  link: r.link,
                })),
              }),
              ...(jobsResearch && {
                jobPostings: jobsResearch.searchResults.slice(0, 3).map((r: any) => ({
                  title: r.title,
                  snippet: r.snippet,
                  link: r.link,
                })),
              }),
              // Include CRM records in response
              ...(crmRecords && {
                existingCrmRecords: crmRecords,
              }),
              // Include financial/stock data if available
              ...(financialData && !financialData.error && {
                financialData: {
                  symbol: financialData.symbol,
                  isPublicCompany: financialData.symbol !== 'PRIVATE',
                  ...(financialData.quote && {
                    stockQuote: {
                      price: financialData.quote.price,
                      change: financialData.quote.change,
                      changePercent: financialData.quote.changePercent,
                      formattedPrice: `$${financialData.quote.price?.toFixed(2)}`,
                      formattedChange: `${financialData.quote.change >= 0 ? '+' : ''}${financialData.quote.change?.toFixed(2)}`,
                      formattedChangePercent: `${financialData.quote.changePercent >= 0 ? '+' : ''}${financialData.quote.changePercent?.toFixed(2)}%`,
                      high: financialData.quote.high,
                      low: financialData.quote.low,
                      open: financialData.quote.open,
                      previousClose: financialData.quote.previousClose,
                      volume: financialData.quote.volume,
                      marketCap: financialData.quote.marketCap,
                      formattedMarketCap: financialData.quote.marketCap ? this.financialDataService.formatCurrency(financialData.quote.marketCap) : undefined,
                      peRatio: financialData.quote.peRatio,
                      eps: financialData.quote.eps,
                      dividend: financialData.quote.dividend,
                      dividendYield: financialData.quote.dividendYield,
                      week52High: financialData.quote.week52High,
                      week52Low: financialData.quote.week52Low,
                      timestamp: financialData.quote.timestamp,
                    },
                  }),
                  // Historical prices for charting (last 30 days)
                  ...(financialData.historicalPrices && financialData.historicalPrices.length > 0 && {
                    historicalPrices: financialData.historicalPrices.map((p) => ({
                      date: p.date,
                      close: p.close,
                      volume: p.volume,
                    })),
                    chartData: {
                      type: 'stock_price',
                      title: `${financialData.symbol} Stock Price (30 Days)`,
                      data: financialData.historicalPrices.map((p) => ({
                        date: p.date,
                        price: p.close,
                      })),
                    },
                  }),
                  ...(financialData.metrics && {
                    metrics: {
                      revenue: financialData.metrics.revenue,
                      formattedRevenue: financialData.metrics.revenue ? this.financialDataService.formatCurrency(financialData.metrics.revenue) : undefined,
                      grossProfit: financialData.metrics.grossProfit,
                      ebitda: financialData.metrics.ebitda,
                      fiscalYear: financialData.metrics.fiscalYear,
                    },
                  }),
                },
              }),
              // Note if financial data unavailable
              ...(financialData?.error && {
                financialDataNote: financialData.error,
              }),
              ...(!financialData && {
                financialDataNote: 'Financial data not available for this company',
              }),
            },
          };
        }

        case 'search_company_news': {
          if (!this.searchService.isEnabled()) {
            return {
              success: false,
              error: 'Web search is not configured. Please set GOOGLE_SEARCH_API_KEY and GOOGLE_SEARCH_ENGINE_ID environment variables.',
            };
          }

          const days = toolInput.days || 30;
          const newsResult = await this.searchService.searchCompanyNews(toolInput.companyName, days);

          return {
            success: true,
            message: `Found ${newsResult.totalResults} news items for ${toolInput.companyName} in the last ${days} days`,
            data: {
              company: toolInput.companyName,
              period: `Last ${days} days`,
              totalResults: newsResult.totalResults,
              news: newsResult.searchResults.slice(0, 5).map(r => ({
                title: r.title,
                snippet: r.snippet,
                link: r.link,
                source: r.displayLink,
              })),
            },
          };
        }

        case 'search_competitors': {
          if (!this.searchService.isEnabled()) {
            return {
              success: false,
              error: 'Web search is not configured. Please set GOOGLE_SEARCH_API_KEY and GOOGLE_SEARCH_ENGINE_ID environment variables.',
            };
          }

          const competitorResult = await this.searchService.searchCompetitors(
            toolInput.companyName,
            toolInput.industry
          );

          return {
            success: true,
            message: `Found competitor information for ${toolInput.companyName}`,
            data: {
              company: toolInput.companyName,
              industry: toolInput.industry || 'Not specified',
              totalResults: competitorResult.totalResults,
              competitors: competitorResult.searchResults.slice(0, 5).map(r => ({
                title: r.title,
                snippet: r.snippet,
                link: r.link,
                source: r.displayLink,
              })),
            },
          };
        }

        case 'search_leadership': {
          if (!this.searchService.isEnabled()) {
            return {
              success: false,
              error: 'Web search is not configured. Please set GOOGLE_SEARCH_API_KEY and GOOGLE_SEARCH_ENGINE_ID environment variables.',
            };
          }

          const leadershipResult = await this.searchService.searchLeadership(toolInput.companyName);

          return {
            success: true,
            message: `Found leadership information for ${toolInput.companyName}`,
            data: {
              company: toolInput.companyName,
              totalResults: leadershipResult.totalResults,
              leadership: leadershipResult.searchResults.slice(0, 5).map(r => ({
                title: r.title,
                snippet: r.snippet,
                link: r.link,
                source: r.displayLink,
              })),
            },
          };
        }

        // DOCUMENT INTELLIGENCE TOOL HANDLERS - PageIndex Integration
        case 'list_indexed_documents': {
          try {
            const result = await this.pageIndexService.listDocuments();
            if (!result.documents || result.documents.length === 0) {
              return {
                success: true,
                message: 'No documents have been indexed yet. Upload PDFs via the Context Manager to enable document search.',
                data: { documents: [] },
              };
            }
            return {
              success: true,
              message: `Found ${result.documents.length} indexed document(s)`,
              data: {
                documents: result.documents.map(doc => ({
                  id: doc.document_id,
                  filename: doc.filename,
                  indexedAt: doc.indexed_at,
                })),
              },
            };
          } catch (error) {
            return {
              success: false,
              error: 'Document indexing service is not available. Make sure PageIndex service is running.',
            };
          }
        }

        case 'search_document': {
          try {
            let documentId = toolInput.documentId;

            // Auto-correct document ID if it doesn't match an actual document
            // This handles cases where AI guesses incorrect IDs like "brainwave-platform.pdf"
            const docList = await this.pageIndexService.listDocuments();
            if (docList.documents && docList.documents.length > 0) {
              const exactMatch = docList.documents.find(d => d.document_id === documentId);
              if (!exactMatch) {
                // Try fuzzy matching - find document that contains the search term in filename
                const searchTerms = documentId.toLowerCase().replace(/[_\-\.]/g, ' ').split(' ').filter(t => t.length > 2);
                const fuzzyMatch = docList.documents.find(doc => {
                  const docName = (doc.filename || doc.document_id || '').toLowerCase();
                  return searchTerms.some(term => docName.includes(term));
                });

                if (fuzzyMatch) {
                  this.logger.log(`Auto-corrected document ID: "${documentId}" â†’ "${fuzzyMatch.document_id}"`);
                  documentId = fuzzyMatch.document_id;
                } else {
                  // If no match, use first document as fallback
                  this.logger.log(`No document match for "${documentId}", using first available: "${docList.documents[0].document_id}"`);
                  documentId = docList.documents[0].document_id;
                }
              }
            }

            const maxResults = toolInput.maxResults || 5;
            const searchResults = await this.pageIndexService.searchDocument(
              documentId,
              toolInput.query,
              maxResults,
            );

            if (!searchResults || searchResults.length === 0) {
              return {
                success: true,
                message: `No relevant sections found for "${toolInput.query}" in document ${documentId}`,
                data: { results: [], documentId },
              };
            }

            return {
              success: true,
              message: `Found ${searchResults.length} relevant section(s) for "${toolInput.query}"`,
              data: {
                documentId: documentId,
                query: toolInput.query,
                results: searchResults.map(r => ({
                  nodeId: r.node_id,
                  title: r.title,
                  summary: r.summary,
                  relevanceScore: r.relevance_score,
                  pages: `${r.start_page}-${r.end_page}`,
                })),
              },
            };
          } catch (error) {
            return {
              success: false,
              error: `Failed to search document: ${error.message}. Make sure the document ID is correct.`,
            };
          }
        }

        case 'get_document_structure': {
          try {
            const docTree = await this.pageIndexService.getDocumentTree(toolInput.documentId);

            // Extract a simplified structure for the AI
            const simplifyStructure = (node: any, depth: number = 0): any => {
              const simplified: any = {
                title: node.title,
                pages: `${node.start_index || node.start_page || '?'}-${node.end_index || node.end_page || '?'}`,
              };
              if (node.summary) {
                simplified.summary = node.summary.substring(0, 200) + (node.summary.length > 200 ? '...' : '');
              }
              if (node.nodes && node.nodes.length > 0 && depth < 2) {
                simplified.sections = node.nodes.map((n: any) => simplifyStructure(n, depth + 1));
              }
              return simplified;
            };

            const structure = docTree.structure?.structure || docTree.structure || docTree;

            return {
              success: true,
              message: `Retrieved structure for document: ${docTree.filename || toolInput.documentId}`,
              data: {
                documentId: toolInput.documentId,
                filename: docTree.filename,
                structure: Array.isArray(structure)
                  ? structure.map(s => simplifyStructure(s))
                  : simplifyStructure(structure),
              },
            };
          } catch (error) {
            return {
              success: false,
              error: `Failed to get document structure: ${error.message}`,
            };
          }
        }

        case 'get_document_summary': {
          try {
            const docTree = await this.pageIndexService.getDocumentTree(toolInput.documentId);

            // Extract all summaries from the document structure
            const extractSummaries = (node: any, depth: number = 0): any => {
              const section: any = {
                title: node.title,
                pages: `${node.start_index || node.start_page || '?'}-${node.end_index || node.end_page || '?'}`,
              };

              // Include full summary for main sections
              if (node.summary) {
                section.summary = depth < 2 ? node.summary : node.summary.substring(0, 300) + (node.summary.length > 300 ? '...' : '');
              }

              // Recursively get subsection summaries (up to depth 3)
              if (node.nodes && node.nodes.length > 0 && depth < 3) {
                section.subsections = node.nodes.map((n: any) => extractSummaries(n, depth + 1));
              }

              return section;
            };

            const structure = docTree.structure?.structure || docTree.structure || docTree;
            const summaries = Array.isArray(structure)
              ? structure.map(s => extractSummaries(s))
              : [extractSummaries(structure)];

            // Count total sections
            const countSections = (sections: any[]): number => {
              return sections.reduce((count, s) => {
                return count + 1 + (s.subsections ? countSections(s.subsections) : 0);
              }, 0);
            };

            const totalSections = countSections(summaries);

            return {
              success: true,
              message: `Generated comprehensive summary for "${docTree.filename || toolInput.documentId}" with ${totalSections} sections`,
              data: {
                documentId: toolInput.documentId,
                filename: docTree.filename,
                totalSections,
                sections: summaries,
              },
            };
          } catch (error) {
            return {
              success: false,
              error: `Failed to get document summary: ${error.message}`,
            };
          }
        }

        // ==================== EMAIL TOOL HANDLERS ====================
        case 'send_email': {
          try {
            this.logger.log(`[SEND_EMAIL] Tool called with input: ${JSON.stringify({ to: toolInput.to, subject: toolInput.subject, bodyLength: toolInput.body?.length || 0 })}`);
            const { to, subject, body } = toolInput;

            // Validate recipients
            const recipients = Array.isArray(to) ? to : [to];
            if (recipients.length === 0) {
              this.logger.warn('[SEND_EMAIL] No recipients specified');
              const noRecipientFacts: EmailSendFacts = {
                action_completed: false,
                email_sent: false,
                recipients: [],
                failed_recipients: [],
                delivery_status: 'failed',
                subject: subject || '',
                failure_reason: 'No recipients specified',
              };
              const noRecipientResponse = RESPONSE_TEMPLATES.send_email.failure(noRecipientFacts);
              return createCriticalResult(false, noRecipientFacts, noRecipientResponse, undefined, 'No recipients specified');
            }

            // Check if email service is available
            this.logger.log(`[SEND_EMAIL] Checking email service: configured=${!!this.emailService}, ready=${this.emailService?.isReady()}`);
            if (!this.emailService || !this.emailService.isReady()) {
              this.logger.error('[SEND_EMAIL] Email service is not configured or not ready');
              const notConfiguredFacts: EmailSendFacts = {
                action_completed: false,
                email_sent: false,
                recipients,
                failed_recipients: recipients,
                delivery_status: 'failed',
                subject: subject || '',
                failure_reason: 'Email service is not configured. Please set GMAIL_USER and GMAIL_APP_PASSWORD in the environment.',
              };
              const notConfiguredResponse = RESPONSE_TEMPLATES.send_email.failure(notConfiguredFacts);
              return createCriticalResult(false, notConfiguredFacts, notConfiguredResponse, undefined, notConfiguredFacts.failure_reason);
            }

            // Use the EmailTrackingService to send tracked emails
            // This ensures replies can be matched and auto-drafts generated
            this.logger.log(`[SEND_EMAIL] Sending tracked email to: ${recipients[0]}, subject: ${subject}`);
            const result = await this.emailTrackingService.sendTrackedEmail({
              to: recipients[0], // Primary recipient
              subject,
              body: body || '',
            }, userId);

            this.logger.log(`[SEND_EMAIL] Result: sent=${result.sent}, trackingId=${result.trackingId}`);

            // Build explicit facts about what happened
            const sendFacts: EmailSendFacts = {
              action_completed: true,
              email_sent: result.sent,
              recipients,
              failed_recipients: result.sent ? [] : recipients,
              delivery_status: result.sent ? 'sent' : 'failed',
              message_id: result.trackingId,
              thread_id: result.thread?.id,
              subject: subject || '',
              failure_reason: result.sent ? undefined : 'Email was tracked but failed to send',
            };

            // Use template for verified response
            const sendResponse = sendFacts.email_sent
              ? RESPONSE_TEMPLATES.send_email.success(sendFacts)
              : RESPONSE_TEMPLATES.send_email.failure(sendFacts);

            // Return grounded result with backward compatibility
            return createCriticalResult(
              sendFacts.email_sent,
              sendFacts,
              sendResponse,
              {
                recipients,
                subject,
                threadId: result.thread?.id,
                trackingId: result.trackingId,
              }
            );
          } catch (error) {
            this.logger.error(`[SEND_EMAIL] Failed to send email: ${error.message}`, error.stack);
            const errorFacts: EmailSendFacts = {
              action_completed: false,
              email_sent: false,
              recipients: Array.isArray(toolInput.to) ? toolInput.to : [toolInput.to].filter(Boolean),
              failed_recipients: Array.isArray(toolInput.to) ? toolInput.to : [toolInput.to].filter(Boolean),
              delivery_status: 'failed',
              subject: toolInput.subject || '',
              failure_reason: error.message,
            };
            const errorResponse = RESPONSE_TEMPLATES.send_email.failure(errorFacts);
            return createCriticalResult(false, errorFacts, errorResponse, undefined, `Failed to send email: ${error.message}`);
          }
        }

        case 'get_email_threads': {
          try {
            const threads = await this.emailTrackingService.getThreads(userId, {
              status: toolInput.status,
            });

            // Calculate overdue status for each thread
            const now = new Date();
            const threadsWithOverdue = threads.map((thread: any) => {
              const lastEmailAt = new Date(thread.lastEmailAt);
              const daysSinceLastEmail = Math.floor((now.getTime() - lastEmailAt.getTime()) / (1000 * 60 * 60 * 24));
              const isOverdue = thread.status === 'AWAITING_RESPONSE' && daysSinceLastEmail > 3;
              return {
                ...thread,
                daysSinceLastEmail,
                isOverdue,
                overdueMessage: isOverdue ? `No response in ${daysSinceLastEmail} days` : null,
              };
            });

            return {
              success: true,
              count: threadsWithOverdue.length,
              threads: threadsWithOverdue,
            };
          } catch (error) {
            this.logger.error(`Failed to get email threads: ${error.message}`, error.stack);
            return { success: false, error: `Failed to get email threads: ${error.message}` };
          }
        }

        case 'get_awaiting_responses': {
          try {
            const threads = await this.emailTrackingService.getThreadsAwaitingResponse(userId);

            // Calculate overdue status
            const now = new Date();
            const threadsWithOverdue = threads.map((thread: any) => {
              const lastEmailAt = new Date(thread.lastEmailAt);
              const daysSinceLastEmail = Math.floor((now.getTime() - lastEmailAt.getTime()) / (1000 * 60 * 60 * 24));
              const isOverdue = daysSinceLastEmail > 3;
              return {
                id: thread.id,
                subject: thread.subject,
                recipient: thread.emails?.[0]?.toEmails?.[0] || 'Unknown',
                lastEmailAt: thread.lastEmailAt,
                daysSinceLastEmail,
                isOverdue,
                overdueMessage: isOverdue ? `OVERDUE: No response in ${daysSinceLastEmail} days` : `Waiting ${daysSinceLastEmail} day${daysSinceLastEmail !== 1 ? 's' : ''}`,
                totalEmails: thread.totalEmails,
              };
            });

            const overdueCount = threadsWithOverdue.filter((t: any) => t.isOverdue).length;

            return {
              success: true,
              count: threadsWithOverdue.length,
              overdueCount,
              message: overdueCount > 0
                ? `${overdueCount} of ${threadsWithOverdue.length} emails are overdue (no response in 3+ days)`
                : `${threadsWithOverdue.length} emails awaiting response`,
              threads: threadsWithOverdue,
            };
          } catch (error) {
            this.logger.error(`Failed to get awaiting responses: ${error.message}`, error.stack);
            return { success: false, error: `Failed to get awaiting responses: ${error.message}` };
          }
        }

        case 'get_thread_messages': {
          try {
            const { threadId } = toolInput;
            if (!threadId) {
              return { success: false, error: 'Thread ID is required' };
            }

            const thread = await this.emailTrackingService.getThread(threadId, userId) as any;

            // Format messages with full content for easy reading
            const messages = thread.emails.map((email: any) => {
              // Strip HTML tags for plain text version if needed
              const plainText = email.bodyText || email.bodyHtml?.replace(/<[^>]*>/g, '').replace(/&nbsp;/g, ' ').replace(/\s+/g, ' ').trim() || '';
              
              return {
                id: email.id,
                direction: email.direction, // INBOUND or OUTBOUND
                from: email.fromEmail,
                fromName: email.fromName,
                to: email.toEmails,
                cc: email.ccEmails,
                subject: email.subject,
                body: plainText,
                bodyHtml: email.bodyHtml,
                sentAt: email.direction === 'OUTBOUND' ? email.sentAt : null,
                receivedAt: email.direction === 'INBOUND' ? email.receivedAt : null,
                createdAt: email.createdAt,
              };
            });

            return {
              success: true,
              threadId: thread.id,
              subject: thread.subject,
              status: thread.status,
              totalMessages: messages.length,
              messages,
              lead: thread.lead ? {
                id: thread.lead.id,
                name: `${thread.lead.firstName} ${thread.lead.lastName}`,
                email: thread.lead.email,
                company: thread.lead.company,
              } : null,
            };
          } catch (error) {
            this.logger.error(`Failed to get thread messages: ${error.message}`, error.stack);
            return { success: false, error: `Failed to get thread messages: ${error.message}` };
          }
        }

        case 'get_email_drafts': {
          try {
            const { threadId } = toolInput;
            const drafts = await this.emailTrackingService.getPendingDrafts(userId, threadId);
            return {
              success: true,
              count: drafts.length,
              message: drafts.length > 0
                ? `${drafts.length} AI-drafted response${drafts.length !== 1 ? 's' : ''} ready for review`
                : 'No pending drafts',
              drafts: drafts.map((draft: any) => ({
                id: draft.id,
                subject: draft.subject,
                recipient: draft.toEmails?.[0] || 'Unknown',
                recipients: draft.toEmails || [],
                bodyHtml: draft.bodyHtml,
                bodyText: draft.bodyText,
                preview: (draft.bodyText || draft.bodyHtml?.replace(/<[^>]*>/g, '') || '').substring(0, 200) + '...',
                createdAt: draft.createdAt,
                threadId: draft.threadId,
                confidence: draft.confidence,
                tone: draft.tone,
                inReplyTo: draft.inReplyToMessage ? {
                  from: draft.inReplyToMessage.fromEmail,
                  fromName: draft.inReplyToMessage.fromName,
                  subject: draft.inReplyToMessage.subject,
                  receivedAt: draft.inReplyToMessage.receivedAt,
                } : null,
              })),
            };
          } catch (error) {
            this.logger.error(`Failed to get email drafts: ${error.message}`, error.stack);
            return { success: false, error: `Failed to get email drafts: ${error.message}` };
          }
        }

        case 'send_email_draft': {
          try {
            const { draftId } = toolInput;
            const result = await this.emailTrackingService.sendDraft(draftId, userId);

            // Build explicit facts about what happened
            const draftFacts: EmailSendFacts = {
              action_completed: true,
              email_sent: result.success,
              recipients: result.message?.toEmails || [],
              failed_recipients: result.success ? [] : (result.message?.toEmails || []),
              delivery_status: result.success ? 'sent' : 'failed',
              message_id: result.trackingId,
              thread_id: result.message?.threadId,
              subject: result.message?.subject || '',
              failure_reason: result.success ? undefined : 'Draft email failed to send',
            };

            // Use template for verified response
            const draftResponse = draftFacts.email_sent
              ? RESPONSE_TEMPLATES.send_email.success(draftFacts)
              : RESPONSE_TEMPLATES.send_email.failure(draftFacts);

            // Return grounded result with backward compatibility
            return createCriticalResult(
              draftFacts.email_sent,
              draftFacts,
              draftResponse,
              {
                draftId,
                messageId: result.message?.id,
                trackingId: result.trackingId,
                recipients: result.message?.toEmails,
                subject: result.message?.subject,
              }
            );
          } catch (error) {
            this.logger.error(`Failed to send email draft: ${error.message}`, error.stack);
            const draftErrorFacts: EmailSendFacts = {
              action_completed: false,
              email_sent: false,
              recipients: [],
              failed_recipients: [],
              delivery_status: 'failed',
              subject: '',
              failure_reason: error.message,
            };
            const draftErrorResponse = RESPONSE_TEMPLATES.send_email.failure(draftErrorFacts);
            return createCriticalResult(false, draftErrorFacts, draftErrorResponse, undefined, `Failed to send email draft: ${error.message}`);
          }
        }

        // ==================== LOCAL IRIS TASK TOOL HANDLERS ====================
        case 'get_iris_task': {
          try {
            const { taskId } = toolInput;
            if (!taskId) {
              return { success: false, error: 'Task ID is required' };
            }
            // Get user's organizationId for tenant isolation
            const userMembership = await this.prisma.organizationMember.findFirst({
              where: { userId, isActive: true },
              select: { organizationId: true },
            });
            const orgId = userMembership?.organizationId || '';
            const task = await this.tasksService.getTask(taskId, userId, orgId, false);
            if (!task) {
              return { success: false, error: `Task with ID ${taskId} not found` };
            }
            const now = new Date();
            const dueDate = task.dueDate ? new Date(task.dueDate) : null;
            const isOverdue = dueDate && dueDate < now && task.status !== 'COMPLETED';
            return {
              success: true,
              task: {
                id: task.id,
                subject: task.subject,
                description: task.description,
                status: task.status,
                priority: task.priority,
                dueDate: task.dueDate,
                isOverdue,
                overdueMessage: isOverdue ? `OVERDUE by ${Math.floor((now.getTime() - dueDate!.getTime()) / (1000 * 60 * 60 * 24))} days` : null,
                relatedTo: task.leadId ? `Lead: ${task.leadId}` : task.accountId ? `Account: ${task.accountId}` : task.opportunityId ? `Opportunity: ${task.opportunityId}` : null,
                createdAt: task.createdAt,
                updatedAt: task.updatedAt,
              },
            };
          } catch (error) {
            this.logger.error(`Failed to get IRIS task: ${error.message}`, error.stack);
            return { success: false, error: `Failed to get task: ${error.message}` };
          }
        }

        case 'list_iris_tasks': {
          try {
            const { status, limit = 20 } = toolInput;
            // Get user's organizationId for tenant isolation
            const userMembershipForList = await this.prisma.organizationMember.findFirst({
              where: { userId, isActive: true },
              select: { organizationId: true },
            });
            const orgIdForList = userMembershipForList?.organizationId || '';
            const allTasks = await this.tasksService.listTasks(orgIdForList, {
              ownerId: userId,
              status,
            }, false);
            // Apply limit manually since listTasks doesn't support it
            const tasks = allTasks.slice(0, limit);
            const now = new Date();
            const tasksWithOverdue = tasks.map((task: any) => {
              const dueDate = task.dueDate ? new Date(task.dueDate) : null;
              const isOverdue = dueDate && dueDate < now && task.status !== 'COMPLETED';
              return {
                id: task.id,
                subject: task.subject,
                status: task.status,
                priority: task.priority,
                dueDate: task.dueDate,
                isOverdue,
                overdueMessage: isOverdue ? `OVERDUE by ${Math.floor((now.getTime() - dueDate!.getTime()) / (1000 * 60 * 60 * 24))} days` : null,
              };
            });
            const overdueCount = tasksWithOverdue.filter((t: any) => t.isOverdue).length;
            return {
              success: true,
              count: tasksWithOverdue.length,
              overdueCount,
              message: overdueCount > 0
                ? `${overdueCount} of ${tasksWithOverdue.length} tasks are overdue`
                : `${tasksWithOverdue.length} tasks found`,
              tasks: tasksWithOverdue,
            };
          } catch (error) {
            this.logger.error(`Failed to list IRIS tasks: ${error.message}`, error.stack);
            return { success: false, error: `Failed to list tasks: ${error.message}` };
          }
        }

        // ==================== MEETING INTELLIGENCE TOOL HANDLERS ====================
        case 'schedule_meeting': {
          try {
            // Handle both parameter naming conventions:
            // - Chat tools use: scheduledStart, duration
            // - Realtime voice tools use: startTime, endTime
            const rawScheduledAt = toolInput.scheduledStart || toolInput.startTime;

            // Validate and parse the scheduled time
            if (!rawScheduledAt) {
              return { success: false, error: 'Meeting time (scheduledStart) is required. Please specify when to schedule the meeting.' };
            }

            // Parse the date - handle various formats
            let scheduledAt: Date;
            if (rawScheduledAt instanceof Date) {
              scheduledAt = rawScheduledAt;
            } else {
              scheduledAt = new Date(rawScheduledAt);
            }

            // Validate the parsed date
            if (isNaN(scheduledAt.getTime())) {
              this.logger.warn(`[SCHEDULE_MEETING] Invalid date received: "${rawScheduledAt}"`);
              return {
                success: false,
                error: `Invalid meeting time format: "${rawScheduledAt}". Please provide a valid ISO 8601 date string (e.g., "2026-01-03T15:00:00Z" or "2026-01-03T15:00:00+05:30").`
              };
            }

            // Ensure meeting is in the future
            if (scheduledAt.getTime() < Date.now()) {
              return { success: false, error: 'Meeting time must be in the future. Please specify a future date and time.' };
            }

            // Calculate duration from endTime if provided, otherwise use duration or default to 60
            let duration = toolInput.duration || 60;
            if (!toolInput.duration && toolInput.endTime) {
              const end = new Date(toolInput.endTime);
              if (!isNaN(end.getTime())) {
                duration = Math.round((end.getTime() - scheduledAt.getTime()) / (1000 * 60));
              }
            }

            // Use the MeetingsService to create a real meeting via platform API (Zoom/Teams/Google Meet)
            // Generate contextual title if not provided by AI
            let meetingTitle = toolInput.title;
            if (!meetingTitle) {
              // Try to build a meaningful title from context
              const titleParts: string[] = [];

              // Check for attendee context
              if (toolInput.attendeeEmails?.length) {
                const firstAttendee = toolInput.attendeeEmails[0];
                const name = firstAttendee.split('@')[0].replace(/[._]/g, ' ');
                titleParts.push(`Meeting with ${name.charAt(0).toUpperCase() + name.slice(1)}`);
              }

              // Check for CRM context
              if (!titleParts.length) {
                if (toolInput.leadId) {
                  const lead = await this.prisma.lead.findUnique({ where: { id: toolInput.leadId }, select: { firstName: true, lastName: true, company: true } });
                  if (lead) titleParts.push(`Meeting with ${lead.firstName} ${lead.lastName}${lead.company ? ` (${lead.company})` : ''}`);
                }
                if (toolInput.accountId && !titleParts.length) {
                  const account = await this.prisma.account.findUnique({ where: { id: toolInput.accountId }, select: { name: true } });
                  if (account) titleParts.push(`Meeting with ${account.name}`);
                }
                if (toolInput.opportunityId && !titleParts.length) {
                  const opp = await this.prisma.opportunity.findUnique({ where: { id: toolInput.opportunityId }, select: { name: true } });
                  if (opp) titleParts.push(`Discussion: ${opp.name}`);
                }
              }

              // Fallback to platform + date
              meetingTitle = titleParts.length > 0
                ? titleParts[0]
                : `${toolInput.platform || 'Video'} Call - ${scheduledAt.toLocaleDateString('en-US', { month: 'short', day: 'numeric' })}`;
            }

            // Auto-fetch attendee emails from linked CRM records if not provided by AI
            let attendeeEmails: string[] = toolInput.attendeeEmails || [];

            if (attendeeEmails.length === 0) {
              this.logger.log(`[SCHEDULE_MEETING] No attendeeEmails provided by AI, attempting to fetch from CRM records...`);

              // Try to get email from Lead if leadId is provided
              if (toolInput.leadId) {
                const lead = await this.prisma.lead.findUnique({
                  where: { id: toolInput.leadId },
                  select: { email: true, firstName: true, lastName: true }
                });
                if (lead?.email) {
                  attendeeEmails.push(lead.email);
                  this.logger.log(`[SCHEDULE_MEETING] Found email from Lead (${lead.firstName} ${lead.lastName}): ${lead.email}`);
                }
              }

              // Try to get email from Contact if contactId is provided (and no email found yet)
              if (attendeeEmails.length === 0 && toolInput.contactId) {
                const contact = await this.prisma.contact.findUnique({
                  where: { id: toolInput.contactId },
                  select: { email: true, firstName: true, lastName: true }
                });
                if (contact?.email) {
                  attendeeEmails.push(contact.email);
                  this.logger.log(`[SCHEDULE_MEETING] Found email from Contact (${contact.firstName} ${contact.lastName}): ${contact.email}`);
                }
              }

              // Try to get primary contact email from Account if accountId is provided (and no email found yet)
              if (attendeeEmails.length === 0 && toolInput.accountId) {
                const primaryContact = await this.prisma.contact.findFirst({
                  where: { accountId: toolInput.accountId },
                  orderBy: { createdAt: 'asc' },
                  select: { email: true, firstName: true, lastName: true }
                });
                if (primaryContact?.email) {
                  attendeeEmails.push(primaryContact.email);
                  this.logger.log(`[SCHEDULE_MEETING] Found email from Account primary contact (${primaryContact.firstName} ${primaryContact.lastName}): ${primaryContact.email}`);
                }
              }

              if (attendeeEmails.length === 0) {
                this.logger.warn(`[SCHEDULE_MEETING] Could not auto-fetch attendee emails. No email found in linked Lead/Contact/Account. Meeting will be created but no invite will be sent.`);
              }
            }

            const meeting = await this.meetingsService.scheduleMeeting({
              title: meetingTitle,
              platform: toolInput.platform || 'ZOOM', // Default to ZOOM if not specified
              scheduledAt: scheduledAt.toISOString(),
              duration,
              hostEmail: toolInput.hostEmail || process.env.DEFAULT_HOST_EMAIL || 'meetings@example.com',
              attendeeEmails: attendeeEmails.length > 0 ? attendeeEmails : undefined,
              leadId: toolInput.leadId || undefined,
              contactId: toolInput.contactId || undefined,
              accountId: toolInput.accountId || undefined,
              opportunityId: toolInput.opportunityId || undefined,
            }, userId);

            // Sync to Salesforce Event (for Salesforce mode users)
            // This creates a corresponding Event in Salesforce with the Zoom/Teams/GMeet details
            let salesforceEventId: string | null = null;
            try {
              // Calculate scheduledEnd if not set (use duration or default 60 min)
              const meetingEndTime = meeting.scheduledEnd ||
                new Date(meeting.scheduledStart.getTime() + (duration * 60 * 1000));

              salesforceEventId = await this.syncMeetingToSalesforceEvent(
                {
                  id: meeting.id,
                  title: meeting.title,
                  description: toolInput.description || null,
                  scheduledStart: meeting.scheduledStart,
                  scheduledEnd: meetingEndTime,
                  meetingUrl: meeting.meetingUrl,
                  platform: meeting.platform,
                  // Use meeting record's CRM IDs (these were stored during creation)
                  leadId: meeting.leadId || toolInput.leadId || null,
                  accountId: meeting.accountId || toolInput.accountId || null,
                  opportunityId: meeting.opportunityId || toolInput.opportunityId || null,
                },
                userId,
                'create',
              );

              if (salesforceEventId) {
                this.logger.log(`Salesforce Event ${salesforceEventId} created for meeting ${meeting.id} with Zoom URL: ${meeting.meetingUrl}`);
              }
            } catch (sfError: any) {
              this.logger.warn(`Salesforce Event sync failed (non-blocking): ${sfError.message}`);
            }

            // Build grounded result with explicit facts to prevent hallucination
            const invitesSent = attendeeEmails.length > 0;
            const scheduledStart = meeting.scheduledStart.toISOString();
            const scheduledEnd = meeting.scheduledEnd?.toISOString() ||
              new Date(meeting.scheduledStart.getTime() + (duration * 60 * 1000)).toISOString();

            // Format date/time for display
            const formattedDate = meeting.scheduledStart.toLocaleDateString('en-US', {
              weekday: 'long',
              year: 'numeric',
              month: 'long',
              day: 'numeric',
            });
            const formattedTime = meeting.scheduledStart.toLocaleTimeString('en-US', {
              hour: 'numeric',
              minute: '2-digit',
              hour12: true,
            });

            const facts: MeetingScheduleFacts = {
              action_completed: true,
              meeting_created: true,
              meeting_id: meeting.id,
              platform: meeting.platform,
              meeting_url: meeting.meetingUrl || undefined,
              scheduled_start: scheduledStart,
              scheduled_end: scheduledEnd,
              duration_minutes: duration,
              invites_sent: invitesSent,
              invites_sent_to: invitesSent ? attendeeEmails : [],
              invites_failed_for: [], // Track failed invites if we add that capability
              calendar_event_created: invitesSent, // Calendar event created when invites sent
              salesforce_synced: !!salesforceEventId,
              salesforce_event_id: salesforceEventId || undefined,
            };

            // Build verified response that AI MUST use verbatim
            let verifiedResponse: string;
            if (invitesSent) {
              verifiedResponse = `Meeting scheduled successfully.
- Title: "${meeting.title}"
- Platform: ${meeting.platform}
- Date: ${formattedDate}
- Time: ${formattedTime}
- Duration: ${duration} minutes
- Meeting Link: ${meeting.meetingUrl || 'Pending'}
- Calendar invites sent to: ${attendeeEmails.join(', ')}${salesforceEventId ? '\n- Synced to Salesforce Event' : ''}`;
            } else {
              verifiedResponse = `Meeting scheduled successfully.
- Title: "${meeting.title}"
- Platform: ${meeting.platform}
- Date: ${formattedDate}
- Time: ${formattedTime}
- Duration: ${duration} minutes
- Meeting Link: ${meeting.meetingUrl || 'Pending'}

WARNING: No calendar invites were sent - no attendee email addresses were provided.
Please share the meeting link manually or provide attendee emails to send invites.${salesforceEventId ? '\n\n- Synced to Salesforce Event' : ''}`;
            }

            return createCriticalResult(
              true,
              facts,
              verifiedResponse,
              {
                meetingId: meeting.id,
                title: meeting.title,
                platform: meeting.platform,
                meetingUrl: meeting.meetingUrl,
                scheduledStart: meeting.scheduledStart,
                status: meeting.status,
              },
            );
          } catch (error) {
            this.logger.error(`Failed to schedule meeting: ${error.message}`, error.stack);

            // Return grounded error result
            const errorFacts: MeetingScheduleFacts = {
              action_completed: false,
              meeting_created: false,
              platform: toolInput.platform || 'ZOOM',
              invites_sent: false,
              invites_sent_to: [],
              invites_failed_for: [],
              calendar_event_created: false,
              salesforce_synced: false,
            };
            const errorResponse = RESPONSE_TEMPLATES.schedule_meeting.failure(error.message);

            return createCriticalResult(false, errorFacts, errorResponse, undefined, error.message);
          }
        }

        case 'log_email': {
          try {
            const { subject, body, direction, relatedTo } = toolInput;

            const activityData: any = {
              ownerId: userId,
              type: 'EMAIL',
              subject: `Email ${direction === 'RECEIVED' ? 'Received' : 'Sent'}: ${subject}`,
              notes: body,
              completedAt: new Date(),
            };

            // Parse relatedTo (e.g., "lead:abc123" or "contact:xyz789")
            if (relatedTo) {
              const [entityType, entityId] = relatedTo.split(':');
              if (entityType === 'lead') activityData.leadId = entityId;
              else if (entityType === 'contact') activityData.contactId = entityId;
              else if (entityType === 'account') activityData.accountId = entityId;
              else if (entityType === 'opportunity') activityData.opportunityId = entityId;
            }

            const activity = await this.prisma.activity.create({ data: activityData });

            return {
              success: true,
              message: `Email activity logged successfully`,
              data: {
                activityId: activity.id,
                subject,
                direction,
                loggedAt: activity.createdAt,
              },
            };
          } catch (error) {
            this.logger.error(`Failed to log email: ${error.message}`, error.stack);
            return {
              success: false,
              error: `Failed to log email: ${error.message}`,
            };
          }
        }

        case 'log_call': {
          try {
            const { subject, notes, duration, outcome, relatedTo } = toolInput;

            const activityData: any = {
              ownerId: userId,
              type: 'CALL',
              subject: `Call: ${subject}`,
              notes: `Outcome: ${outcome || 'N/A'}\nDuration: ${duration || 'N/A'} minutes\n\n${notes || ''}`,
              completedAt: new Date(),
            };

            // Parse relatedTo
            if (relatedTo) {
              const [entityType, entityId] = relatedTo.split(':');
              if (entityType === 'lead') activityData.leadId = entityId;
              else if (entityType === 'contact') activityData.contactId = entityId;
              else if (entityType === 'account') activityData.accountId = entityId;
              else if (entityType === 'opportunity') activityData.opportunityId = entityId;
            }

            const activity = await this.prisma.activity.create({ data: activityData });

            return {
              success: true,
              message: `Call activity logged successfully`,
              data: {
                activityId: activity.id,
                subject,
                outcome,
                duration,
                loggedAt: activity.createdAt,
              },
            };
          } catch (error) {
            this.logger.error(`Failed to log call: ${error.message}`, error.stack);
            return {
              success: false,
              error: `Failed to log call: ${error.message}`,
            };
          }
        }

        case 'get_meeting': {
          try {
            const meeting = await this.prisma.meetingSession.findUnique({
              where: { id: toolInput.meetingId },
              include: {
                participants: true,
                analysis: true,
                insights: true,
                lead: { select: { id: true, firstName: true, lastName: true, company: true } },
                account: { select: { id: true, name: true } },
                opportunity: { select: { id: true, name: true, stage: true } },
              },
            });

            if (!meeting) {
              return { success: false, error: 'Meeting not found' };
            }

            return {
              success: true,
              data: {
                id: meeting.id,
                title: meeting.title,
                platform: meeting.platform,
                status: meeting.status,
                scheduledStart: meeting.scheduledStart,
                scheduledEnd: meeting.scheduledEnd,
                actualStart: meeting.actualStart,
                actualEnd: meeting.actualEnd,
                duration: meeting.duration,
                recordingStatus: meeting.recordingStatus,
                hasTranscript: !!meeting.transcriptText,
                hasAnalysis: !!meeting.analysis,
                participantCount: meeting.participants.length,
                insightCount: meeting.insights.length,
                lead: meeting.lead,
                account: meeting.account,
                opportunity: meeting.opportunity,
              },
            };
          } catch (error) {
            return { success: false, error: `Failed to get meeting: ${error.message}` };
          }
        }

        case 'list_meetings': {
          try {
            const where: any = { ownerId: userId };
            if (toolInput.leadId) where.leadId = toolInput.leadId;
            if (toolInput.accountId) where.accountId = toolInput.accountId;
            if (toolInput.opportunityId) where.opportunityId = toolInput.opportunityId;
            if (toolInput.status) where.status = toolInput.status;
            if (toolInput.platform) where.platform = toolInput.platform;
            if (toolInput.startDate) where.scheduledStart = { gte: new Date(toolInput.startDate) };
            if (toolInput.endDate) where.scheduledStart = { ...where.scheduledStart, lte: new Date(toolInput.endDate) };

            const meetings = await this.prisma.meetingSession.findMany({
              where,
              orderBy: { scheduledStart: 'desc' },
              take: toolInput.limit || 10,
              include: {
                lead: { select: { firstName: true, lastName: true, company: true } },
                account: { select: { name: true } },
                _count: { select: { participants: true, insights: true } },
              },
            });

            return {
              success: true,
              count: meetings.length,
              data: meetings.map(m => ({
                id: m.id,
                title: m.title,
                platform: m.platform,
                status: m.status,
                scheduledStart: m.scheduledStart,
                duration: m.duration,
                lead: m.lead ? `${m.lead.firstName} ${m.lead.lastName}` : null,
                account: m.account?.name,
                participantCount: m._count.participants,
                insightCount: m._count.insights,
              })),
            };
          } catch (error) {
            return { success: false, error: `Failed to list meetings: ${error.message}` };
          }
        }

        case 'get_meeting_transcript': {
          try {
            const meeting = await this.prisma.meetingSession.findUnique({
              where: { id: toolInput.meetingId },
              include: {
                transcriptSegments: {
                  orderBy: { startTime: 'asc' },
                },
              },
            });

            if (!meeting) {
              return { success: false, error: 'Meeting not found' };
            }

            if (!meeting.transcriptText && meeting.transcriptSegments.length === 0) {
              return {
                success: false,
                error: 'No transcript available for this meeting. Meeting may still be processing.',
              };
            }

            const format = toolInput.format || 'full';

            if (format === 'by_speaker') {
              const bySpeaker: Record<string, string[]> = {};
              for (const seg of meeting.transcriptSegments) {
                if (!bySpeaker[seg.speakerName]) bySpeaker[seg.speakerName] = [];
                bySpeaker[seg.speakerName].push(seg.text);
              }
              return {
                success: true,
                data: { meetingId: meeting.id, title: meeting.title, bySpeaker },
              };
            }

            if (format === 'summary') {
              return {
                success: true,
                data: {
                  meetingId: meeting.id,
                  title: meeting.title,
                  segmentCount: meeting.transcriptSegments.length,
                  speakers: [...new Set(meeting.transcriptSegments.map(s => s.speakerName))],
                  duration: meeting.duration,
                },
              };
            }

            // Full format
            return {
              success: true,
              data: {
                meetingId: meeting.id,
                title: meeting.title,
                fullText: meeting.transcriptText,
                segments: meeting.transcriptSegments.map(s => ({
                  speaker: s.speakerName,
                  text: s.text,
                  startTime: s.startTime,
                  endTime: s.endTime,
                })),
              },
            };
          } catch (error) {
            return { success: false, error: `Failed to get transcript: ${error.message}` };
          }
        }

        case 'get_meeting_analysis': {
          try {
            const meeting = await this.prisma.meetingSession.findUnique({
              where: { id: toolInput.meetingId },
              include: { analysis: true },
            });

            if (!meeting) {
              return { success: false, error: 'Meeting not found' };
            }

            if (!meeting.analysis) {
              return {
                success: false,
                error: 'No analysis available for this meeting. Meeting may still be processing.',
              };
            }

            const analysis = meeting.analysis;
            return {
              success: true,
              data: {
                meetingId: meeting.id,
                title: meeting.title,
                summary: analysis.summary,
                keyPoints: analysis.keyPoints,
                decisions: analysis.decisions,
                actionItems: analysis.actionItems,
                sentiment: analysis.overallSentiment,
                sentimentScore: analysis.sentimentScore,
                buyingSignals: analysis.buyingSignals,
                objections: analysis.objections,
                nextSteps: analysis.nextSteps,
                competitorMentions: analysis.competitorMentions,
                dealRiskLevel: analysis.dealRiskLevel,
                dealRiskFactors: analysis.dealRiskFactors,
                opportunityScore: analysis.opportunityScore,
              },
            };
          } catch (error) {
            return { success: false, error: `Failed to get analysis: ${error.message}` };
          }
        }

        case 'get_meeting_insights': {
          try {
            const where: any = { meetingSessionId: toolInput.meetingId };
            if (toolInput.type) where.type = toolInput.type;
            if (toolInput.priority) where.priority = toolInput.priority;

            const insights = await this.prisma.meetingInsight.findMany({
              where,
              orderBy: [{ priority: 'desc' }, { createdAt: 'desc' }],
            });

            return {
              success: true,
              count: insights.length,
              data: insights.map(i => ({
                id: i.id,
                type: i.type,
                title: i.title,
                description: i.description,
                priority: i.priority,
                speakerName: i.speakerName,
                sourceTimestamp: i.sourceTimestamp,
                isActioned: i.isActioned,
              })),
            };
          } catch (error) {
            return { success: false, error: `Failed to get insights: ${error.message}` };
          }
        }

        case 'search_meeting_transcripts': {
          try {
            const dateLimit = new Date();
            dateLimit.setDate(dateLimit.getDate() - (toolInput.dateRange || 90));

            const where: any = {
              ownerId: userId,
              scheduledStart: { gte: dateLimit },
              transcriptText: { not: null },
            };
            if (toolInput.leadId) where.leadId = toolInput.leadId;
            if (toolInput.accountId) where.accountId = toolInput.accountId;

            const meetings = await this.prisma.meetingSession.findMany({
              where,
              include: {
                transcriptSegments: {
                  where: {
                    text: { contains: toolInput.query, mode: 'insensitive' },
                  },
                },
                lead: { select: { firstName: true, lastName: true } },
                account: { select: { name: true } },
              },
            });

            // Filter to only meetings with matching segments
            const matchingMeetings = meetings.filter(m => m.transcriptSegments.length > 0);

            return {
              success: true,
              count: matchingMeetings.length,
              data: matchingMeetings.slice(0, toolInput.limit || 10).map(m => ({
                meetingId: m.id,
                title: m.title,
                date: m.scheduledStart,
                lead: m.lead ? `${m.lead.firstName} ${m.lead.lastName}` : null,
                account: m.account?.name,
                matchingSegments: m.transcriptSegments.slice(0, 3).map(s => ({
                  speaker: s.speakerName,
                  text: s.text.substring(0, 200) + (s.text.length > 200 ? '...' : ''),
                  timestamp: s.startTime,
                })),
              })),
            };
          } catch (error) {
            return { success: false, error: `Failed to search transcripts: ${error.message}` };
          }
        }

        case 'create_tasks_from_meeting': {
          try {
            const meeting = await this.prisma.meetingSession.findUnique({
              where: { id: toolInput.meetingId },
              include: { analysis: true },
            });

            if (!meeting || !meeting.analysis) {
              const notFoundFacts: BulkOperationFacts = {
                action_completed: false,
                operation_type: 'create',
                total_requested: 0,
                successful_count: 0,
                failed_count: 0,
                successful_ids: [],
                failed_ids: [],
              };
              return createHighRiskResult(false, notFoundFacts, 'Meeting not found or analysis not available.');
            }

            const actionItems = meeting.analysis.actionItems as any[];
            if (!actionItems || actionItems.length === 0) {
              const noItemsFacts: BulkOperationFacts = {
                action_completed: true,
                operation_type: 'create',
                total_requested: 0,
                successful_count: 0,
                failed_count: 0,
                successful_ids: [],
                failed_ids: [],
              };
              return createHighRiskResult(true, noItemsFacts, 'No action items found in meeting analysis. No tasks created.');
            }

            const createdTasks: { id: string; subject: string; priority: string; dueDate: Date | null }[] = [];
            const failedItems: string[] = [];

            for (const item of actionItems) {
              try {
                const task = await this.prisma.task.create({
                  data: {
                    ownerId: userId,
                    subject: item.task || item.description || 'Follow-up task',
                    description: `From meeting: ${meeting.title}\n\n${item.task || item.description}`,
                    status: 'NOT_STARTED',
                    priority: item.priority === 'HIGH' ? 'HIGH' : item.priority === 'URGENT' ? 'URGENT' : 'NORMAL',
                    dueDate: item.dueDate ? new Date(item.dueDate) : null,
                    leadId: meeting.leadId,
                    accountId: meeting.accountId,
                    opportunityId: meeting.opportunityId,
                    meetingSessionId: meeting.id,
                  },
                });
                createdTasks.push({ id: task.id, subject: task.subject, priority: task.priority, dueDate: task.dueDate });
              } catch (itemError) {
                failedItems.push(item.task || item.description || 'Unknown item');
              }
            }

            const bulkFacts: BulkOperationFacts = {
              action_completed: true,
              operation_type: 'create',
              total_requested: actionItems.length,
              successful_count: createdTasks.length,
              failed_count: failedItems.length,
              successful_ids: createdTasks.map(t => t.id),
              failed_ids: failedItems,
            };

            let bulkVerifiedResponse = `Created ${createdTasks.length} task(s) from meeting "${meeting.title}" action items.`;
            if (createdTasks.length > 0) {
              bulkVerifiedResponse += '\n\nTasks created:';
              createdTasks.forEach((t, i) => {
                bulkVerifiedResponse += `\n${i + 1}. "${t.subject}" (ID: ${t.id}, Priority: ${t.priority}, Due: ${t.dueDate?.toISOString().split('T')[0] || 'Not set'})`;
              });
            }
            if (failedItems.length > 0) {
              bulkVerifiedResponse += `\n\nFailed to create ${failedItems.length} task(s): ${failedItems.join(', ')}`;
            }

            return createHighRiskResult(true, bulkFacts, bulkVerifiedResponse, {
              meetingId: meeting.id,
              meetingTitle: meeting.title,
              tasksCreated: createdTasks.length,
              tasks: createdTasks.map(t => ({
                id: t.id,
                title: t.subject,
                priority: t.priority,
                dueDate: t.dueDate,
              })),
            });
          } catch (error) {
            const errorFacts: BulkOperationFacts = {
              action_completed: false,
              operation_type: 'create',
              total_requested: 0,
              successful_count: 0,
              failed_count: 0,
              successful_ids: [],
              failed_ids: [],
            };
            return createHighRiskResult(false, errorFacts, `Failed to create tasks from meeting: ${error.message}`);
          }
        }

        case 'update_crm_from_meeting': {
          try {
            const meeting = await this.prisma.meetingSession.findUnique({
              where: { id: toolInput.meetingId },
              include: { analysis: true, lead: true, opportunity: true },
            });
            if (!meeting) {
              const notFoundFacts: RecordUpdateFacts = { action_completed: false, record_updated: false, record_id: toolInput.meetingId, record_type: 'MeetingSession', fields_changed: [], previous_values: {}, new_values: {}, validation_errors: ['Meeting not found'] };
              return createHighRiskResult(false, notFoundFacts, `Meeting with ID "${toolInput.meetingId}" not found.`, undefined, 'Meeting not found');
            }
            const recordsCreated: string[] = [];
            const recordsUpdated: { type: string; id: string; changes: Record<string, any> }[] = [];
            // Create activity record
            if (toolInput.createActivity !== false) {
              const activity = await this.prisma.activity.create({
                data: { userId, type: 'MEETING', subject: meeting.title, description: meeting.analysis?.summary || `Meeting held on ${meeting.scheduledStart}`, leadId: meeting.leadId, accountId: meeting.accountId, opportunityId: meeting.opportunityId, meetingSessionId: meeting.id },
              });
              recordsCreated.push(`Activity (${activity.id})`);
            }
            // Add meeting summary as notes
            if (toolInput.addNotes !== false && meeting.analysis?.summary && meeting.leadId) {
              const note = await this.prisma.note.create({
                data: { userId, leadId: meeting.leadId, title: `Meeting Notes: ${meeting.title}`, body: `**Summary:**\n${meeting.analysis.summary}\n\n**Key Points:**\n${meeting.analysis.keyPoints?.join('\n- ')}\n\n**Next Steps:**\n${meeting.analysis.nextSteps?.join('\n- ')}` },
              });
              recordsCreated.push(`Note (${note.id})`);
            }
            // Update lead based on insights
            let leadUpdated = false;
            if (toolInput.updateLead !== false && meeting.leadId && meeting.analysis) {
              const buyingSignals = meeting.analysis.buyingSignals || [];
              if (buyingSignals.length >= 2) {
                const beforeLead = await this.prisma.lead.findUnique({ where: { id: meeting.leadId } });
                await this.prisma.lead.update({ where: { id: meeting.leadId }, data: { buyingIntent: 'HIGH', painPoints: buyingSignals.slice(0, 5) } });
                recordsUpdated.push({ type: 'Lead', id: meeting.leadId, changes: { buyingIntent: { from: beforeLead?.buyingIntent || 'Not set', to: 'HIGH' } } });
                leadUpdated = true;
              }
            }
            // Update opportunity if exists
            let oppUpdated = false;
            let newProbability: number | null = null;
            if (toolInput.updateOpportunity !== false && meeting.opportunityId && meeting.analysis) {
              const opportunityScore = meeting.analysis.opportunityScore;
              if (opportunityScore !== null && opportunityScore !== undefined) {
                const beforeOpp = await this.prisma.opportunity.findUnique({ where: { id: meeting.opportunityId } });
                newProbability = Math.min(100, Math.max(0, opportunityScore));
                await this.prisma.opportunity.update({ where: { id: meeting.opportunityId }, data: { probability: newProbability } });
                recordsUpdated.push({ type: 'Opportunity', id: meeting.opportunityId, changes: { probability: { from: beforeOpp?.probability || 'Not set', to: newProbability } } });
                oppUpdated = true;
              }
            }
            const facts: RecordUpdateFacts = {
              action_completed: true,
              record_updated: recordsCreated.length > 0 || recordsUpdated.length > 0,
              record_id: meeting.id,
              record_type: 'MeetingSession',
              record_name: meeting.title,
              fields_changed: [...recordsCreated.map(r => `created:${r}`), ...recordsUpdated.map(r => `updated:${r.type}`)],
              previous_values: {},
              new_values: { recordsCreated, recordsUpdated },
            };
            let verifiedResponse = `CRM updated from meeting "${meeting.title}".\n`;
            if (recordsCreated.length > 0) verifiedResponse += `Records created:\n  - ${recordsCreated.join('\n  - ')}\n`;
            if (recordsUpdated.length > 0) {
              verifiedResponse += `Records updated:\n`;
              recordsUpdated.forEach(r => {
                verifiedResponse += `  - ${r.type} (${r.id}): ${Object.entries(r.changes).map(([k, v]: [string, any]) => `${k}: ${v.from} -> ${v.to}`).join(', ')}\n`;
              });
            }
            if (recordsCreated.length === 0 && recordsUpdated.length === 0) verifiedResponse = `No CRM changes were made from meeting "${meeting.title}" - no qualifying conditions met.`;
            return createHighRiskResult(true, facts, verifiedResponse, { meetingId: meeting.id, meetingTitle: meeting.title, recordsCreated, recordsUpdated });
          } catch (error) {
            const errorFacts: RecordUpdateFacts = { action_completed: false, record_updated: false, record_id: toolInput.meetingId, record_type: 'MeetingSession', fields_changed: [], previous_values: {}, new_values: {} };
            return createHighRiskResult(false, errorFacts, `Failed to update CRM from meeting: ${error.message}`, undefined, error.message);
          }
        }

        // MEETING RSVP & PARTICIPANT MANAGEMENT TOOL HANDLERS
        case 'get_meeting_rsvp_status': {
          try {
            const meeting = await this.prisma.meetingSession.findUnique({
              where: { id: toolInput.meetingId },
              include: {
                participants: {
                  select: {
                    id: true,
                    name: true,
                    email: true,
                    role: true,
                    responseStatus: true,
                    responseAt: true,
                    responseNote: true,
                    inviteSentAt: true,
                    isInternal: true,
                  },
                },
              },
            });

            if (!meeting) {
              return { success: false, error: 'Meeting not found' };
            }

            const participants = meeting.participants || [];
            const summary = {
              total: participants.length,
              accepted: participants.filter(p => p.responseStatus === 'ACCEPTED').length,
              declined: participants.filter(p => p.responseStatus === 'DECLINED').length,
              tentative: participants.filter(p => p.responseStatus === 'TENTATIVE').length,
              pending: participants.filter(p => p.responseStatus === 'PENDING' || !p.responseStatus).length,
              noResponse: participants.filter(p => p.responseStatus === 'NO_RESPONSE').length,
            };

            const formattedParticipants = participants.map(p => ({
              name: p.name,
              email: p.email,
              role: p.role || 'attendee',
              isInternal: p.isInternal,
              responseStatus: p.responseStatus || 'PENDING',
              respondedAt: p.responseAt,
              note: p.responseNote,
              inviteSentAt: p.inviteSentAt,
            }));

            return {
              success: true,
              data: {
                meetingId: meeting.id,
                meetingTitle: meeting.title,
                scheduledStart: meeting.scheduledStart,
                status: meeting.status,
                rsvpSummary: summary,
                participants: formattedParticipants,
                allAccepted: summary.accepted === summary.total && summary.total > 0,
                hasDeclines: summary.declined > 0,
                hasPending: summary.pending > 0,
              },
            };
          } catch (error) {
            return { success: false, error: `Failed to get RSVP status: ${error.message}` };
          }
        }

        case 'get_meeting_participants': {
          try {
            const meeting = await this.prisma.meetingSession.findUnique({
              where: { id: toolInput.meetingId },
              include: {
                participants: {
                  include: {
                    contact: toolInput.includeContactDetails !== false ? {
                      select: {
                        id: true,
                        firstName: true,
                        lastName: true,
                        email: true,
                        phone: true,
                        title: true,
                        department: true,
                        role: true,
                      },
                    } : false,
                  },
                },
                lead: { select: { id: true, firstName: true, lastName: true, email: true, company: true } },
                account: { select: { id: true, name: true } },
              },
            });

            if (!meeting) {
              return { success: false, error: 'Meeting not found' };
            }

            return {
              success: true,
              data: {
                meetingId: meeting.id,
                meetingTitle: meeting.title,
                participantCount: meeting.participants.length,
                participants: meeting.participants.map(p => ({
                  id: p.id,
                  name: p.name,
                  email: p.email,
                  role: p.role,
                  isInternal: p.isInternal,
                  isBot: p.isBot,
                  responseStatus: p.responseStatus || 'PENDING',
                  responseAt: p.responseAt,
                  responseNote: p.responseNote,
                  joinedAt: p.joinedAt,
                  leftAt: p.leftAt,
                  speakingDuration: p.speakingDuration,
                  engagementLevel: p.engagementLevel,
                  contact: p.contact || null,
                })),
                relatedLead: meeting.lead,
                relatedAccount: meeting.account,
              },
            };
          } catch (error) {
            return { success: false, error: `Failed to get participants: ${error.message}` };
          }
        }

        case 'update_meeting_rsvp': {
          try {
            const meeting = await this.prisma.meetingSession.findUnique({
              where: { id: toolInput.meetingId },
              include: { participants: true },
            });

            if (!meeting) {
              return { success: false, error: 'Meeting not found' };
            }

            // Verify ownership
            if (meeting.ownerId !== userId) {
              const user = await this.prisma.user.findUnique({ where: { id: userId } });
              if (user?.role !== 'ADMIN') {
                return { success: false, error: 'Not authorized to update this meeting' };
              }
            }

            const participant = meeting.participants.find(
              p => p.email?.toLowerCase() === toolInput.participantEmail.toLowerCase()
            );

            if (!participant) {
              return {
                success: false,
                error: `Participant with email ${toolInput.participantEmail} not found in this meeting. Available participants: ${meeting.participants.map(p => p.email).filter(Boolean).join(', ')}`,
              };
            }

            const previousStatus = participant.responseStatus || 'PENDING';
            const now = new Date();

            // Update participant response
            await this.prisma.meetingParticipant.update({
              where: { id: participant.id },
              data: {
                responseStatus: toolInput.responseStatus,
                responseAt: now,
                responseNote: toolInput.responseNote || participant.responseNote,
              },
            });

            // Log the response change in history
            await this.prisma.meetingInviteResponse.create({
              data: {
                meetingSessionId: meeting.id,
                participantEmail: participant.email || '',
                participantName: participant.name || null,
                newStatus: toolInput.responseStatus,
                previousStatus,
                responseSource: 'conversation_ai',
              },
            });

            return {
              success: true,
              message: `Updated ${participant.name || participant.email}'s response to ${toolInput.responseStatus}`,
              data: {
                participantName: participant.name,
                participantEmail: participant.email,
                previousStatus,
                newStatus: toolInput.responseStatus,
                note: toolInput.responseNote,
                updatedAt: now,
              },
            };
          } catch (error) {
            return { success: false, error: `Failed to update RSVP: ${error.message}` };
          }
        }

        case 'cancel_meeting': {
          try {
            const meeting = await this.prisma.meetingSession.findUnique({
              where: { id: toolInput.meetingId },
              include: {
                participants: true,
                owner: { select: { email: true, name: true } },
              },
            });

            if (!meeting) {
              // Return grounded error result for not found
              const notFoundFacts: MeetingCancelFacts = {
                action_completed: false,
                meeting_cancelled: false,
                meeting_id: toolInput.meetingId,
                meeting_title: 'Unknown',
                notifications_sent: false,
                notified_participants: [],
                notification_failed_for: [],
                calendar_event_removed: false,
                salesforce_event_removed: false,
              };
              return createCriticalResult(
                false,
                notFoundFacts,
                RESPONSE_TEMPLATES.cancel_meeting.failure('Meeting not found'),
                undefined,
                'Meeting not found'
              );
            }

            // Verify ownership
            if (meeting.ownerId !== userId) {
              const user = await this.prisma.user.findUnique({ where: { id: userId } });
              if (user?.role !== 'ADMIN') {
                const unauthorizedFacts: MeetingCancelFacts = {
                  action_completed: false,
                  meeting_cancelled: false,
                  meeting_id: meeting.id,
                  meeting_title: meeting.title,
                  notifications_sent: false,
                  notified_participants: [],
                  notification_failed_for: [],
                  calendar_event_removed: false,
                  salesforce_event_removed: false,
                };
                return createCriticalResult(
                  false,
                  unauthorizedFacts,
                  RESPONSE_TEMPLATES.cancel_meeting.failure('Not authorized to cancel this meeting'),
                  undefined,
                  'Not authorized to cancel this meeting'
                );
              }
            }

            if (meeting.status === 'CANCELLED') {
              const alreadyCancelledFacts: MeetingCancelFacts = {
                action_completed: false,
                meeting_cancelled: false,
                meeting_id: meeting.id,
                meeting_title: meeting.title,
                notifications_sent: false,
                notified_participants: [],
                notification_failed_for: [],
                calendar_event_removed: false,
                salesforce_event_removed: false,
              };
              return createCriticalResult(
                false,
                alreadyCancelledFacts,
                RESPONSE_TEMPLATES.cancel_meeting.failure('Meeting is already cancelled'),
                undefined,
                'Meeting is already cancelled'
              );
            }

            if (meeting.status === 'COMPLETED') {
              const completedFacts: MeetingCancelFacts = {
                action_completed: false,
                meeting_cancelled: false,
                meeting_id: meeting.id,
                meeting_title: meeting.title,
                notifications_sent: false,
                notified_participants: [],
                notification_failed_for: [],
                calendar_event_removed: false,
                salesforce_event_removed: false,
              };
              return createCriticalResult(
                false,
                completedFacts,
                RESPONSE_TEMPLATES.cancel_meeting.failure('Cannot cancel a completed meeting'),
                undefined,
                'Cannot cancel a completed meeting'
              );
            }

            const participantEmails = meeting.participants
              .filter(p => p.email && !p.isBot)
              .map(p => p.email as string);

            // Send cancellation emails if requested
            if (toolInput.sendNotification !== false && participantEmails.length > 0) {
              try {
                // Generate ICS content for cancellation
                const icsContent = [
                  'BEGIN:VCALENDAR',
                  'VERSION:2.0',
                  'PRODID:-//IRIS Sales CRM//Meeting Cancellation//EN',
                  'METHOD:CANCEL',
                  'BEGIN:VEVENT',
                  `UID:${meeting.id}@irissalescrm.com`,
                  `DTSTAMP:${new Date().toISOString().replace(/[-:]/g, '').split('.')[0]}Z`,
                  `DTSTART:${(meeting.scheduledStart || new Date()).toISOString().replace(/[-:]/g, '').split('.')[0]}Z`,
                  `SUMMARY:${meeting.title}`,
                  'STATUS:CANCELLED',
                  'END:VEVENT',
                  'END:VCALENDAR',
                ].join('\r\n');

                await this.emailService.sendMeetingCancellation({
                  to: participantEmails,
                  meetingTitle: meeting.title,
                  meetingDate: meeting.scheduledStart || new Date(),
                  reason: toolInput.reason || 'This meeting has been cancelled.',
                  organizerName: meeting.owner?.name || 'Meeting Organizer',
                  icsContent,
                });
              } catch (emailError: any) {
                this.logger.warn(`Failed to send cancellation emails: ${emailError.message}`);
              }
            }

            // Update meeting status to cancelled
            await this.prisma.meetingSession.update({
              where: { id: meeting.id },
              data: {
                status: 'CANCELLED',
                cancelledAt: new Date(),
                cancellationReason: toolInput.reason,
                cancellationNotificationSent: toolInput.sendNotification !== false && participantEmails.length > 0,
              },
            });

            // Update all participants' cancellation status
            await this.prisma.meetingParticipant.updateMany({
              where: { meetingSessionId: meeting.id },
              data: { cancellationSentAt: new Date() },
            });

            // Sync cancellation to Salesforce Event (for Salesforce mode users)
            let salesforceEventUpdated = false;
            if (meeting.salesforceEventId) {
              try {
                await this.syncMeetingToSalesforceEvent(
                  {
                    id: meeting.id,
                    title: meeting.title,
                    description: toolInput.reason || null,
                    scheduledStart: meeting.scheduledStart,
                    scheduledEnd: meeting.scheduledEnd,
                    meetingUrl: meeting.meetingUrl,
                    platform: meeting.platform,
                    salesforceEventId: meeting.salesforceEventId,
                  },
                  userId,
                  'cancel',
                );
                salesforceEventUpdated = true;
              } catch (sfError: any) {
                this.logger.warn(`Salesforce Event cancellation sync failed (non-blocking): ${sfError.message}`);
              }
            }

            // Build grounded result with explicit facts
            const cancelFacts: MeetingCancelFacts = {
              action_completed: true,
              meeting_cancelled: true,
              meeting_id: meeting.id,
              meeting_title: meeting.title,
              notifications_sent: toolInput.sendNotification !== false && participantEmails.length > 0,
              notified_participants: toolInput.sendNotification !== false ? participantEmails : [],
              notification_failed_for: [], // Track failed notifications if we add that capability
              calendar_event_removed: true, // Calendar event removed when meeting cancelled
              salesforce_event_removed: salesforceEventUpdated,
            };

            // Build verified response based on actual notification status
            let cancelVerifiedResponse: string;
            const notifySent = toolInput.sendNotification !== false && participantEmails.length > 0;
            if (notifySent) {
              cancelVerifiedResponse = `Meeting "${meeting.title}" has been cancelled.
- Cancellation notifications sent to: ${participantEmails.join(', ')}
- Calendar event removed${salesforceEventUpdated ? '\n- Salesforce Event cancelled' : ''}`;
            } else if (toolInput.sendNotification === false) {
              cancelVerifiedResponse = `Meeting "${meeting.title}" has been cancelled.
- Cancellation notifications were NOT sent (per your request)
- Calendar event removed${salesforceEventUpdated ? '\n- Salesforce Event cancelled' : ''}`;
            } else {
              cancelVerifiedResponse = `Meeting "${meeting.title}" has been cancelled.

WARNING: No cancellation notifications were sent - no participant email addresses on file.
Please notify participants manually.
- Calendar event removed${salesforceEventUpdated ? '\n- Salesforce Event cancelled' : ''}`;
            }

            return createCriticalResult(
              true,
              cancelFacts,
              cancelVerifiedResponse,
              {
                meetingId: meeting.id,
                meetingTitle: meeting.title,
                reason: toolInput.reason,
                cancelledAt: new Date(),
              },
            );
          } catch (error) {
            // Return grounded error result
            const cancelErrorFacts: MeetingCancelFacts = {
              action_completed: false,
              meeting_cancelled: false,
              meeting_id: toolInput.meetingId,
              meeting_title: 'Unknown',
              notifications_sent: false,
              notified_participants: [],
              notification_failed_for: [],
              calendar_event_removed: false,
              salesforce_event_removed: false,
            };
            return createCriticalResult(
              false,
              cancelErrorFacts,
              RESPONSE_TEMPLATES.cancel_meeting.failure(error.message),
              undefined,
              error.message
            );
          }
        }

        case 'get_meeting_response_history': {
          try {
            const where: any = { meetingSessionId: toolInput.meetingId };
            if (toolInput.participantEmail) {
              where.participantEmail = { equals: toolInput.participantEmail, mode: 'insensitive' };
            }

            const responses = await this.prisma.meetingInviteResponse.findMany({
              where,
              orderBy: { createdAt: 'desc' },
            });

            return {
              success: true,
              count: responses.length,
              data: responses.map(r => ({
                participantName: r.participantName,
                participantEmail: r.participantEmail,
                responseStatus: r.newStatus,
                previousStatus: r.previousStatus,
                source: r.responseSource,
                respondedAt: r.createdAt,
              })),
            };
          } catch (error) {
            return { success: false, error: `Failed to get response history: ${error.message}` };
          }
        }

        case 'resend_meeting_invite': {
          try {
            const meeting = await this.prisma.meetingSession.findUnique({
              where: { id: toolInput.meetingId },
              include: { participants: true },
            });

            if (!meeting) {
              return { success: false, error: 'Meeting not found' };
            }

            if (meeting.status === 'CANCELLED' || meeting.status === 'COMPLETED') {
              return { success: false, error: `Cannot resend invites for a ${meeting.status.toLowerCase()} meeting` };
            }

            let participantsToNotify = meeting.participants.filter(p => p.email && !p.isBot);

            // Filter by specific emails if provided
            if (toolInput.emails && toolInput.emails.length > 0) {
              const emailSet = new Set(toolInput.emails.map((e: string) => e.toLowerCase()));
              participantsToNotify = participantsToNotify.filter(p => 
                p.email && emailSet.has(p.email.toLowerCase())
              );
            } else if (toolInput.onlyPending !== false) {
              // Default: only pending responses
              participantsToNotify = participantsToNotify.filter(p => 
                !p.responseStatus || p.responseStatus === 'PENDING' || p.responseStatus === 'NO_RESPONSE'
              );
            }

            if (participantsToNotify.length === 0) {
              return {
                success: true,
                message: 'No participants to send invites to',
                data: { sentCount: 0 },
              };
            }

            const emails = participantsToNotify.map(p => p.email as string);

            // Resend invites
            try {
              await this.emailService.sendMeetingInvite({
                to: emails,
                meetingTitle: meeting.title,
                meetingDate: meeting.scheduledStart || new Date(),
                duration: meeting.duration || 30,
                joinUrl: meeting.meetingUrl || '',
                platform: meeting.platform as any,
              });

              // Update invite sent timestamp
              const now = new Date();
              await this.prisma.meetingParticipant.updateMany({
                where: {
                  meetingSessionId: meeting.id,
                  email: { in: emails },
                },
                data: { inviteSentAt: now },
              });

              return {
                success: true,
                message: `Meeting invites resent to ${emails.length} participant(s)`,
                data: {
                  sentCount: emails.length,
                  recipients: emails,
                  sentAt: now,
                },
              };
            } catch (emailError: any) {
              return { success: false, error: `Failed to send invites: ${emailError.message}` };
            }
          } catch (error) {
            return { success: false, error: `Failed to resend invites: ${error.message}` };
          }
        }

        case 'check_meeting_availability': {
          try {
            const proposedTime = new Date(toolInput.proposedTime);
            const duration = toolInput.duration || 30;
            const endTime = new Date(proposedTime.getTime() + duration * 60 * 1000);

            const participantEmails = toolInput.participantEmails.map((e: string) => e.toLowerCase());

            // Check for conflicting meetings for each participant
            const conflicts = await this.prisma.meetingSession.findMany({
              where: {
                status: { in: ['SCHEDULED', 'IN_PROGRESS'] },
                participants: {
                  some: {
                    email: { in: participantEmails, mode: 'insensitive' },
                    responseStatus: { in: ['ACCEPTED', 'TENTATIVE'] },
                  },
                },
                OR: [
                  {
                    scheduledStart: { lte: proposedTime },
                    scheduledEnd: { gte: proposedTime },
                  },
                  {
                    scheduledStart: { lte: endTime },
                    scheduledEnd: { gte: endTime },
                  },
                  {
                    scheduledStart: { gte: proposedTime },
                    scheduledEnd: { lte: endTime },
                  },
                ],
              },
              include: {
                participants: {
                  where: { email: { in: participantEmails, mode: 'insensitive' } },
                  select: { email: true, name: true },
                },
              },
            });

            // Analyze past response patterns
            const responsePatterns = await this.prisma.meetingParticipant.groupBy({
              by: ['email', 'responseStatus'],
              where: {
                email: { in: participantEmails, mode: 'insensitive' },
              },
              _count: true,
            });

            // Calculate response reliability for each participant
            const participantAnalysis = participantEmails.map((email: string) => {
              const patterns = responsePatterns.filter(p => p.email?.toLowerCase() === email);
              const total = patterns.reduce((sum, p) => sum + p._count, 0);
              const accepted = patterns.find(p => p.responseStatus === 'ACCEPTED')?._count || 0;
              const declined = patterns.find(p => p.responseStatus === 'DECLINED')?._count || 0;

              const conflictingMeetings = conflicts.filter(c => 
                c.participants.some(p => p.email?.toLowerCase() === email)
              );

              return {
                email,
                hasConflict: conflictingMeetings.length > 0,
                conflictingMeetings: conflictingMeetings.map(c => ({
                  title: c.title,
                  start: c.scheduledStart,
                  end: c.scheduledEnd,
                })),
                responseHistory: {
                  totalMeetings: total,
                  acceptRate: total > 0 ? Math.round((accepted / total) * 100) : null,
                  declineRate: total > 0 ? Math.round((declined / total) * 100) : null,
                },
                likelyToAccept: total === 0 ? 'unknown' : (accepted / total) >= 0.7 ? 'high' : (accepted / total) >= 0.4 ? 'medium' : 'low',
              };
            });

            const hasAnyConflict = participantAnalysis.some(p => p.hasConflict);
            const allLikelyToAccept = participantAnalysis.every(p => p.likelyToAccept !== 'low');

            return {
              success: true,
              data: {
                proposedTime: proposedTime.toISOString(),
                duration,
                hasConflicts: hasAnyConflict,
                recommendation: hasAnyConflict 
                  ? 'Consider rescheduling - some participants have conflicting meetings'
                  : allLikelyToAccept 
                    ? 'Good time slot - no conflicts and participants have good response history'
                    : 'Time available but some participants have low acceptance rates',
                participants: participantAnalysis,
              },
            };
          } catch (error) {
            return { success: false, error: `Failed to check availability: ${error.message}` };
          }
        }

        // 10X PRODUCTIVITY TOOL HANDLERS
        case 'generate_followup_email': {
          try {
            const meeting = await this.prisma.meetingSession.findUnique({
              where: { id: toolInput.meetingId },
              include: {
                analysis: true,
                participants: true,
                lead: true,
                account: true,
                opportunity: true,
              },
            });

            if (!meeting) {
              return { success: false, error: 'Meeting not found' };
            }

            const recipientName = toolInput.recipientName ||
              meeting.participants?.find(p => !p.isInternal)?.name ||
              meeting.lead?.firstName ||
              'there';

            const tone = toolInput.tone || 'consultative';
            const analysis = meeting.analysis;

            // Build email content based on meeting insights
            const actionItems = (analysis?.actionItems as any[]) || [];
            const nextSteps = analysis?.nextSteps || [];
            const keyPoints = analysis?.keyPoints || [];

            let emailContent = `**Subject:** Follow-up: ${meeting.title}\n\n`;
            emailContent += `Hi ${recipientName},\n\n`;
            emailContent += `Thank you for taking the time to meet ${tone === 'formal' ? 'with us' : 'with me'} today. `;

            if (analysis?.summary) {
              emailContent += `I wanted to recap our discussion and ensure we're aligned on next steps.\n\n`;
              emailContent += `**Key Discussion Points:**\n`;
              keyPoints.slice(0, 5).forEach((point: string) => {
                emailContent += `- ${point}\n`;
              });
            }

            if (toolInput.includeActionItems !== false && actionItems.length > 0) {
              emailContent += `\n**Action Items:**\n`;
              actionItems.slice(0, 5).forEach((item: any) => {
                const assignee = item.assignee ? ` (${item.assignee})` : '';
                const dueDate = item.dueDate ? ` - Due: ${new Date(item.dueDate).toLocaleDateString()}` : '';
                emailContent += `- ${item.text}${assignee}${dueDate}\n`;
              });
            }

            if (toolInput.includeNextSteps !== false && nextSteps.length > 0) {
              emailContent += `\n**Proposed Next Steps:**\n`;
              nextSteps.slice(0, 3).forEach((step: string) => {
                emailContent += `- ${step}\n`;
              });
            }

            emailContent += `\nPlease let me know if I've missed anything or if you have any questions.\n\n`;
            emailContent += tone === 'formal' ? `Best regards` : `Looking forward to our continued partnership!`;

            return {
              success: true,
              data: {
                email: emailContent,
                meetingTitle: meeting.title,
                recipientName,
                tone,
              },
            };
          } catch (error) {
            return { success: false, error: `Failed to generate email: ${error.message}` };
          }
        }

        case 'analyze_deal_risk': {
          try {
            const opportunity = await this.prisma.opportunity.findUnique({
              where: { id: toolInput.opportunityId },
              include: {
                account: true,
                activities: { orderBy: { createdAt: 'desc' }, take: 10 },
                meetingSessions: {
                  include: { analysis: true },
                  orderBy: { scheduledStart: 'desc' },
                  take: 5,
                },
                tasks: { where: { status: { not: 'COMPLETED' } } },
              },
            });

            if (!opportunity) {
              const errorFacts: AnalysisFacts = {
                action_completed: false,
                analysis_completed: false,
                data_sources_used: [],
                records_analyzed: 0,
                confidence_level: 'low',
                data_freshness: `as of ${new Date().toISOString().split('T')[0]}`,
                caveats: ['Opportunity not found'],
              };
              return createMediumRiskResult(false, errorFacts, 'Opportunity not found', undefined, 'Opportunity not found');
            }

            const risks: { risk: string; severity: 'HIGH' | 'MEDIUM' | 'LOW'; recommendation: string }[] = [];

            // Check days in current stage
            const daysInStage = Math.floor((Date.now() - opportunity.updatedAt.getTime()) / (1000 * 60 * 60 * 24));
            if (daysInStage > 30) {
              risks.push({
                risk: `Opportunity has been in ${opportunity.stage} stage for ${daysInStage} days`,
                severity: daysInStage > 60 ? 'HIGH' : 'MEDIUM',
                recommendation: 'Schedule a check-in call to understand blockers and re-engage the prospect',
              });
            }

            // Check close date
            const closeDate = opportunity.closeDate ? new Date(opportunity.closeDate).getTime() : Date.now();
            const daysToClose = Math.floor((closeDate - Date.now()) / (1000 * 60 * 60 * 24));
            if (daysToClose < 0) {
              risks.push({
                risk: `Close date has passed by ${Math.abs(daysToClose)} days`,
                severity: 'HIGH',
                recommendation: 'Update close date and reassess deal timeline with customer',
              });
            } else if (daysToClose < 14 && opportunity.stage !== 'CLOSED_WON' && opportunity.stage !== 'NEGOTIATION_REVIEW') {
              risks.push({
                risk: `Close date is in ${daysToClose} days but deal is only in ${opportunity.stage} stage`,
                severity: 'HIGH',
                recommendation: 'Accelerate sales cycle or revise close date to realistic timeline',
              });
            }

            // Check engagement
            const lastActivity = opportunity.activities[0];
            const daysSinceActivity = lastActivity
              ? Math.floor((Date.now() - lastActivity.createdAt.getTime()) / (1000 * 60 * 60 * 24))
              : 999;
            if (daysSinceActivity > 14) {
              risks.push({
                risk: `No customer engagement for ${daysSinceActivity === 999 ? 'unknown time' : `${daysSinceActivity} days`}`,
                severity: daysSinceActivity > 30 ? 'HIGH' : 'MEDIUM',
                recommendation: 'Reach out with value-add content or schedule a touchpoint',
              });
            }

            // Check meeting sentiment
            const recentMeeting = opportunity.meetingSessions[0];
            const hasMeetingData = !!recentMeeting?.analysis;
            if (hasMeetingData && recentMeeting.analysis) {
              const sentiment = recentMeeting.analysis.overallSentiment;
              if (sentiment === 'NEGATIVE' || sentiment === 'VERY_NEGATIVE') {
                risks.push({
                  risk: `Recent meeting had ${sentiment} sentiment`,
                  severity: 'HIGH',
                  recommendation: 'Address concerns raised in the meeting immediately',
                });
              }
            }

            // Calculate overall risk score
            const highRisks = risks.filter(r => r.severity === 'HIGH').length;
            const mediumRisks = risks.filter(r => r.severity === 'MEDIUM').length;
            const overallRisk = highRisks >= 2 ? 'CRITICAL' : highRisks >= 1 ? 'HIGH' : mediumRisks >= 2 ? 'MEDIUM' : 'LOW';

            // Build caveats to prevent AI from overstating certainty
            const riskCaveats: string[] = [];
            if (!hasMeetingData) {
              riskCaveats.push('No recent meeting data available - sentiment analysis not included');
            }
            if (opportunity.activities.length === 0) {
              riskCaveats.push('No activity history - engagement metrics may be incomplete');
            }
            if (!opportunity.closeDate) {
              riskCaveats.push('No close date set - timeline risk assessment limited');
            }

            // Determine confidence level based on data availability
            const riskAnalysisConfidence: 'high' | 'medium' | 'low' =
              (hasMeetingData && opportunity.activities.length > 3) ? 'high' :
              (opportunity.activities.length > 0) ? 'medium' : 'low';

            const riskFacts: AnalysisFacts = {
              action_completed: true,
              analysis_completed: true,
              data_sources_used: ['opportunity_data', 'activity_history', hasMeetingData ? 'meeting_analysis' : null].filter(Boolean) as string[],
              records_analyzed: 1 + opportunity.activities.length + opportunity.meetingSessions.length,
              confidence_level: riskAnalysisConfidence,
              data_freshness: `as of ${new Date().toISOString().split('T')[0]}`,
              caveats: riskCaveats,
              methodology: 'Rule-based risk scoring: stage duration, close date proximity, engagement frequency, meeting sentiment',
            };

            // Build verified response - prevents AI from inventing additional risk factors
            let riskVerifiedResponse = `## Deal Risk Analysis: ${opportunity.name}\n`;
            riskVerifiedResponse += `**Overall Risk:** ${overallRisk}\n`;
            riskVerifiedResponse += `**Confidence:** ${riskAnalysisConfidence.toUpperCase()}\n`;
            riskVerifiedResponse += `**Data Sources:** ${riskFacts.data_sources_used.join(', ')}\n`;
            riskVerifiedResponse += `**Records Analyzed:** ${riskFacts.records_analyzed}\n\n`;

            riskVerifiedResponse += `### Deal Snapshot\n`;
            riskVerifiedResponse += `- Stage: ${opportunity.stage}\n`;
            riskVerifiedResponse += `- Amount: $${opportunity.amount?.toLocaleString() || 'Not set'}\n`;
            riskVerifiedResponse += `- Days in Stage: ${daysInStage}\n`;
            riskVerifiedResponse += `- Days to Close: ${daysToClose < 0 ? `${Math.abs(daysToClose)} overdue` : daysToClose}\n\n`;

            if (risks.length > 0) {
              riskVerifiedResponse += `### Risk Factors (${risks.length} identified)\n`;
              risks.forEach((r, i) => {
                riskVerifiedResponse += `${i + 1}. [${r.severity}] ${r.risk}\n`;
              });
            } else {
              riskVerifiedResponse += `### Risk Factors\nNo significant risk factors identified.\n`;
            }

            if (riskCaveats.length > 0) {
              riskVerifiedResponse += `\n### Limitations\n`;
              riskCaveats.forEach(c => {
                riskVerifiedResponse += `- ${c}\n`;
              });
            }

            const riskData = {
              opportunityId: opportunity.id,
              opportunityName: opportunity.name,
              amount: opportunity.amount,
              stage: opportunity.stage,
              overallRiskLevel: overallRisk,
              riskFactors: risks,
              daysInStage,
              daysToClose,
              recommendations: toolInput.includeRecommendations !== false ? risks.map(r => r.recommendation) : undefined,
            };

            return createMediumRiskResult(true, riskFacts, riskVerifiedResponse, riskData);
          } catch (error) {
            const dealRiskErrorFacts: AnalysisFacts = {
              action_completed: false,
              analysis_completed: false,
              data_sources_used: [],
              records_analyzed: 0,
              confidence_level: 'low',
              data_freshness: `as of ${new Date().toISOString().split('T')[0]}`,
              caveats: [`Analysis failed: ${error.message}`],
            };
            return createMediumRiskResult(false, dealRiskErrorFacts, `Failed to analyze deal risk: ${error.message}`, undefined, error.message);
          }
        }

        case 'get_daily_priorities': {
          try {
            const today = new Date();
            today.setHours(0, 0, 0, 0);
            const tomorrow = new Date(today);
            tomorrow.setDate(tomorrow.getDate() + 1);

            // Get overdue tasks
            const overdueTasks = await this.prisma.task.findMany({
              where: {
                ownerId: userId,
                status: { not: 'COMPLETED' },
                dueDate: { lt: today },
              },
              include: { opportunity: true, lead: true },
              orderBy: { priority: 'desc' },
              take: 5,
            });

            // Get tasks due today
            const todayTasks = await this.prisma.task.findMany({
              where: {
                ownerId: userId,
                status: { not: 'COMPLETED' },
                dueDate: { gte: today, lt: tomorrow },
              },
              include: { opportunity: true, lead: true },
              orderBy: { priority: 'desc' },
              take: 5,
            });

            // Get high-value opportunities needing attention
            const staleOpportunities = await this.prisma.opportunity.findMany({
              where: {
                ownerId: userId,
                stage: { notIn: ['CLOSED_WON', 'CLOSED_LOST'] },
                updatedAt: { lt: new Date(Date.now() - 7 * 24 * 60 * 60 * 1000) },
              },
              orderBy: { amount: 'desc' },
              take: 3,
            });

            // Get hot leads needing follow-up
            const hotLeads = await this.prisma.lead.findMany({
              where: {
                ownerId: userId,
                rating: 'HOT',
                status: { notIn: ['CONVERTED', 'LOST'] },
              },
              orderBy: { updatedAt: 'asc' },
              take: 3,
            });

            const priorities: { priority: number; type: string; title: string; reasoning: string; entityId: string }[] = [];

            // Add overdue tasks as top priorities
            overdueTasks.forEach((task, i) => {
              priorities.push({
                priority: i + 1,
                type: 'OVERDUE_TASK',
                title: task.subject,
                reasoning: `Overdue by ${Math.floor((today.getTime() - task.dueDate!.getTime()) / (1000 * 60 * 60 * 24))} days - complete immediately`,
                entityId: task.id,
              });
            });

            // Add today's tasks
            todayTasks.forEach((task) => {
              priorities.push({
                priority: priorities.length + 1,
                type: 'TODAY_TASK',
                title: task.subject,
                reasoning: `Due today - ${task.priority} priority`,
                entityId: task.id,
              });
            });

            // Add stale high-value opportunities
            staleOpportunities.forEach((opp) => {
              const daysSinceUpdate = Math.floor((Date.now() - opp.updatedAt.getTime()) / (1000 * 60 * 60 * 24));
              priorities.push({
                priority: priorities.length + 1,
                type: 'STALE_OPPORTUNITY',
                title: `Follow up: ${opp.name} ($${opp.amount?.toLocaleString()})`,
                reasoning: `No updates for ${daysSinceUpdate} days - risk of going cold`,
                entityId: opp.id,
              });
            });

            // Add hot leads
            hotLeads.forEach((lead) => {
              priorities.push({
                priority: priorities.length + 1,
                type: 'HOT_LEAD',
                title: `Engage hot lead: ${lead.firstName} ${lead.lastName} at ${lead.company}`,
                reasoning: `Hot lead with high buying intent - strike while iron is hot`,
                entityId: lead.id,
              });
            });

            // Build grounded result for daily priorities - prevents AI from inventing tasks
            const priorityCaveats: string[] = [];
            if (overdueTasks.length === 0 && todayTasks.length === 0) {
              priorityCaveats.push('No tasks due today or overdue - schedule may be clear');
            }
            if (staleOpportunities.length === 0 && hotLeads.length === 0) {
              priorityCaveats.push('No stale opportunities or hot leads found - pipeline may need attention');
            }

            const priorityConfidence: 'high' | 'medium' | 'low' =
              priorities.length >= 5 ? 'high' :
              priorities.length >= 2 ? 'medium' : 'low';

            const priorityFacts: AnalysisFacts = {
              action_completed: true,
              analysis_completed: true,
              data_sources_used: ['tasks', 'opportunities', 'leads'],
              records_analyzed: overdueTasks.length + todayTasks.length + staleOpportunities.length + hotLeads.length,
              confidence_level: priorityConfidence,
              data_freshness: `as of ${new Date().toISOString().split('T')[0]}`,
              caveats: priorityCaveats,
              methodology: 'Priority scoring: overdue tasks first, then due today, then stale high-value opportunities, then hot leads',
            };

            // Build verified response
            let priorityVerifiedResponse = `## Daily Priorities for ${today.toISOString().split('T')[0]}\n`;
            priorityVerifiedResponse += `**Confidence:** ${priorityConfidence.toUpperCase()}\n`;
            priorityVerifiedResponse += `**Records Analyzed:** ${priorityFacts.records_analyzed}\n\n`;

            if (priorities.length === 0) {
              priorityVerifiedResponse += `No high-priority items found for today.\n`;
            } else {
              priorityVerifiedResponse += `### Top ${Math.min(priorities.length, toolInput.maxItems || 10)} Priorities\n`;
              priorities.slice(0, toolInput.maxItems || 10).forEach((p, i) => {
                priorityVerifiedResponse += `${i + 1}. [${p.type}] ${p.title}\n   Reason: ${p.reasoning}\n`;
              });
            }

            if (priorityCaveats.length > 0) {
              priorityVerifiedResponse += `\n### Notes\n`;
              priorityCaveats.forEach(c => {
                priorityVerifiedResponse += `- ${c}\n`;
              });
            }

            const priorityData = {
              date: today.toISOString().split('T')[0],
              totalPriorities: Math.min(priorities.length, toolInput.maxItems || 10),
              priorities: priorities.slice(0, toolInput.maxItems || 10),
            };

            return createMediumRiskResult(true, priorityFacts, priorityVerifiedResponse, priorityData);
          } catch (error) {
            const priorityErrorFacts: AnalysisFacts = {
              action_completed: false,
              analysis_completed: false,
              data_sources_used: [],
              records_analyzed: 0,
              confidence_level: 'low',
              data_freshness: `as of ${new Date().toISOString().split('T')[0]}`,
              caveats: [`Failed to retrieve priorities: ${error.message}`],
            };
            return createMediumRiskResult(false, priorityErrorFacts, `Failed to get priorities: ${error.message}`, undefined, error.message);
          }
        }

        case 'suggest_next_actions': {
          try {
            let entity: any;
            let entityData: any;
            const suggestions: { action: string; priority: 'HIGH' | 'MEDIUM' | 'LOW'; reasoning: string }[] = [];

            if (toolInput.entityType === 'lead') {
              entity = await this.prisma.lead.findUnique({
                where: { id: toolInput.entityId },
                include: { activities: { orderBy: { createdAt: 'desc' }, take: 5 } },
              });
              if (!entity) return { success: false, error: 'Lead not found' };

              // Suggest based on lead status
              if (entity.status === 'NEW') {
                suggestions.push({
                  action: 'Make initial contact within 24 hours',
                  priority: 'HIGH',
                  reasoning: 'New leads have highest engagement rate when contacted quickly',
                });
              }
              if (entity.rating === 'HOT' && entity.status !== 'CONTACTED') {
                suggestions.push({
                  action: 'Schedule a discovery call',
                  priority: 'HIGH',
                  reasoning: 'Hot lead showing strong buying signals - capitalize on interest',
                });
              }
              if (entity.buyingIntent === 'HIGH') {
                suggestions.push({
                  action: 'Send personalized demo invitation',
                  priority: 'HIGH',
                  reasoning: 'High buying intent detected - move to demonstration phase',
                });
              }
              entityData = { name: `${entity.firstName} ${entity.lastName}`, company: entity.company, status: entity.status };

            } else if (toolInput.entityType === 'opportunity') {
              entity = await this.prisma.opportunity.findUnique({
                where: { id: toolInput.entityId },
                include: {
                  activities: { orderBy: { createdAt: 'desc' }, take: 5 },
                  account: true,
                },
              });
              if (!entity) return { success: false, error: 'Opportunity not found' };

              // Suggest based on opportunity stage
              const stageActions: Record<string, { action: string; reasoning: string }[]> = {
                'QUALIFICATION': [
                  { action: 'Complete discovery call to understand needs', reasoning: 'Critical to qualify budget, authority, need, and timeline' },
                  { action: 'Identify key decision makers', reasoning: 'Multi-threading increases win rate by 30%' },
                ],
                'NEEDS_ANALYSIS': [
                  { action: 'Send detailed proposal or solution overview', reasoning: 'Move from discovery to presenting solution' },
                  { action: 'Schedule technical deep-dive', reasoning: 'Address technical requirements and concerns' },
                ],
                'PROPOSAL': [
                  { action: 'Follow up on proposal within 48 hours', reasoning: 'Keep momentum and address questions' },
                  { action: 'Identify and address objections', reasoning: 'Proactively handle concerns before they stall the deal' },
                ],
                'NEGOTIATION': [
                  { action: 'Prepare negotiation strategy and walk-away points', reasoning: 'Enter negotiation prepared with clear boundaries' },
                  { action: 'Get executive sponsor involved', reasoning: 'Executive alignment increases close rate' },
                ],
              };

              (stageActions[entity.stage] || []).forEach(s => {
                suggestions.push({ ...s, priority: 'HIGH' });
              });

              // Days to close check
              const daysToClose = Math.floor((new Date(entity.closeDate).getTime() - Date.now()) / (1000 * 60 * 60 * 24));
              if (daysToClose < 14) {
                suggestions.push({
                  action: 'Create urgency or extend close date',
                  priority: 'HIGH',
                  reasoning: `Only ${daysToClose} days to close date - ensure timeline is realistic`,
                });
              }

              entityData = { name: entity.name, amount: entity.amount, stage: entity.stage };

            } else if (toolInput.entityType === 'account') {
              entity = await this.prisma.account.findUnique({
                where: { id: toolInput.entityId },
                include: {
                  opportunities: { where: { stage: { notIn: ['CLOSED_WON', 'CLOSED_LOST'] } } },
                  contacts: { take: 5 },
                },
              });
              if (!entity) return { success: false, error: 'Account not found' };

              if (entity.opportunities.length === 0) {
                suggestions.push({
                  action: 'Identify expansion opportunities',
                  priority: 'MEDIUM',
                  reasoning: 'No active opportunities - look for cross-sell or upsell',
                });
              }
              if (entity.contacts.length < 3) {
                suggestions.push({
                  action: 'Expand contact network within account',
                  priority: 'MEDIUM',
                  reasoning: 'Multi-threading protects against contact changes',
                });
              }
              entityData = { name: entity.name, industry: entity.industry };
            }

            return {
              success: true,
              data: {
                entityType: toolInput.entityType,
                entityId: toolInput.entityId,
                entitySummary: entityData,
                suggestedActions: suggestions,
              },
            };
          } catch (error) {
            return { success: false, error: `Failed to suggest actions: ${error.message}` };
          }
        }

        case 'prepare_meeting_brief': {
          try {
            let account: any = null;
            let lead: any = null;
            let meeting: any = null;

            if (toolInput.meetingId) {
              meeting = await this.prisma.meetingSession.findUnique({
                where: { id: toolInput.meetingId },
                include: { account: true, lead: true, opportunity: true },
              });
              account = meeting?.account;
              lead = meeting?.lead;
            } else if (toolInput.accountId) {
              account = await this.prisma.account.findUnique({
                where: { id: toolInput.accountId },
                include: {
                  contacts: { take: 5 },
                  opportunities: { where: { stage: { notIn: ['CLOSED_WON', 'CLOSED_LOST'] } }, take: 5 },
                  activities: { orderBy: { createdAt: 'desc' }, take: 5 },
                  meetingSessions: { orderBy: { scheduledStart: 'desc' }, take: 3, include: { analysis: true } },
                },
              });
            } else if (toolInput.leadId) {
              lead = await this.prisma.lead.findUnique({
                where: { id: toolInput.leadId },
                include: {
                  activities: { orderBy: { createdAt: 'desc' }, take: 5 },
                },
              });
            }

            if (!account && !lead) {
              return { success: false, error: 'No account or lead found to prepare brief for' };
            }

            const brief: any = {
              preparedAt: new Date().toISOString(),
            };

            if (account) {
              brief.accountOverview = {
                name: account.name,
                industry: account.industry,
                employees: account.numberOfEmployees,
                revenue: account.annualRevenue,
                website: account.website,
              };
              brief.keyContacts = account.contacts?.map((c: any) => ({
                name: `${c.firstName} ${c.lastName}`,
                title: c.title,
                role: c.role,
              }));
              brief.activeOpportunities = account.opportunities?.map((o: any) => ({
                name: o.name,
                amount: o.amount,
                stage: o.stage,
                closeDate: o.closeDate,
              }));
              brief.recentInteractions = account.activities?.map((a: any) => ({
                type: a.type,
                subject: a.subject,
                date: a.activityDate || a.createdAt,
              }));

              // Extract insights from past meetings
              const pastMeetingInsights = account.meetingSessions
                ?.filter((m: any) => m.analysis)
                .map((m: any) => ({
                  meetingTitle: m.title,
                  keyPoints: m.analysis.keyPoints?.slice(0, 3),
                  objections: m.analysis.objections?.slice(0, 2),
                }));
              if (pastMeetingInsights?.length > 0) {
                brief.pastMeetingInsights = pastMeetingInsights;
              }
            }

            if (lead) {
              brief.leadOverview = {
                name: `${lead.firstName} ${lead.lastName}`,
                company: lead.company,
                title: lead.title,
                email: lead.email,
                status: lead.status,
                rating: lead.rating,
                buyingIntent: lead.buyingIntent,
                painPoints: lead.painPoints,
              };
            }

            // Generate talking points
            brief.suggestedTalkingPoints = [
              'Open with a reference to their recent activity or news',
              'Confirm understanding of their current challenges',
              'Present tailored solution addressing specific pain points',
              'Address any known objections proactively',
              'Establish clear next steps before ending the call',
            ];

            return {
              success: true,
              data: brief,
            };
          } catch (error) {
            return { success: false, error: `Failed to prepare meeting brief: ${error.message}` };
          }
        }

        case 'batch_update_pipeline': {
          try {
            const results: { opportunityId: string; success: boolean; updates: string[] }[] = [];

            for (const update of toolInput.updates) {
              const updateData: any = {};
              const appliedUpdates: string[] = [];

              if (update.stage) {
                updateData.stage = update.stage;
                appliedUpdates.push(`Stage â†’ ${update.stage}`);
              }
              if (update.nextStep) {
                updateData.nextStep = update.nextStep;
                appliedUpdates.push(`Next step updated`);
              }
              if (update.closeDate) {
                updateData.closeDate = new Date(update.closeDate);
                appliedUpdates.push(`Close date â†’ ${update.closeDate}`);
              }

              try {
                await this.prisma.opportunity.update({
                  where: { id: update.opportunityId },
                  data: updateData,
                });

                // Add note if provided
                if (update.notes) {
                  await this.prisma.note.create({
                    data: {
                      userId: userId,
                      opportunityId: update.opportunityId,
                      title: 'Pipeline Update',
                      body: update.notes,
                    },
                  });
                  appliedUpdates.push('Note added');
                }

                results.push({ opportunityId: update.opportunityId, success: true, updates: appliedUpdates });
              } catch (err) {
                results.push({ opportunityId: update.opportunityId, success: false, updates: [`Error: ${err.message}`] });
              }
            }

            const successCount = results.filter(r => r.success).length;
            return {
              success: true,
              message: `Updated ${successCount}/${toolInput.updates.length} opportunities`,
              data: { results },
            };
          } catch (error) {
            return { success: false, error: `Failed to batch update: ${error.message}` };
          }
        }

        // =============================================================================
        // SALESFORCE CRM TOOLS - Direct Salesforce Operations
        // =============================================================================

        case 'sf_query': {
          try {
            let query = toolInput.query;

            // Guard against undefined query - try to extract from malformed args
            if (!query || typeof query !== 'string') {
              // AI sometimes puts the SOQL as a key instead of in the query property
              // Try to extract a valid SOQL from the keys or values
              const keys = Object.keys(toolInput || {});
              const soqlKey = keys.find(k => k.toUpperCase().startsWith('SELECT '));
              if (soqlKey) {
                query = soqlKey;
                this.logger.warn(`[sf_query] Extracted SOQL from malformed args key: ${query.substring(0, 100)}`);
              } else {
                // Try to find SOQL in values
                const values = Object.values(toolInput || {});
                const soqlValue = values.find(v => typeof v === 'string' && v.toUpperCase().startsWith('SELECT '));
                if (soqlValue) {
                  query = soqlValue as string;
                  this.logger.warn(`[sf_query] Extracted SOQL from malformed args value: ${query.substring(0, 100)}`);
                }
              }
            }

            if (!query || typeof query !== 'string') {
              this.logger.error(`[sf_query] Missing or invalid query parameter. toolInput: ${JSON.stringify(toolInput)?.substring(0, 500)}`);
              return { success: false, error: 'Missing required "query" parameter. Provide a valid SOQL query string like: SELECT Id, Name FROM Opportunity LIMIT 10' };
            }

            // Fix common field name mistakes for Task object
            // Salesforce Tasks use ActivityDate, not DueDate
            if (query.includes('FROM Task') && query.includes('DueDate')) {
              query = query.replace(/\bDueDate\b/g, 'ActivityDate');
              this.logger.log(`[sf_query] Corrected DueDate to ActivityDate in Task query`);
            }

            const result = await this.salesforceService.query(userId, query);
            return {
              success: true,
              message: `Query returned ${result.totalSize} record(s)`,
              data: {
                totalSize: result.totalSize,
                done: result.done,
                records: result.records,
              },
            };
          } catch (error) {
            return { success: false, error: `Salesforce query failed: ${error.message}` };
          }
        }

        case 'sf_create_lead': {
          try {
            const data = this.filterSalesforceFields(toolInput);

            const result = await this.salesforceService.create(userId, 'Lead', data);
            const instanceUrl = await this.salesforceService.getInstanceUrl(userId);
            const recordUrl = this.salesforceService.buildLightningUrl(instanceUrl, 'Lead', result.id);

            const fieldsSet = Object.keys(data).filter(k => data[k] !== undefined && data[k] !== null);
            const recordName = `${data.FirstName || ''} ${data.LastName || ''}`.trim();

            const facts: RecordCreateFacts = {
              action_completed: true,
              record_created: true,
              record_id: result.id,
              record_type: 'Lead',
              record_name: recordName,
              fields_set: fieldsSet,
              duplicate_detected: false,
            };

            const verified_response = `Salesforce Lead "${recordName}" created successfully.
- ID: ${result.id} (18-char Salesforce ID)
- Company: ${data.Company || 'Not set'}
- Fields set: ${fieldsSet.join(', ')}

**Lead URL:** ${recordUrl}`;

            return createHighRiskResult(true, facts, verified_response, {
              id: result.id,
              name: recordName,
              company: data.Company,
              createdFields: fieldsSet,
              url: recordUrl,
            });
          } catch (error) {
            const facts: RecordCreateFacts = {
              action_completed: false,
              record_created: false,
              record_type: 'Lead',
              fields_set: [],
              validation_errors: [error.message],
            };
            return createHighRiskResult(false, facts, `Failed to create Salesforce Lead: ${error.message}`);
          }
        }

        case 'sf_update_lead': {
          try {
            const { leadId, ...updateFields } = toolInput;
            const data = this.filterSalesforceFields(updateFields);

            if (Object.keys(data).length === 0) {
              return { success: false, error: 'No fields provided to update' };
            }

            await this.salesforceService.update(userId, 'Lead', leadId, data);
            const instanceUrl = await this.salesforceService.getInstanceUrl(userId);
            const recordUrl = this.salesforceService.buildLightningUrl(instanceUrl, 'Lead', leadId);

            return {
              success: true,
              message: `Lead ${leadId} updated successfully.\n\n**Lead URL:** ${recordUrl}`,
              data: { id: leadId, updatedFields: Object.keys(data), values: data, url: recordUrl },
            };
          } catch (error) {
            return { success: false, error: `Failed to update Lead: ${error.message}` };
          }
        }

        case 'sf_create_opportunity': {
          try {
            const data = this.filterSalesforceFields(toolInput);

            const result = await this.salesforceService.create(userId, 'Opportunity', data);
            const instanceUrl = await this.salesforceService.getInstanceUrl(userId);
            const recordUrl = this.salesforceService.buildLightningUrl(instanceUrl, 'Opportunity', result.id);

            return {
              success: true,
              message: `Opportunity "${data.Name}" created successfully.\n\n**Opportunity URL:** ${recordUrl}`,
              data: {
                id: result.id,
                name: data.Name,
                amount: data.Amount,
                stage: data.StageName,
                closeDate: data.CloseDate,
                createdFields: Object.keys(data),
                url: recordUrl,
              },
            };
          } catch (error) {
            return { success: false, error: `Failed to create Opportunity: ${error.message}` };
          }
        }

        case 'sf_update_opportunity': {
          try {
            this.logger.warn(`[SF_UPDATE_OPP_DEBUG] Raw input: ${JSON.stringify(toolInput)?.substring(0, 500)}`);

            // CRITICAL: Check for required opportunityId FIRST
            if (!toolInput.opportunityId) {
              return {
                success: false,
                error: 'STOP: Missing opportunityId. You need to: 1) Use sf_query to find the Opportunity by name (e.g., SELECT Id, Name, StageName FROM Opportunity WHERE Name LIKE \'%Pyramid%\'), 2) Then ASK the user which stage they want from the valid options.'
              };
            }

            const { opportunityId, ...updateFields } = toolInput;
            const data = this.filterSalesforceFields(updateFields);

            if (Object.keys(data).length === 0) {
              return {
                success: false,
                error: 'STOP: No fields to update provided. You MUST ask the user which stage they want. Present the valid StageName options from sf_describe_object and let the user choose.'
              };
            }

            // Validate that picklist fields have actual values, not placeholders
            if (data.StageName && (data.StageName === '' || data.StageName === 'undefined' || data.StageName === 'null')) {
              return {
                success: false,
                error: 'StageName value is missing. You MUST ask the user which stage they want before updating. Use sf_describe_object to get valid stage options and present them to the user.'
              };
            }

            await this.salesforceService.update(userId, 'Opportunity', opportunityId, data);
            const instanceUrl = await this.salesforceService.getInstanceUrl(userId);
            const recordUrl = this.salesforceService.buildLightningUrl(instanceUrl, 'Opportunity', opportunityId);

            return {
              success: true,
              message: `Opportunity ${opportunityId} updated successfully.\n\n**Opportunity URL:** ${recordUrl}`,
              data: { id: opportunityId, updatedFields: Object.keys(data), values: data, url: recordUrl },
            };
          } catch (error) {
            return { success: false, error: `Failed to update Opportunity: ${error.message}` };
          }
        }

        case 'sf_create_contact': {
          try {
            const data = this.filterSalesforceFields(toolInput);

            const result = await this.salesforceService.create(userId, 'Contact', data);
            const instanceUrl = await this.salesforceService.getInstanceUrl(userId);
            const recordUrl = this.salesforceService.buildLightningUrl(instanceUrl, 'Contact', result.id);
            const contactName = `${data.FirstName || ''} ${data.LastName || ''}`.trim();

            return {
              success: true,
              message: `Contact "${contactName}" created successfully.\n\n**Contact URL:** ${recordUrl}`,
              data: {
                id: result.id,
                name: contactName,
                email: data.Email,
                createdFields: Object.keys(data),
                url: recordUrl,
              },
            };
          } catch (error) {
            return { success: false, error: `Failed to create Contact: ${error.message}` };
          }
        }

        case 'sf_update_contact': {
          try {
            const { contactId, ...updateFields } = toolInput;
            const data = this.filterSalesforceFields(updateFields);

            if (Object.keys(data).length === 0) {
              return { success: false, error: 'No fields provided to update' };
            }

            await this.salesforceService.update(userId, 'Contact', contactId, data);
            const instanceUrl = await this.salesforceService.getInstanceUrl(userId);
            const recordUrl = this.salesforceService.buildLightningUrl(instanceUrl, 'Contact', contactId);

            return {
              success: true,
              message: `Contact ${contactId} updated successfully.\n\n**Contact URL:** ${recordUrl}`,
              data: { id: contactId, updatedFields: Object.keys(data), values: data, url: recordUrl },
            };
          } catch (error) {
            return { success: false, error: `Failed to update Contact: ${error.message}` };
          }
        }

        case 'sf_create_account': {
          try {
            const data = this.filterSalesforceFields(toolInput);

            const result = await this.salesforceService.create(userId, 'Account', data);
            const instanceUrl = await this.salesforceService.getInstanceUrl(userId);
            const recordUrl = this.salesforceService.buildLightningUrl(instanceUrl, 'Account', result.id);

            return {
              success: true,
              message: `Account "${data.Name}" created successfully.\n\n**Account URL:** ${recordUrl}`,
              data: {
                id: result.id,
                name: data.Name,
                createdFields: Object.keys(data),
                url: recordUrl,
              },
            };
          } catch (error) {
            return { success: false, error: `Failed to create Account: ${error.message}` };
          }
        }

        case 'sf_create_task': {
          try {
            const data = this.filterSalesforceFields(toolInput);

            const result = await this.salesforceService.create(userId, 'Task', data);
            const instanceUrl = await this.salesforceService.getInstanceUrl(userId);
            const recordUrl = this.salesforceService.buildLightningUrl(instanceUrl, 'Task', result.id);

            return {
              success: true,
              message: `Task "${data.Subject}" created successfully.\n\n**Task URL:** ${recordUrl}`,
              data: {
                id: result.id,
                subject: data.Subject,
                status: data.Status || 'Not Started',
                dueDate: data.ActivityDate,
                createdFields: Object.keys(data),
                url: recordUrl,
              },
            };
          } catch (error) {
            return { success: false, error: `Failed to create Task: ${error.message}` };
          }
        }

        case 'sf_list_objects': {
          try {
            const result = await this.salesforceService.describeGlobal(userId);
            let objects = result.sobjects || [];
            
            // Apply filter
            const filter = toolInput.filter || 'all';
            if (filter === 'standard') {
              objects = objects.filter((o: any) => !o.custom);
            } else if (filter === 'custom') {
              objects = objects.filter((o: any) => o.custom);
            } else if (filter === 'queryable') {
              objects = objects.filter((o: any) => o.queryable);
            } else if (filter === 'createable') {
              objects = objects.filter((o: any) => o.createable);
            }

            return {
              success: true,
              message: `Found ${objects.length} Salesforce objects`,
              data: {
                totalCount: objects.length,
                objects: objects.slice(0, 100).map((o: any) => ({
                  name: o.name,
                  label: o.label,
                  labelPlural: o.labelPlural,
                  custom: o.custom,
                  queryable: o.queryable,
                  createable: o.createable,
                  updateable: o.updateable,
                  deletable: o.deletable,
                  searchable: o.searchable,
                })),
              },
            };
          } catch (error) {
            return { success: false, error: `Failed to list objects: ${error.message}` };
          }
        }

        case 'sf_describe_object': {
          try {
            this.logger.warn(`[SF_DESCRIBE_DEBUG] Raw toolInput: ${JSON.stringify(toolInput)?.substring(0, 300)}`);
            // Check for objectType or common synonyms (objectName, sobjectType, object, type)
            let objectType = toolInput.objectType || toolInput.objectName || toolInput.sobjectType || toolInput.object || toolInput.type;

            // Guard against malformed args - AI sometimes passes objectType as key or value incorrectly
            if (!objectType || typeof objectType !== 'string') {
              const validObjects = ['Opportunity', 'Lead', 'Contact', 'Account', 'Task', 'Case', 'Campaign', 'Event', 'User'];
              const keys = Object.keys(toolInput || {});
              const values = Object.values(toolInput || {});

              // Check if a valid object name is in the keys
              const objectInKey = keys.find(k => validObjects.some(v => k.toLowerCase() === v.toLowerCase()));
              if (objectInKey) {
                objectType = validObjects.find(v => v.toLowerCase() === objectInKey.toLowerCase());
                this.logger.warn(`[SF_DESCRIBE_DEBUG] Extracted objectType from malformed key: ${objectType}`);
              } else {
                // Check if a valid object name is in the values
                const objectInValue = values.find(v => typeof v === 'string' && validObjects.some(obj => v.toLowerCase() === obj.toLowerCase()));
                if (objectInValue) {
                  objectType = validObjects.find(v => v.toLowerCase() === (objectInValue as string).toLowerCase());
                  this.logger.warn(`[SF_DESCRIBE_DEBUG] Extracted objectType from malformed value: ${objectType}`);
                }
              }
            }

            this.logger.warn(`[SF_DESCRIBE_DEBUG] Input: objectType=${objectType}, fieldFilter=${toolInput.fieldFilter}`);

            if (!objectType) {
              this.logger.error(`[SF_DESCRIBE_DEBUG] Missing objectType parameter. Raw input: ${JSON.stringify(toolInput)?.substring(0, 200)}`);
              return { success: false, error: 'Missing required "objectType" parameter. Specify the Salesforce object (e.g., Opportunity, Lead, Contact, Account, Task)' };
            }

            const metadata = await this.salesforceService.describeSObject(userId, objectType);
            this.logger.warn(`[SF_DESCRIBE_DEBUG] Got metadata for ${objectType}, fields count: ${metadata?.fields?.length}`);
            
            // Apply field filter
            let filteredFields = metadata.fields || [];
            const fieldFilter = toolInput.fieldFilter || 'all';
            
            if (fieldFilter === 'updateable') {
              filteredFields = filteredFields.filter((f: any) => f.updateable);
            } else if (fieldFilter === 'createable') {
              filteredFields = filteredFields.filter((f: any) => f.createable);
            } else if (fieldFilter === 'required') {
              filteredFields = filteredFields.filter((f: any) => !f.nillable && !f.defaultedOnCreate);
            }
            
            // Extract useful field info (show more fields now - up to 100)
            const fields = filteredFields.slice(0, 100).map((f: any) => ({
              name: f.name,
              label: f.label,
              type: f.type,
              length: f.length,
              required: !f.nillable && !f.defaultedOnCreate,
              updateable: f.updateable,
              createable: f.createable,
              picklistValues: f.picklistValues?.length > 0 
                ? f.picklistValues.filter((v: any) => v.active).map((v: any) => v.value).slice(0, 20) 
                : undefined,
              referenceTo: f.referenceTo?.length > 0 ? f.referenceTo : undefined,
            }));

            return {
              success: true,
              message: `Metadata for ${toolInput.objectType} (${filteredFields.length} fields${fieldFilter !== 'all' ? ` matching filter: ${fieldFilter}` : ''})`,
              data: {
                name: metadata.name,
                label: metadata.label,
                labelPlural: metadata.labelPlural,
                keyPrefix: metadata.keyPrefix,
                custom: metadata.custom,
                createable: metadata.createable,
                updateable: metadata.updateable,
                deletable: metadata.deletable,
                queryable: metadata.queryable,
                searchable: metadata.searchable,
                totalFieldCount: metadata.fields?.length,
                filteredFieldCount: filteredFields.length,
                fields,
              },
            };
          } catch (error) {
            this.logger.error(`[SF_DESCRIBE_DEBUG] Error describing ${toolInput.objectType}: ${error.message}`);
            return { success: false, error: `Failed to describe ${toolInput.objectType}: ${error.message}` };
          }
        }

        case 'sf_get_record': {
          try {
            let { objectType, recordId, fields } = toolInput;

            // Auto-detect objectType from Salesforce ID prefix if not provided
            if (!objectType && recordId) {
              const inferredType = IdValidator.getSalesforceObjectType(recordId);
              if (inferredType) {
                objectType = inferredType;
                this.logger.log(`[sf_get_record] Inferred objectType "${objectType}" from ID prefix for ${recordId}`);
              } else {
                return { success: false, error: `Could not determine object type for record ID "${recordId}". Please specify objectType parameter.` };
              }
            }

            if (!objectType) {
              return { success: false, error: 'objectType is required. Please specify the Salesforce object type (e.g., Task, Lead, Contact, Account, Opportunity).' };
            }

            let fieldList = fields;

            // If no fields specified, dynamically discover queryable fields from object metadata
            if (!fieldList) {
              try {
                const metadata = await this.salesforceService.describeSObject(userId, objectType);
                // Get all queryable fields, limit to first 50 to avoid query limits
                const queryableFields = metadata.fields
                  ?.filter((f: any) => !f.deprecatedAndHidden && f.type !== 'address' && f.type !== 'location')
                  ?.slice(0, 50)
                  ?.map((f: any) => f.name) || ['Id', 'Name'];
                fieldList = queryableFields.join(', ');
              } catch {
                // Fallback to default fields if describe fails
                fieldList = this.getDefaultFields(objectType);
              }
            } else {
              // Fix common field name mistakes for Task object
              // Salesforce Tasks use ActivityDate, not DueDate
              if (objectType === 'Task' && fieldList.includes('DueDate')) {
                fieldList = fieldList.replace(/\bDueDate\b/g, 'ActivityDate');
                this.logger.log(`[sf_get_record] Corrected DueDate to ActivityDate for Task query`);
              }
            }

            const query = `SELECT ${fieldList} FROM ${objectType} WHERE Id = '${recordId}' LIMIT 1`;
            const result = await this.salesforceService.query(userId, query);

            if (result.totalSize === 0) {
              return { success: false, error: `Record ${recordId} not found` };
            }

            return {
              success: true,
              message: `Retrieved ${objectType} record`,
              data: result.records[0],
            };
          } catch (error) {
            return { success: false, error: `Failed to get record: ${error.message}` };
          }
        }

        case 'sf_update_record': {
          try {
            this.logger.warn(`[SF_UPDATE_RECORD_DEBUG] Raw input: ${JSON.stringify(toolInput)?.substring(0, 500)}`);
            let { objectType, recordId, fields } = toolInput;

            // Check for placeholder or invalid IDs - AI sometimes uses fake IDs instead of searching first
            const invalidIdPatterns = ['xxxx', 'XXXX', '0000', 'test', 'example', 'placeholder'];
            const isPlaceholderId = recordId && invalidIdPatterns.some(p => recordId.includes(p));
            const isObjectNameAsId = recordId && ['Opportunity', 'Lead', 'Contact', 'Account', 'Task', 'Case'].includes(recordId);

            if (!recordId || isPlaceholderId || isObjectNameAsId || (recordId && recordId.length < 15)) {
              return {
                success: false,
                error: `STOP: Invalid or missing recordId "${recordId || 'none'}". You MUST first search for the record using sf_query. Example: SELECT Id, Name, StageName FROM Opportunity WHERE Name LIKE '%Pyramid%' to find the actual Salesforce ID, then ask the user which stage they want.`
              };
            }

            // Auto-detect objectType from Salesforce ID prefix if not provided
            if (!objectType && recordId) {
              const inferredType = IdValidator.getSalesforceObjectType(recordId);
              if (inferredType) {
                objectType = inferredType;
                this.logger.log(`[sf_update_record] Inferred objectType "${objectType}" from ID prefix for ${recordId}`);
              } else {
                return { success: false, error: `Could not determine object type for record ID "${recordId}". Please specify objectType parameter.` };
              }
            }

            if (!objectType) {
              return { success: false, error: 'objectType is required. Please specify the Salesforce object type (e.g., Task, Lead, Contact, Account, Opportunity).' };
            }

            // Validate and normalize fields input - handle edge cases where AI might pass incorrect format
            let normalizedFields = fields;

            // Handle case where fields is a string (JSON that needs parsing)
            if (typeof fields === 'string') {
              try {
                normalizedFields = JSON.parse(fields);
              } catch {
                return { success: false, error: 'Invalid fields format: expected an object with field names and values' };
              }
            }

            // Handle case where fields is an array (should be object)
            if (Array.isArray(normalizedFields)) {
              if (normalizedFields.length === 1 && typeof normalizedFields[0] === 'object') {
                // Extract the first object from array
                normalizedFields = normalizedFields[0];
              } else {
                return { success: false, error: 'Invalid fields format: expected an object, received an array' };
              }
            }

            if (!normalizedFields || typeof normalizedFields !== 'object' || Object.keys(normalizedFields).length === 0) {
              return { success: false, error: 'No fields provided to update' };
            }

            // Fix common field name mistakes for Task object
            // Salesforce Tasks use ActivityDate, not DueDate
            if (objectType === 'Task' && normalizedFields.DueDate !== undefined) {
              normalizedFields.ActivityDate = normalizedFields.DueDate;
              delete normalizedFields.DueDate;
              this.logger.log(`[sf_update_record] Corrected DueDate to ActivityDate for Task update`);
            }

            const updateData = this.filterSalesforceFields(normalizedFields);

            if (Object.keys(updateData).length === 0) {
              return {
                success: false,
                error: 'No valid fields to update. IMPORTANT: You must ASK the user what value they want before calling this tool. Do not guess or use placeholder values.'
              };
            }

            // Validate that picklist fields have actual values, not empty/placeholder values
            const picklistFields = ['StageName', 'Status', 'Type', 'Priority', 'Rating', 'LeadSource', 'Industry'];
            for (const field of picklistFields) {
              if (updateData[field] !== undefined && (updateData[field] === '' || updateData[field] === 'undefined' || updateData[field] === 'null' || updateData[field] === null)) {
                return {
                  success: false,
                  error: `${field} value is empty or invalid. You MUST ask the user which ${field} value they want before updating. Use sf_describe_object to get valid options and present them to the user.`
                };
              }
            }

            await this.salesforceService.update(userId, objectType, recordId, updateData);
            const instanceUrl = await this.salesforceService.getInstanceUrl(userId);
            const recordUrl = this.salesforceService.buildLightningUrl(instanceUrl, objectType, recordId);

            return {
              success: true,
              message: `${objectType} ${recordId} updated successfully.\n\n**${objectType} URL:** ${recordUrl}`,
              data: {
                id: recordId,
                objectType,
                updatedFields: Object.keys(updateData),
                values: updateData,
                url: recordUrl,
              },
            };
          } catch (error) {
            return { success: false, error: `Failed to update ${toolInput.objectType}: ${error.message}` };
          }
        }

        case 'sf_create_record': {
          try {
            const { objectType, fields } = toolInput;

            if (!fields || Object.keys(fields).length === 0) {
              return { success: false, error: 'No fields provided for new record' };
            }

            const createData = this.filterSalesforceFields(fields);

            const result = await this.salesforceService.create(userId, objectType, createData);
            const instanceUrl = await this.salesforceService.getInstanceUrl(userId);
            const recordUrl = this.salesforceService.buildLightningUrl(instanceUrl, objectType, result.id);

            return {
              success: true,
              message: `${objectType} created successfully.\n\n**${objectType} URL:** ${recordUrl}`,
              data: {
                id: result.id,
                objectType,
                createdFields: Object.keys(createData),
                values: createData,
                url: recordUrl,
              },
            };
          } catch (error) {
            return { success: false, error: `Failed to create ${toolInput.objectType}: ${error.message}` };
          }
        }

        case 'sf_delete_record': {
          try {
            const { objectType, recordId } = toolInput;
            
            await this.salesforceService.delete(userId, objectType, recordId);
            
            return {
              success: true,
              message: `${objectType} ${recordId} deleted successfully`,
              data: { 
                id: recordId, 
                objectType,
                deleted: true
              },
            };
          } catch (error) {
            return { success: false, error: `Failed to delete ${toolInput.objectType}: ${error.message}` };
          }
        }

        case 'sf_search': {
          try {
            const { searchTerm, objects, limit } = toolInput;
            const maxLimit = limit || 20;
            
            // Build SOSL query
            let sosl = `FIND {${searchTerm.replace(/[{}]/g, '')}}`;
            
            if (objects && objects.length > 0) {
              // Search in specific objects
              const objectClauses = objects.map(obj => `${obj}(FIELDS(ALL) LIMIT ${maxLimit})`).join(', ');
              sosl += ` IN ALL FIELDS RETURNING ${objectClauses}`;
            } else {
              // Search in common objects
              sosl += ` IN ALL FIELDS RETURNING Lead(FIELDS(STANDARD) LIMIT ${maxLimit}), Contact(FIELDS(STANDARD) LIMIT ${maxLimit}), Account(FIELDS(STANDARD) LIMIT ${maxLimit}), Opportunity(FIELDS(STANDARD) LIMIT ${maxLimit})`;
            }
            
            const result = await this.salesforceService.search(userId, sosl);
            
            // Flatten and format search results for mobile-friendly display
            const searchResults = result.searchRecords || [];

            // Extract only essential fields based on object type
            const formattedRecords = searchResults.map((r: any) => {
              const objectType = r.attributes?.type;
              const base = {
                id: r.Id,
                objectType,
                name: r.Name,
              };

              switch (objectType) {
                case 'Lead':
                  return {
                    ...base,
                    email: r.Email,
                    phone: r.Phone,
                    company: r.Company,
                    title: r.Title,
                    status: r.Status,
                  };
                case 'Contact':
                  return {
                    ...base,
                    email: r.Email,
                    phone: r.Phone,
                    title: r.Title,
                    accountName: r.Account?.Name,
                  };
                case 'Account':
                  return {
                    ...base,
                    industry: r.Industry,
                    phone: r.Phone,
                    website: r.Website,
                    type: r.Type,
                  };
                case 'Opportunity':
                  return {
                    ...base,
                    amount: r.Amount,
                    stageName: r.StageName,
                    closeDate: r.CloseDate,
                    accountName: r.Account?.Name,
                  };
                default:
                  return base;
              }
            });

            return {
              success: true,
              message: `Found ${searchResults.length} results for "${searchTerm}"`,
              data: {
                searchTerm,
                totalResults: searchResults.length,
                records: formattedRecords,
              },
            };
          } catch (error) {
            return { success: false, error: `Search failed: ${error.message}` };
          }
        }

        // =============================================================================
        // SALESFORCE ADMIN/CONFIG TOOLS - Tooling API Operations
        // =============================================================================

        case 'sf_tooling_query': {
          try {
            const result = await this.salesforceService.toolingQuery(userId, toolInput.query);
            return {
              success: true,
              message: `Tooling query returned ${result.totalSize} record(s)`,
              data: {
                totalSize: result.totalSize,
                done: result.done,
                records: result.records,
              },
            };
          } catch (error) {
            return { success: false, error: `Tooling query failed: ${error.message}` };
          }
        }

        case 'sf_list_users': {
          try {
            const limit = toolInput.limit || 50;
            const result = await this.salesforceService.listUsers(userId, limit);
            return {
              success: true,
              message: `Found ${result.totalSize} active user(s)`,
              data: result.records?.map((u: any) => ({
                id: u.Id,
                username: u.Username,
                name: u.Name,
                email: u.Email,
                profile: u.Profile?.Name,
                role: u.UserRole?.Name,
                lastLogin: u.LastLoginDate,
              })),
            };
          } catch (error) {
            return { success: false, error: `Failed to list users: ${error.message}` };
          }
        }

        case 'sf_list_profiles': {
          try {
            const result = await this.salesforceService.listProfiles(userId);
            return {
              success: true,
              message: `Found ${result.totalSize} profile(s)`,
              data: result.records?.map((p: any) => ({
                id: p.Id,
                name: p.Name,
                description: p.Description,
                userType: p.UserType,
              })),
            };
          } catch (error) {
            return { success: false, error: `Failed to list profiles: ${error.message}` };
          }
        }

        case 'sf_list_permission_sets': {
          try {
            const result = await this.salesforceService.listPermissionSets(userId);
            return {
              success: true,
              message: `Found ${result.totalSize} permission set(s)`,
              data: result.records?.map((ps: any) => ({
                id: ps.Id,
                name: ps.Name,
                label: ps.Label,
                description: ps.Description,
                isCustom: ps.IsCustom,
              })),
            };
          } catch (error) {
            return { success: false, error: `Failed to list permission sets: ${error.message}` };
          }
        }

        case 'sf_assign_permission_set': {
          try {
            const result = await this.salesforceService.assignPermissionSet(
              userId,
              toolInput.assigneeId,
              toolInput.permissionSetId
            );
            return {
              success: true,
              message: `Permission set assigned successfully`,
              data: { id: result.id },
            };
          } catch (error) {
            return { success: false, error: `Failed to assign permission set: ${error.message}` };
          }
        }

        case 'sf_list_custom_fields': {
          try {
            const result = await this.salesforceService.listCustomFields(userId, toolInput.objectName);
            return {
              success: true,
              message: `Found ${result.totalSize} custom field(s) on ${toolInput.objectName}`,
              data: result.records?.map((f: any) => ({
                id: f.Id,
                developerName: f.DeveloperName,
                fullName: f.FullName,
              })),
            };
          } catch (error) {
            return { success: false, error: `Failed to list custom fields: ${error.message}` };
          }
        }

        case 'sf_list_validation_rules': {
          try {
            const result = await this.salesforceService.listValidationRules(userId, toolInput.objectName);
            return {
              success: true,
              message: `Found ${result.totalSize} validation rule(s) on ${toolInput.objectName}`,
              data: result.records?.map((vr: any) => ({
                id: vr.Id,
                name: vr.ValidationName,
                active: vr.Active,
                errorMessage: vr.ErrorMessage,
              })),
            };
          } catch (error) {
            return { success: false, error: `Failed to list validation rules: ${error.message}` };
          }
        }

        case 'sf_toggle_validation_rule': {
          try {
            await this.salesforceService.toggleValidationRule(
              userId,
              toolInput.validationRuleId,
              toolInput.active
            );
            return {
              success: true,
              message: `Validation rule ${toolInput.active ? 'activated' : 'deactivated'} successfully`,
              data: { id: toolInput.validationRuleId, active: toolInput.active },
            };
          } catch (error) {
            return { success: false, error: `Failed to toggle validation rule: ${error.message}` };
          }
        }

        case 'sf_list_flows': {
          try {
            const activeOnly = toolInput.activeOnly !== false;
            const result = await this.salesforceService.listFlows(userId, activeOnly);
            return {
              success: true,
              message: `Found ${result.totalSize} flow(s)`,
              data: result.records?.map((f: any) => ({
                id: f.Id,
                developerName: f.DeveloperName,
                label: f.MasterLabel,
                processType: f.ProcessType,
                status: f.Status,
                description: f.Description,
              })),
            };
          } catch (error) {
            return { success: false, error: `Failed to list flows: ${error.message}` };
          }
        }

        case 'sf_list_record_types': {
          try {
            const result = await this.salesforceService.listRecordTypes(userId, toolInput.objectName);
            return {
              success: true,
              message: `Found ${result.totalSize} record type(s) on ${toolInput.objectName}`,
              data: result.records?.map((rt: any) => ({
                id: rt.Id,
                name: rt.Name,
                developerName: rt.DeveloperName,
                description: rt.Description,
                isActive: rt.IsActive,
              })),
            };
          } catch (error) {
            return { success: false, error: `Failed to list record types: ${error.message}` };
          }
        }

        case 'sf_get_org_limits': {
          try {
            const limits = await this.salesforceService.getOrgLimits(userId);
            // Format key limits for readability
            const keyLimits = {
              DailyApiRequests: limits.DailyApiRequests,
              DailyAsyncApexExecutions: limits.DailyAsyncApexExecutions,
              DailyBulkApiRequests: limits.DailyBulkApiRequests,
              DataStorageMB: limits.DataStorageMB,
              FileStorageMB: limits.FileStorageMB,
              HourlyDashboardRefreshes: limits.HourlyDashboardRefreshes,
              HourlyTimeBasedWorkflow: limits.HourlyTimeBasedWorkflow,
              SingleEmail: limits.SingleEmail,
              MassEmail: limits.MassEmail,
            };
            return {
              success: true,
              message: 'Org limits retrieved',
              data: keyLimits,
            };
          } catch (error) {
            return { success: false, error: `Failed to get org limits: ${error.message}` };
          }
        }

        case 'sf_list_apex_classes': {
          try {
            const limit = toolInput.limit || 100;
            const result = await this.salesforceService.listApexClasses(userId, limit);
            return {
              success: true,
              message: `Found ${result.totalSize} Apex class(es)`,
              data: result.records?.map((c: any) => ({
                id: c.Id,
                name: c.Name,
                status: c.Status,
                isValid: c.IsValid,
                namespace: c.NamespacePrefix,
                lastModified: c.LastModifiedDate,
              })),
            };
          } catch (error) {
            return { success: false, error: `Failed to list Apex classes: ${error.message}` };
          }
        }

        case 'sf_list_apex_triggers': {
          try {
            const result = await this.salesforceService.listApexTriggers(userId, toolInput.objectName);
            return {
              success: true,
              message: `Found ${result.totalSize} Apex trigger(s)`,
              data: result.records?.map((t: any) => ({
                id: t.Id,
                name: t.Name,
                object: t.TableEnumOrId,
                status: t.Status,
                isValid: t.IsValid,
              })),
            };
          } catch (error) {
            return { success: false, error: `Failed to list Apex triggers: ${error.message}` };
          }
        }

        case 'sf_run_apex_tests': {
          try {
            const testRunId = await this.salesforceService.runApexTests(userId, toolInput.testClassId);

            // Note: This is an asynchronous operation - tests are submitted but not completed yet
            // The testRunId can be used to check status via sf_get_test_results
            const facts: TestExecutionFacts = {
              action_completed: true,
              tests_executed: false, // Tests are submitted but running asynchronously
              total_tests: 0,  // Unknown until tests complete
              tests_passed: 0,
              tests_failed: 0,
              failed_test_names: [],
            };

            const verified_response = toolInput.testClassId
              ? `Apex test class submitted for asynchronous execution.
- Test Run ID: ${testRunId}
- Status: Tests are now running in the background
- Use sf_get_test_results with this Test Run ID to check completion status and results`
              : `All local Apex tests submitted for asynchronous execution.
- Test Run ID: ${testRunId}
- Status: Tests are now running in the background
- Use sf_get_test_results with this Test Run ID to check completion status and results`;

            return createCriticalResult(
              true,
              facts,
              verified_response,
              { testRunId },
            );
          } catch (error) {
            const facts: TestExecutionFacts = {
              action_completed: false,
              tests_executed: false,
              total_tests: 0,
              tests_passed: 0,
              tests_failed: 0,
              failed_test_names: [],
            };
            return createCriticalResult(
              false,
              facts,
              `Failed to submit Apex tests: ${error.message}`,
              undefined,
              error.message,
            );
          }
        }

        case 'sf_list_installed_packages': {
          try {
            const result = await this.salesforceService.listInstalledPackages(userId);
            return {
              success: true,
              message: `Found ${result.totalSize} installed package(s)`,
              data: result.records?.map((p: any) => ({
                id: p.Id,
                name: p.SubscriberPackage?.Name,
                namespace: p.SubscriberPackage?.NamespacePrefix,
                version: `${p.SubscriberPackageVersion?.MajorVersion}.${p.SubscriberPackageVersion?.MinorVersion}`,
              })),
            };
          } catch (error) {
            return { success: false, error: `Failed to list installed packages: ${error.message}` };
          }
        }

        case 'sf_execute_apex': {
          try {
            const result = await this.salesforceService.executeAnonymousApex(userId, toolInput.apexCode);

            const executionSuccess = result.compiled && result.success;
            let executionResult: 'success' | 'failure' | 'compile_error' | 'runtime_error' = 'success';
            if (!result.compiled) {
              executionResult = 'compile_error';
            } else if (!result.success) {
              executionResult = 'runtime_error';
            }

            const facts: CodeExecutionFacts = {
              action_completed: true,
              execution_completed: executionSuccess,
              execution_result: executionResult,
              output: result.success ? 'Code executed without errors' : undefined,
              error_message: result.compileProblem || result.exceptionMessage || undefined,
              logs: result.exceptionStackTrace ? [result.exceptionStackTrace] : undefined,
            };

            let verified_response: string;
            if (executionSuccess) {
              verified_response = `Anonymous Apex executed successfully.
- Compilation: Passed
- Execution: Completed without errors`;
            } else if (!result.compiled) {
              verified_response = `Anonymous Apex compilation failed.
- Compilation: FAILED
- Error: ${result.compileProblem}
- Location: Line ${result.line || 'unknown'}, Column ${result.column || 'unknown'}`;
            } else {
              verified_response = `Anonymous Apex runtime error.
- Compilation: Passed
- Execution: FAILED
- Exception: ${result.exceptionMessage}${result.exceptionStackTrace ? `
- Stack trace: ${result.exceptionStackTrace}` : ''}`;
            }

            return createCriticalResult(
              executionSuccess,
              facts,
              verified_response,
              {
                compiled: result.compiled,
                success: result.success,
                compileProblem: result.compileProblem,
                exceptionMessage: result.exceptionMessage,
                exceptionStackTrace: result.exceptionStackTrace,
                line: result.line,
                column: result.column,
              },
            );
          } catch (error) {
            const facts: CodeExecutionFacts = {
              action_completed: false,
              execution_completed: false,
              execution_result: 'failure',
              error_message: error.message,
            };
            return createCriticalResult(
              false,
              facts,
              `Failed to execute Apex: ${error.message}`,
              undefined,
              error.message,
            );
          }
        }

        // =============================================================================
        // METADATA MODIFICATION TOOLS
        // =============================================================================

        case 'sf_create_custom_field': {
          try {
            const result = await this.salesforceService.createCustomField(userId, toolInput.objectName, {
              fullName: toolInput.fullName,
              label: toolInput.label,
              type: toolInput.type,
              length: toolInput.length,
              precision: toolInput.precision,
              scale: toolInput.scale,
              required: toolInput.required,
              unique: toolInput.unique,
              description: toolInput.description,
              helpText: toolInput.helpText,
              picklistValues: toolInput.picklistValues,
              referenceTo: toolInput.referenceTo,
              relationshipLabel: toolInput.relationshipLabel,
              defaultValue: toolInput.defaultValue,
            });

            if (result.success) {
              return {
                success: true,
                message: `Successfully created custom field '${toolInput.label}' (${toolInput.fullName}__c) on ${toolInput.objectName}`,
                data: {
                  fieldId: result.fieldId,
                  objectName: toolInput.objectName,
                  fieldName: toolInput.fullName.endsWith('__c') ? toolInput.fullName : `${toolInput.fullName}__c`,
                  fieldType: toolInput.type,
                },
                nextSteps: [
                  'The field is now available in the org',
                  'You may need to add it to page layouts for visibility',
                  'Consider setting field-level security for appropriate profiles',
                ],
              };
            } else {
              return {
                success: false,
                error: result.error,
                errorCode: result.errorCode,
                suggestions: result.suggestions,
                message: `Failed to create field: ${result.error}`,
              };
            }
          } catch (error) {
            return { 
              success: false, 
              error: `Failed to create custom field: ${error.message}`,
              suggestions: [
                'Verify you have Customize Application permission',
                'Check if a field with this name already exists',
                'Ensure the object name is correct',
              ],
            };
          }
        }

        case 'sf_create_custom_object': {
          try {
            const result = await this.salesforceService.createCustomObject(userId, {
              fullName: toolInput.fullName,
              label: toolInput.label,
              pluralLabel: toolInput.pluralLabel,
              description: toolInput.description,
              nameFieldType: toolInput.nameFieldType,
              nameFieldLabel: toolInput.nameFieldLabel,
              nameFieldFormat: toolInput.nameFieldFormat,
              allowReports: toolInput.allowReports,
              allowActivities: toolInput.allowActivities,
              allowSearch: toolInput.allowSearch,
              sharingModel: toolInput.sharingModel,
            });

            if (result.success) {
              const objectApiName = toolInput.fullName.endsWith('__c') ? toolInput.fullName : `${toolInput.fullName}__c`;
              return {
                success: true,
                message: `Successfully created custom object '${toolInput.label}' (${objectApiName})`,
                data: {
                  objectId: result.objectId,
                  objectApiName,
                  label: toolInput.label,
                  pluralLabel: toolInput.pluralLabel,
                },
                nextSteps: [
                  `The object ${objectApiName} is now available`,
                  'Add custom fields to extend the object',
                  'Create a Tab to make it visible in the UI',
                  'Set up page layouts and record types as needed',
                  'Configure sharing settings and profiles',
                ],
              };
            } else {
              return {
                success: false,
                error: result.error,
                errorCode: result.errorCode,
                suggestions: result.suggestions,
                message: `Failed to create object: ${result.error}`,
              };
            }
          } catch (error) {
            return { 
              success: false, 
              error: `Failed to create custom object: ${error.message}`,
              suggestions: [
                'Verify you have Customize Application permission',
                'Check your custom object limits (sf_get_org_limits)',
                'Ensure the object name is unique',
              ],
            };
          }
        }

        case 'sf_create_validation_rule': {
          try {
            const result = await this.salesforceService.createValidationRule(userId, toolInput.objectName, {
              name: toolInput.name,
              description: toolInput.description,
              errorConditionFormula: toolInput.errorConditionFormula,
              errorMessage: toolInput.errorMessage,
              errorDisplayField: toolInput.errorDisplayField,
              active: toolInput.active !== false,
            });

            if (result.success) {
              return {
                success: true,
                message: `Successfully created validation rule '${toolInput.name}' on ${toolInput.objectName}`,
                data: {
                  ruleId: result.ruleId,
                  objectName: toolInput.objectName,
                  ruleName: toolInput.name,
                  active: toolInput.active !== false,
                  formula: toolInput.errorConditionFormula,
                },
                nextSteps: [
                  toolInput.active !== false 
                    ? 'The validation rule is now active and will fire on record saves' 
                    : 'The rule was created but is inactive - activate it when ready',
                  'Test the rule by trying to save a record that violates it',
                  'Use sf_toggle_validation_rule to activate/deactivate as needed',
                ],
              };
            } else {
              return {
                success: false,
                error: result.error,
                errorCode: result.errorCode,
                suggestions: result.suggestions,
                message: `Failed to create validation rule: ${result.error}`,
              };
            }
          } catch (error) {
            return { 
              success: false, 
              error: `Failed to create validation rule: ${error.message}`,
              suggestions: [
                'Check your formula syntax - use ISBLANK(), AND(), OR(), etc.',
                'Verify all field API names in the formula exist on the object',
                'Remember: formula returns TRUE when record is INVALID',
              ],
            };
          }
        }

        case 'sf_add_picklist_values': {
          try {
            const result = await this.salesforceService.addPicklistValues(
              userId,
              toolInput.objectName,
              toolInput.fieldName,
              toolInput.newValues
            );

            if (result.success) {
              return {
                success: true,
                message: `Successfully added ${toolInput.newValues.length} value(s) to ${toolInput.fieldName} on ${toolInput.objectName}`,
                data: {
                  objectName: toolInput.objectName,
                  fieldName: toolInput.fieldName,
                  addedValues: toolInput.newValues,
                },
              };
            } else {
              return {
                success: false,
                error: result.error,
                errorCode: result.errorCode,
                suggestions: result.suggestions,
                message: `Failed to add picklist values: ${result.error}`,
              };
            }
          } catch (error) {
            return { 
              success: false, 
              error: `Failed to add picklist values: ${error.message}`,
              suggestions: [
                'Verify the field is a local picklist (not a global value set)',
                'Check the field API name is correct',
                'Use sf_list_custom_fields to confirm the field exists',
              ],
            };
          }
        }

        case 'sf_update_field_level_security': {
          try {
            const result = await this.salesforceService.updateFieldLevelSecurity(
              userId,
              toolInput.profileName,
              toolInput.objectName,
              toolInput.fieldName,
              { readable: toolInput.readable, editable: toolInput.editable }
            );

            if (result.success) {
              return {
                success: true,
                message: `Updated field-level security for ${toolInput.fieldName} on profile '${toolInput.profileName}'`,
                data: {
                  profileName: toolInput.profileName,
                  objectName: toolInput.objectName,
                  fieldName: toolInput.fieldName,
                  readable: toolInput.readable,
                  editable: toolInput.editable,
                },
              };
            } else {
              return {
                success: false,
                error: result.error,
                errorCode: result.errorCode,
                suggestions: result.suggestions,
                message: `Failed to update FLS: ${result.error}`,
              };
            }
          } catch (error) {
            return { 
              success: false, 
              error: `Failed to update field-level security: ${error.message}`,
              suggestions: [
                'Verify the profile name is exact (case-sensitive)',
                'Use sf_list_profiles to see available profiles',
                'Some standard fields cannot have FLS modified',
              ],
            };
          }
        }

        case 'sf_validate_metadata': {
          try {
            const result = await this.salesforceService.validateMetadataChange(
              userId,
              toolInput.metadataType,
              toolInput.metadata
            );

            return {
              success: result.valid,
              message: result.valid 
                ? 'Metadata validation passed - safe to proceed with creation' 
                : `Validation found ${result.errors.length} error(s)`,
              data: {
                valid: result.valid,
                errors: result.errors,
                warnings: result.warnings,
              },
              suggestions: result.valid 
                ? ['You can proceed to create this metadata']
                : result.errors,
            };
          } catch (error) {
            return { 
              success: false, 
              error: `Failed to validate metadata: ${error.message}`,
            };
          }
        }

        // =============================================================================
        // EXTENDED ADMIN TOOLS
        // =============================================================================

        case 'sf_toggle_flow': {
          try {
            const result = await this.salesforceService.toggleFlow(userId, toolInput.flowId, toolInput.activate);
            if (result.success) {
              return {
                success: true,
                message: `Flow ${toolInput.activate ? 'activated' : 'deactivated'} successfully`,
              };
            }
            return { success: false, error: result.error, suggestions: result.suggestions };
          } catch (error) {
            return { success: false, error: `Failed to toggle flow: ${error.message}` };
          }
        }

        case 'sf_create_user': {
          try {
            const result = await this.salesforceService.createUser(userId, {
              username: toolInput.username,
              email: toolInput.email,
              firstName: toolInput.firstName,
              lastName: toolInput.lastName,
              alias: toolInput.alias,
              profileId: toolInput.profileId,
              roleId: toolInput.roleId,
              timeZone: toolInput.timeZone,
              isActive: toolInput.isActive,
            });

            if (result.success && result.userId) {
              const instanceUrl = await this.salesforceService.getInstanceUrl(userId);
              const userUrl = this.salesforceService.buildLightningUrl(instanceUrl, 'User', result.userId);

              const facts: UserManagementFacts = {
                action_completed: true,
                user_id: result.userId,
                username: toolInput.username,
                operation: 'create',
                email_sent: true, // Salesforce sends welcome email by default
                email_recipient: toolInput.email,
                new_state: toolInput.isActive !== false ? 'active' : 'inactive',
              };

              const verified_response = `Salesforce user created successfully.
- User ID: ${facts.user_id}
- Username: ${facts.username}
- Name: ${toolInput.firstName} ${toolInput.lastName}
- Email: ${facts.email_recipient}
- Status: ${facts.new_state}
- Welcome email: Sent to ${facts.email_recipient}

**User URL:** ${userUrl}`;

              return createCriticalResult(
                true,
                facts,
                verified_response,
                { userId: result.userId, url: userUrl },
              );
            }

            const facts: UserManagementFacts = {
              action_completed: false,
              username: toolInput.username,
              operation: 'create',
              email_sent: false,
            };
            return createCriticalResult(
              false,
              facts,
              `Failed to create Salesforce user: ${result.error}`,
              undefined,
              result.error,
            );
          } catch (error) {
            const facts: UserManagementFacts = {
              action_completed: false,
              username: toolInput.username,
              operation: 'create',
              email_sent: false,
            };
            return createCriticalResult(
              false,
              facts,
              `Failed to create user: ${error.message}`,
              undefined,
              error.message,
            );
          }
        }

        case 'sf_update_user': {
          try {
            const result = await this.salesforceService.updateUser(userId, toolInput.targetUserId, {
              email: toolInput.email,
              firstName: toolInput.firstName,
              lastName: toolInput.lastName,
              profileId: toolInput.profileId,
              roleId: toolInput.roleId,
              isActive: toolInput.isActive,
              managerId: toolInput.managerId,
              title: toolInput.title,
              department: toolInput.department,
            });
            if (result.success) {
              return { success: true, message: 'User updated successfully' };
            }
            return { success: false, error: result.error };
          } catch (error) {
            return { success: false, error: `Failed to update user: ${error.message}` };
          }
        }

        case 'sf_freeze_user': {
          try {
            const result = await this.salesforceService.freezeUser(userId, toolInput.targetUserId, toolInput.freeze);

            const facts: UserManagementFacts = {
              action_completed: result.success,
              user_id: toolInput.targetUserId,
              operation: toolInput.freeze ? 'freeze' : 'unfreeze',
              email_sent: false, // Freeze/unfreeze doesn't send emails
              previous_state: toolInput.freeze ? 'active' : 'frozen',
              new_state: toolInput.freeze ? 'frozen' : 'active',
            };

            if (result.success) {
              const verified_response = `Salesforce user ${toolInput.freeze ? 'frozen' : 'unfrozen'} successfully.
- User ID: ${facts.user_id}
- Previous state: ${facts.previous_state}
- New state: ${facts.new_state}
- The user ${toolInput.freeze ? 'can no longer log in' : 'can now log in again'}`;

              return createCriticalResult(
                true,
                facts,
                verified_response,
                { userId: toolInput.targetUserId, frozen: toolInput.freeze },
              );
            }

            return createCriticalResult(
              false,
              facts,
              `Failed to ${toolInput.freeze ? 'freeze' : 'unfreeze'} user: ${result.error}`,
              undefined,
              result.error,
            );
          } catch (error) {
            const facts: UserManagementFacts = {
              action_completed: false,
              user_id: toolInput.targetUserId,
              operation: toolInput.freeze ? 'freeze' : 'unfreeze',
              email_sent: false,
            };
            return createCriticalResult(
              false,
              facts,
              `Failed to ${toolInput.freeze ? 'freeze' : 'unfreeze'} user: ${error.message}`,
              undefined,
              error.message,
            );
          }
        }

        case 'sf_reset_user_password': {
          try {
            const result = await this.salesforceService.resetUserPassword(userId, toolInput.targetUserId);

            const facts: UserManagementFacts = {
              action_completed: result.success,
              user_id: toolInput.targetUserId,
              operation: 'reset_password',
              email_sent: result.success, // Password reset sends email on success
            };

            if (result.success) {
              const verified_response = `Password reset initiated successfully.
- User ID: ${facts.user_id}
- Password reset email: SENT to the user's registered email address
- The user must check their email and follow the link to set a new password`;

              return createCriticalResult(
                true,
                facts,
                verified_response,
                { userId: toolInput.targetUserId },
              );
            }

            return createCriticalResult(
              false,
              facts,
              `Failed to reset password: ${result.error}`,
              undefined,
              result.error,
            );
          } catch (error) {
            const facts: UserManagementFacts = {
              action_completed: false,
              user_id: toolInput.targetUserId,
              operation: 'reset_password',
              email_sent: false,
            };
            return createCriticalResult(
              false,
              facts,
              `Failed to reset password: ${error.message}`,
              undefined,
              error.message,
            );
          }
        }

        case 'sf_create_record_type': {
          try {
            const result = await this.salesforceService.createRecordType(userId, toolInput.objectName, {
              name: toolInput.name,
              developerName: toolInput.developerName,
              description: toolInput.description,
              isActive: toolInput.isActive,
            });
            if (result.success) {
              return {
                success: true,
                message: `Record type '${toolInput.name}' created on ${toolInput.objectName}`,
                data: { recordTypeId: result.recordTypeId },
                nextSteps: ['Assign to profiles', 'Configure page layouts', 'Set up business processes'],
              };
            }
            return { success: false, error: result.error, suggestions: result.suggestions };
          } catch (error) {
            return { success: false, error: `Failed to create record type: ${error.message}` };
          }
        }

        case 'sf_update_record_type': {
          try {
            const result = await this.salesforceService.updateRecordType(userId, toolInput.recordTypeId, {
              name: toolInput.name,
              description: toolInput.description,
              isActive: toolInput.isActive,
            });
            if (result.success) {
              return { success: true, message: 'Record type updated successfully' };
            }
            return { success: false, error: result.error };
          } catch (error) {
            return { success: false, error: `Failed to update record type: ${error.message}` };
          }
        }

        case 'sf_create_permission_set': {
          try {
            const result = await this.salesforceService.createPermissionSet(userId, {
              name: toolInput.name,
              label: toolInput.label,
              description: toolInput.description,
            });
            if (result.success) {
              return {
                success: true,
                message: `Permission set '${toolInput.label}' created`,
                data: { permissionSetId: result.permissionSetId },
                nextSteps: ['Add object permissions', 'Add field permissions', 'Assign to users'],
              };
            }
            return { success: false, error: result.error, suggestions: result.suggestions };
          } catch (error) {
            return { success: false, error: `Failed to create permission set: ${error.message}` };
          }
        }

        case 'sf_add_object_permission_to_permset': {
          try {
            const result = await this.salesforceService.addObjectPermissionToPermSet(
              userId,
              toolInput.permissionSetId,
              toolInput.objectName,
              {
                read: toolInput.read,
                create: toolInput.create,
                edit: toolInput.edit,
                delete: toolInput.delete,
                viewAll: toolInput.viewAll,
                modifyAll: toolInput.modifyAll,
              }
            );
            if (result.success) {
              return { success: true, message: `Object permissions for ${toolInput.objectName} added to permission set` };
            }
            return { success: false, error: result.error };
          } catch (error) {
            return { success: false, error: `Failed to add object permission: ${error.message}` };
          }
        }

        case 'sf_revoke_permission_set': {
          try {
            const result = await this.salesforceService.revokePermissionSet(userId, toolInput.assigneeId, toolInput.permissionSetId);
            if (result.success) {
              return { success: true, message: 'Permission set revoked from user' };
            }
            return { success: false, error: result.error };
          } catch (error) {
            return { success: false, error: `Failed to revoke permission set: ${error.message}` };
          }
        }

        case 'sf_update_custom_field': {
          try {
            const result = await this.salesforceService.updateCustomField(userId, toolInput.objectName, toolInput.fieldName, {
              label: toolInput.label,
              description: toolInput.description,
              helpText: toolInput.helpText,
              required: toolInput.required,
              defaultValue: toolInput.defaultValue,
            });
            if (result.success) {
              return { success: true, message: `Field ${toolInput.fieldName} updated on ${toolInput.objectName}` };
            }
            return { success: false, error: result.error, suggestions: result.suggestions };
          } catch (error) {
            return { success: false, error: `Failed to update field: ${error.message}` };
          }
        }

        case 'sf_delete_custom_field': {
          try {
            const result = await this.salesforceService.deleteCustomField(userId, toolInput.objectName, toolInput.fieldName);
            if (result.success) {
              return { success: true, message: `Field ${toolInput.fieldName} deleted from ${toolInput.objectName}` };
            }
            return { success: false, error: result.error, suggestions: result.suggestions };
          } catch (error) {
            return { success: false, error: `Failed to delete field: ${error.message}` };
          }
        }

        case 'sf_delete_custom_object': {
          try {
            const result = await this.salesforceService.deleteCustomObject(userId, toolInput.objectName);
            if (result.success) {
              return { success: true, message: `Object ${toolInput.objectName} deleted` };
            }
            return { success: false, error: result.error, suggestions: result.suggestions };
          } catch (error) {
            return { success: false, error: `Failed to delete object: ${error.message}` };
          }
        }

        case 'sf_update_validation_rule': {
          try {
            const result = await this.salesforceService.updateValidationRule(userId, toolInput.validationRuleId, {
              description: toolInput.description,
              errorConditionFormula: toolInput.errorConditionFormula,
              errorMessage: toolInput.errorMessage,
              errorDisplayField: toolInput.errorDisplayField,
              active: toolInput.active,
            });
            if (result.success) {
              return { success: true, message: 'Validation rule updated successfully' };
            }
            return { success: false, error: result.error, suggestions: result.suggestions };
          } catch (error) {
            return { success: false, error: `Failed to update validation rule: ${error.message}` };
          }
        }

        case 'sf_delete_validation_rule': {
          try {
            const result = await this.salesforceService.deleteValidationRule(userId, toolInput.validationRuleId);
            if (result.success) {
              return { success: true, message: 'Validation rule deleted' };
            }
            return { success: false, error: result.error };
          } catch (error) {
            return { success: false, error: `Failed to delete validation rule: ${error.message}` };
          }
        }

        case 'sf_list_roles': {
          try {
            const result = await this.salesforceService.listRoles(userId);
            return {
              success: true,
              message: `Found ${result.totalSize} role(s)`,
              data: result.records?.map((r: any) => ({
                id: r.Id,
                name: r.Name,
                developerName: r.DeveloperName,
                parentRoleId: r.ParentRoleId,
              })),
            };
          } catch (error) {
            return { success: false, error: `Failed to list roles: ${error.message}` };
          }
        }

        case 'sf_create_role': {
          try {
            const result = await this.salesforceService.createRole(userId, {
              name: toolInput.name,
              developerName: toolInput.developerName,
              parentRoleId: toolInput.parentRoleId,
            });
            if (result.success) {
              return {
                success: true,
                message: `Role '${toolInput.name}' created`,
                data: { roleId: result.roleId },
              };
            }
            return { success: false, error: result.error };
          } catch (error) {
            return { success: false, error: `Failed to create role: ${error.message}` };
          }
        }

        case 'sf_list_groups': {
          try {
            const result = await this.salesforceService.listGroups(userId);
            return {
              success: true,
              message: `Found ${result.totalSize} group(s)`,
              data: result.records?.map((g: any) => ({
                id: g.Id,
                name: g.Name,
                developerName: g.DeveloperName,
                type: g.Type,
              })),
            };
          } catch (error) {
            return { success: false, error: `Failed to list groups: ${error.message}` };
          }
        }

        case 'sf_create_group': {
          try {
            const result = await this.salesforceService.createGroup(userId, {
              name: toolInput.name,
              developerName: toolInput.developerName,
              type: toolInput.type,
            });
            if (result.success) {
              return {
                success: true,
                message: `Group '${toolInput.name}' created`,
                data: { groupId: result.groupId },
              };
            }
            return { success: false, error: result.error };
          } catch (error) {
            return { success: false, error: `Failed to create group: ${error.message}` };
          }
        }

        case 'sf_add_group_member': {
          try {
            const result = await this.salesforceService.addGroupMember(userId, toolInput.groupId, toolInput.memberId);
            if (result.success) {
              return { success: true, message: 'Member added to group' };
            }
            return { success: false, error: result.error };
          } catch (error) {
            return { success: false, error: `Failed to add group member: ${error.message}` };
          }
        }

        case 'sf_create_queue': {
          try {
            const result = await this.salesforceService.createQueue(userId, {
              name: toolInput.name,
              developerName: toolInput.developerName,
              supportedObjects: toolInput.supportedObjects,
              email: toolInput.email,
            });
            if (result.success) {
              return {
                success: true,
                message: `Queue '${toolInput.name}' created for ${toolInput.supportedObjects.join(', ')}`,
                data: { queueId: result.queueId },
                nextSteps: ['Add members to the queue', 'Set up assignment rules'],
              };
            }
            return { success: false, error: result.error };
          } catch (error) {
            return { success: false, error: `Failed to create queue: ${error.message}` };
          }
        }

        case 'sf_list_email_templates': {
          try {
            const result = await this.salesforceService.listEmailTemplates(userId, toolInput.folderId);
            return {
              success: true,
              message: `Found ${result.totalSize} email template(s)`,
              data: result.records?.map((t: any) => ({
                id: t.Id,
                name: t.Name,
                developerName: t.DeveloperName,
                subject: t.Subject,
                type: t.TemplateType,
                isActive: t.IsActive,
              })),
            };
          } catch (error) {
            return { success: false, error: `Failed to list email templates: ${error.message}` };
          }
        }

        case 'sf_create_email_template': {
          try {
            const result = await this.salesforceService.createEmailTemplate(userId, {
              name: toolInput.name,
              developerName: toolInput.developerName,
              subject: toolInput.subject,
              htmlBody: toolInput.htmlBody,
              textBody: toolInput.textBody,
              description: toolInput.description,
            });
            if (result.success) {
              return {
                success: true,
                message: `Email template '${toolInput.name}' created`,
                data: { templateId: result.templateId },
              };
            }
            return { success: false, error: result.error };
          } catch (error) {
            return { success: false, error: `Failed to create email template: ${error.message}` };
          }
        }

        case 'sf_get_schema_overview': {
          try {
            const result = await this.salesforceService.getSchemaOverview(userId, toolInput.objectName);
            return {
              success: true,
              message: `Schema overview for ${result.objectName} (${result.label})`,
              data: result,
            };
          } catch (error) {
            return { success: false, error: `Failed to get schema overview: ${error.message}` };
          }
        }

        case 'sf_get_picklist_values': {
          try {
            const result = await this.salesforceService.getPicklistValues(userId, toolInput.objectName, toolInput.fieldName);
            return {
              success: true,
              message: `Found ${result.values.length} picklist value(s) for ${toolInput.fieldName}`,
              data: result,
            };
          } catch (error) {
            return { success: false, error: `Failed to get picklist values: ${error.message}` };
          }
        }

        case 'sf_bulk_create': {
          try {
            const result = await this.salesforceService.bulkCreate(
              userId,
              toolInput.objectType,
              toolInput.records,
              toolInput.allOrNone
            );

            const successResults = result.results.filter(r => r.success);
            const failedResults = result.results.filter(r => !r.success);
            const successCount = successResults.length;
            const failedCount = failedResults.length;
            const totalRequested = toolInput.records.length;

            // Extract IDs and error details
            const successIds = successResults.map(r => r.id).filter((id): id is string => !!id);
            const failedIds = failedResults.map((r, idx) => {
              // Try to identify the failed record - Salesforce bulk API returns results in order
              const recordIndex = result.results.indexOf(r);
              return toolInput.records[recordIndex]?.Id || `record_${recordIndex}`;
            });
            const errorDetails: Record<string, string> = {};
            failedResults.forEach((r, idx) => {
              const recordIndex = result.results.indexOf(r);
              const recordId = toolInput.records[recordIndex]?.Id || `record_${recordIndex}`;
              errorDetails[recordId] = r.errors?.map(e => typeof e === 'string' ? e : ((e as any).message || String(e))).join('; ') || 'Unknown error';
            });

            const facts: BulkOperationFacts = {
              action_completed: successCount > 0,
              operation_type: 'create',
              total_requested: totalRequested,
              successful_count: successCount,
              failed_count: failedCount,
              successful_ids: successIds,
              failed_ids: failedIds,
              error_details: failedCount > 0 ? errorDetails : undefined,
            };

            // Build verified response
            let verified_response: string;
            if (failedCount === 0) {
              verified_response = `Bulk create completed successfully.
All ${totalRequested} ${toolInput.objectType} record(s) created successfully.
Created IDs: ${successIds.join(', ')}`;
            } else if (successCount === 0) {
              verified_response = `Bulk create failed completely.
0 of ${totalRequested} ${toolInput.objectType} record(s) created.
All records failed:
${Object.entries(errorDetails).map(([id, reason]) => `  - ${id}: ${reason}`).join('\n')}`;
            } else {
              verified_response = `Bulk create completed with partial success.
${successCount} of ${totalRequested} ${toolInput.objectType} record(s) created successfully.
${failedCount} record(s) failed:
${Object.entries(errorDetails).map(([id, reason]) => `  - ${id}: ${reason}`).join('\n')}
Successfully created IDs: ${successIds.join(', ')}
No rollback was performed${toolInput.allOrNone ? ' (allOrNone was requested but some succeeded before failures)' : ''}.`;
            }

            return createCriticalResult(
              result.success || successCount > 0,
              facts,
              verified_response,
              { results: result.results, successIds, failedIds },
              failedCount > 0 ? `${failedCount} record(s) failed to create` : undefined,
            );
          } catch (error) {
            const facts: BulkOperationFacts = {
              action_completed: false,
              operation_type: 'create',
              total_requested: toolInput.records?.length || 0,
              successful_count: 0,
              failed_count: toolInput.records?.length || 0,
              successful_ids: [],
              failed_ids: [],
            };
            return createCriticalResult(
              false,
              facts,
              `Bulk create failed: ${error.message}\nNo ${toolInput.objectType} records were created.`,
              undefined,
              error.message,
            );
          }
        }

        case 'sf_bulk_update': {
          try {
            const result = await this.salesforceService.bulkUpdate(
              userId,
              toolInput.objectType,
              toolInput.records,
              toolInput.allOrNone
            );

            const successResults = result.results.filter(r => r.success);
            const failedResults = result.results.filter(r => !r.success);
            const successCount = successResults.length;
            const failedCount = failedResults.length;
            const totalRequested = toolInput.records.length;

            // Extract IDs - for updates, the ID is in the input records
            const successIds = toolInput.records
              .filter((_, idx) => result.results[idx]?.success)
              .map(r => r.Id || r.id)
              .filter(Boolean);
            const failedIds = toolInput.records
              .filter((_, idx) => !result.results[idx]?.success)
              .map(r => r.Id || r.id)
              .filter(Boolean);
            const errorDetails: Record<string, string> = {};
            failedResults.forEach((r, idx) => {
              const recordIndex = result.results.indexOf(r);
              const recordId = toolInput.records[recordIndex]?.Id || toolInput.records[recordIndex]?.id || `record_${recordIndex}`;
              errorDetails[recordId] = r.errors?.map(e => typeof e === 'string' ? e : ((e as any).message || String(e))).join('; ') || 'Unknown error';
            });

            const facts: BulkOperationFacts = {
              action_completed: successCount > 0,
              operation_type: 'update',
              total_requested: totalRequested,
              successful_count: successCount,
              failed_count: failedCount,
              successful_ids: successIds,
              failed_ids: failedIds,
              error_details: failedCount > 0 ? errorDetails : undefined,
            };

            // Build verified response
            let verified_response: string;
            if (failedCount === 0) {
              verified_response = `Bulk update completed successfully.
All ${totalRequested} ${toolInput.objectType} record(s) updated successfully.
Updated IDs: ${successIds.join(', ')}`;
            } else if (successCount === 0) {
              verified_response = `Bulk update failed completely.
0 of ${totalRequested} ${toolInput.objectType} record(s) updated.
All records failed:
${Object.entries(errorDetails).map(([id, reason]) => `  - ${id}: ${reason}`).join('\n')}
No changes were made to any records.`;
            } else {
              verified_response = `Bulk update completed with partial success.
${successCount} of ${totalRequested} ${toolInput.objectType} record(s) updated successfully.
${failedCount} record(s) failed:
${Object.entries(errorDetails).map(([id, reason]) => `  - ${id}: ${reason}`).join('\n')}
Successfully updated IDs: ${successIds.join(', ')}
Failed IDs remain unchanged: ${failedIds.join(', ')}
No rollback was performed for successful updates.`;
            }

            return createCriticalResult(
              result.success || successCount > 0,
              facts,
              verified_response,
              { results: result.results, successIds, failedIds },
              failedCount > 0 ? `${failedCount} record(s) failed to update` : undefined,
            );
          } catch (error) {
            const facts: BulkOperationFacts = {
              action_completed: false,
              operation_type: 'update',
              total_requested: toolInput.records?.length || 0,
              successful_count: 0,
              failed_count: toolInput.records?.length || 0,
              successful_ids: [],
              failed_ids: toolInput.records?.map(r => r.Id || r.id).filter(Boolean) || [],
            };
            return createCriticalResult(
              false,
              facts,
              `Bulk update failed: ${error.message}\nNo ${toolInput.objectType} records were modified.`,
              undefined,
              error.message,
            );
          }
        }

        case 'sf_bulk_delete': {
          try {
            const result = await this.salesforceService.bulkDelete(userId, toolInput.recordIds, toolInput.allOrNone);

            const successResults = result.results.filter(r => r.success);
            const failedResults = result.results.filter(r => !r.success);
            const successCount = successResults.length;
            const failedCount = failedResults.length;
            const totalRequested = toolInput.recordIds.length;

            // Extract IDs for successful and failed deletions
            const successIds = toolInput.recordIds.filter((_, idx) => result.results[idx]?.success);
            const failedIds = toolInput.recordIds.filter((_, idx) => !result.results[idx]?.success);
            const errorDetails: Record<string, string> = {};
            failedResults.forEach((r, idx) => {
              const recordIndex = result.results.indexOf(r);
              const recordId = toolInput.recordIds[recordIndex] || `record_${recordIndex}`;
              errorDetails[recordId] = r.errors?.map(e => typeof e === 'string' ? e : ((e as any).message || String(e))).join('; ') || 'Unknown error';
            });

            const facts: BulkOperationFacts = {
              action_completed: successCount > 0,
              operation_type: 'delete',
              total_requested: totalRequested,
              successful_count: successCount,
              failed_count: failedCount,
              successful_ids: successIds,
              failed_ids: failedIds,
              error_details: failedCount > 0 ? errorDetails : undefined,
            };

            // Build verified response
            let verified_response: string;
            if (failedCount === 0) {
              verified_response = `Bulk delete completed successfully.
All ${totalRequested} record(s) deleted permanently.
Deleted IDs: ${successIds.join(', ')}
WARNING: These records cannot be recovered.`;
            } else if (successCount === 0) {
              verified_response = `Bulk delete failed completely.
0 of ${totalRequested} record(s) deleted.
All records failed:
${Object.entries(errorDetails).map(([id, reason]) => `  - ${id}: ${reason}`).join('\n')}
No records were deleted.`;
            } else {
              verified_response = `Bulk delete completed with partial success.
${successCount} of ${totalRequested} record(s) deleted permanently.
${failedCount} record(s) failed to delete:
${Object.entries(errorDetails).map(([id, reason]) => `  - ${id}: ${reason}`).join('\n')}
Deleted IDs (cannot be recovered): ${successIds.join(', ')}
Failed IDs (still exist): ${failedIds.join(', ')}
No rollback was performed - successfully deleted records are permanently removed.`;
            }

            return createCriticalResult(
              result.success || successCount > 0,
              facts,
              verified_response,
              { results: result.results, successIds, failedIds },
              failedCount > 0 ? `${failedCount} record(s) failed to delete` : undefined,
            );
          } catch (error) {
            const facts: BulkOperationFacts = {
              action_completed: false,
              operation_type: 'delete',
              total_requested: toolInput.recordIds?.length || 0,
              successful_count: 0,
              failed_count: toolInput.recordIds?.length || 0,
              successful_ids: [],
              failed_ids: toolInput.recordIds || [],
            };
            return createCriticalResult(
              false,
              facts,
              `Bulk delete failed: ${error.message}\nNo records were deleted.`,
              undefined,
              error.message,
            );
          }
        }

        case 'sf_get_record_count': {
          try {
            const count = await this.salesforceService.getRecordCount(userId, toolInput.objectName, toolInput.whereClause);
            return {
              success: true,
              message: `${toolInput.objectName} has ${count.toLocaleString()} record(s)${toolInput.whereClause ? ' matching criteria' : ''}`,
              data: { count, objectName: toolInput.objectName },
            };
          } catch (error) {
            return { success: false, error: `Failed to get record count: ${error.message}` };
          }
        }

        case 'sf_clone_record': {
          try {
            const result = await this.salesforceService.cloneRecord(
              userId,
              toolInput.objectType,
              toolInput.recordId,
              toolInput.fieldOverrides,
              toolInput.excludeFields
            );
            if (result.success) {
              return {
                success: true,
                message: `${toolInput.objectType} record cloned successfully`,
                data: { originalId: toolInput.recordId, newRecordId: result.newRecordId },
              };
            }
            return { success: false, error: result.error };
          } catch (error) {
            return { success: false, error: `Failed to clone record: ${error.message}` };
          }
        }

        case 'sf_get_org_info': {
          try {
            const result = await this.salesforceService.getOrgInfo(userId);
            return {
              success: true,
              message: `Connected to ${result.name} (${result.organizationType})`,
              data: result,
            };
          } catch (error) {
            return { success: false, error: `Failed to get org info: ${error.message}` };
          }
        }

        // =============================================================================
        // ANALYTICS TOOLS
        // =============================================================================
        case 'compute_analytics': {
          try {
            const { metricType, data, startDateField, endDateField, groupByField, valueField, statusField, targetStatus, convertedValues } = toolInput;

            if (!data || !Array.isArray(data) || data.length === 0) {
              return {
                success: false,
                error: 'No data provided. First query the data using sf_query, then pass the records array to compute_analytics.',
              };
            }

            const result = await this.analyticsService.computeMetric(metricType, data, {
              startDateField,
              endDateField,
              groupByField,
              valueField,
              statusField,
              targetStatus,
              convertedValues,
            });

            return {
              success: result.success,
              message: result.insights?.join(' | ') || `Computed ${metricType} metric`,
              data: {
                metric: result.metric,
                result: result.result,
                breakdown: result.breakdown,
                insights: result.insights,
              },
            };
          } catch (error) {
            return { success: false, error: `Analytics computation failed: ${error.message}` };
          }
        }

        // =============================================================================
        // IRIS RANK TOOLS - AI-Powered Entity Ranking
        // =============================================================================
        case 'iris_rank_entities': {
          try {
            const { entityType, query, limit = 10 } = toolInput;

            // Query entities from Salesforce
            const soql = this.buildRankQuerySOQL(entityType);
            const sfResult = await this.salesforceService.query(userId, soql);

            if (!sfResult?.records?.length) {
              const emptyFacts = {
                action_completed: true,
                entities_found: 0,
                entity_type: entityType,
                ranking_computed: false,
              };
              return createMediumRiskResult(
                true,
                emptyFacts,
                `No ${entityType} records found in Salesforce to rank.`,
                { records: [] }
              );
            }

            // Convert to CRMEntity format and compute rankings
            const entities = await this.convertToCRMEntities(userId, sfResult.records, entityType);
            const ranked = await this.irisRank.getRankedEntities(userId, entities, { query }, limit);

            // Map back to Salesforce records with rank info (FLATTENED for table display)
            const rankedRecords = ranked.map((r, index) => {
              const original = sfResult.records.find((rec: any) => rec.Id === r.entityId);

              // Flatten IRISRank data to top level for table visibility
              return {
                // Priority rank (1, 2, 3...)
                '#': index + 1,
                // Key Salesforce fields first
                Name: original?.Name || r.entityName,
                Company: original?.Company || original?.Account?.Name || 'â€”',
                Status: original?.Status || original?.StageName || 'â€”',
                Rating: original?.Rating || 'â€”',
                // IRISRank scores (flattened, not nested)
                'IRISRank': Math.round(r.rank * 100) / 100,
                'Momentum': r.momentum?.momentumScore ? Math.round(r.momentum.momentumScore * 100) / 100 : 0.50,
                'Velocity': r.momentum?.velocity ? `${r.momentum.velocity > 0 ? '+' : ''}${Math.round(r.momentum.velocity * 100)}%` : '0%',
                'Trend': r.momentum?.trend || 'unknown',
                'Network': Math.round(r.networkScore * 100) / 100,
                'Activity': Math.round(r.activityScore * 100) / 100,
                // Days since last activity
                'Last Activity': r.momentum?.daysSinceLastActivity !== undefined
                  ? (r.momentum.daysSinceLastActivity > 900 ? 'Never' : `${r.momentum.daysSinceLastActivity}d ago`)
                  : 'â€”',
                // Key insight
                'Insight': r.explanation?.[0] || 'â€”',
                // Keep original ID for linking
                Id: original?.Id || r.entityId,
              };
            });

            // Build grounded facts
            const rankFacts = {
              action_completed: true,
              entities_found: sfResult.records.length,
              entities_ranked: ranked.length,
              entity_type: entityType,
              ranking_computed: true,
              top_entity_name: rankedRecords[0]?.Name || 'Unknown',
              top_entity_score: rankedRecords[0]?.['IRISRank'] || 0,
              query_filter: query || null,
            };

            // Build verified response with actual data
            const hotLeads = rankedRecords.filter((r: any) => r['IRISRank'] >= 0.7);
            const warmLeads = rankedRecords.filter((r: any) => r['IRISRank'] >= 0.4 && r['IRISRank'] < 0.7);

            let verified_response = `## IRIS Rank Results: Top ${ranked.length} ${entityType}s\n\n`;
            verified_response += `**Total ${entityType}s Analyzed:** ${sfResult.records.length}\n`;
            verified_response += `**Hot (Score â‰¥0.7):** ${hotLeads.length} | **Warm (Score 0.4-0.7):** ${warmLeads.length}\n\n`;

            if (rankedRecords.length > 0) {
              verified_response += `### Top Ranked:\n`;
              rankedRecords.slice(0, 5).forEach((r: any, i: number) => {
                const heatIcon = r['IRISRank'] >= 0.7 ? 'ðŸ”¥' : r['IRISRank'] >= 0.4 ? 'ðŸŒ¡ï¸' : 'â„ï¸';
                verified_response += `${i + 1}. ${heatIcon} **${r.Name}** (${r.Company}) - Score: ${r['IRISRank']}, Trend: ${r['Trend']}\n`;
              });
            }

            return createMediumRiskResult(
              true,
              rankFacts,
              verified_response,
              { records: rankedRecords }
            );
          } catch (error) {
            this.logger.error(`IRISRank failed: ${error.message}`);
            const errorFacts = {
              action_completed: false,
              entities_found: 0,
              entity_type: toolInput.entityType,
              ranking_computed: false,
            };
            return createMediumRiskResult(
              false,
              errorFacts,
              `IRISRank computation failed: ${error.message}`,
              undefined,
              error.message
            );
          }
        }

        case 'iris_get_at_risk': {
          try {
            const { entityType, limit = 5 } = toolInput;

            // Query all entities (or filter by type)
            const types = entityType ? [entityType] : ['Lead', 'Contact', 'Account', 'Opportunity'];
            const allEntities: CRMEntity[] = [];
            const allRecords: any[] = []; // Keep original SF records for display

            for (const type of types) {
              const soql = this.buildRankQuerySOQL(type as any);
              const sfResult = await this.salesforceService.query(userId, soql);
              if (sfResult?.records?.length) {
                const entities = await this.convertToCRMEntities(userId, sfResult.records, type as any);
                allEntities.push(...entities);
                allRecords.push(...sfResult.records.map((r: any) => ({ ...r, _type: type })));
              }
            }

            if (!allEntities.length) {
              return { success: true, message: 'No entities found', data: [] };
            }

            const atRisk = await this.irisRank.getAtRiskEntities(userId, allEntities, limit);

            // Flatten results for table display
            const rankedRecords = atRisk.map((r, index) => {
              const original = allRecords.find((rec: any) => rec.Id === r.entityId);
              return {
                '#': index + 1,
                Name: original?.Name || r.entityName,
                Type: original?._type || r.entityType,
                Company: original?.Company || original?.Account?.Name || 'â€”',
                Status: original?.Status || original?.StageName || 'â€”',
                'Risk Level': r.momentum?.trend === 'churning' ? 'ðŸš¨ Critical' :
                              r.momentum?.trend === 'at_risk' ? 'âš ï¸ High' : 'ðŸ“‰ Medium',
                'Velocity': r.momentum?.velocity ? `${Math.round(r.momentum.velocity * 100)}%` : '0%',
                'Days Inactive': r.momentum?.daysSinceLastActivity !== undefined
                  ? (r.momentum.daysSinceLastActivity > 900 ? 'Never' : `${r.momentum.daysSinceLastActivity}`)
                  : 'â€”',
                'IRISRank': Math.round(r.rank * 100) / 100,
                'Insight': r.explanation?.[0] || 'â€”',
                Id: original?.Id || r.entityId,
              };
            });

            return {
              success: true,
              message: `Found ${atRisk.length} entities needing attention`,
              data: { records: rankedRecords },
            };
          } catch (error) {
            return { success: false, error: `At-risk analysis failed: ${error.message}` };
          }
        }

        case 'iris_get_momentum': {
          try {
            const { entityType, limit = 5 } = toolInput;

            // Query all entities (or filter by type)
            const types = entityType ? [entityType] : ['Lead', 'Contact', 'Account', 'Opportunity'];
            const allEntities: CRMEntity[] = [];
            const allRecords: any[] = []; // Keep original SF records for display

            for (const type of types) {
              const soql = this.buildRankQuerySOQL(type as any);
              const sfResult = await this.salesforceService.query(userId, soql);
              if (sfResult?.records?.length) {
                const entities = await this.convertToCRMEntities(userId, sfResult.records, type as any);
                allEntities.push(...entities);
                allRecords.push(...sfResult.records.map((r: any) => ({ ...r, _type: type })));
              }
            }

            if (!allEntities.length) {
              return { success: true, message: 'No entities found', data: [] };
            }

            const hotEntities = await this.irisRank.getMomentumEntities(userId, allEntities, limit);

            // Flatten results for table display
            const rankedRecords = hotEntities.map((r, index) => {
              const original = allRecords.find((rec: any) => rec.Id === r.entityId);
              return {
                '#': index + 1,
                Name: original?.Name || r.entityName,
                Type: original?._type || r.entityType,
                Company: original?.Company || original?.Account?.Name || 'â€”',
                Status: original?.Status || original?.StageName || 'â€”',
                'Heat': r.momentum?.trend === 'accelerating' ? 'ðŸ”¥ Hot' :
                        r.momentum?.trend === 'steady' ? 'ðŸ“ˆ Warm' : 'âž¡ï¸ Active',
                'Velocity': r.momentum?.velocity ? `+${Math.round(r.momentum.velocity * 100)}%` : '+0%',
                'Momentum': r.momentum?.momentumScore ? Math.round(r.momentum.momentumScore * 100) / 100 : 0.50,
                'IRISRank': Math.round(r.rank * 100) / 100,
                'Insight': r.explanation?.[0] || 'â€”',
                Id: original?.Id || r.entityId,
              };
            });

            return {
              success: true,
              message: `Found ${hotEntities.length} entities with strong momentum`,
              data: { records: rankedRecords },
            };
          } catch (error) {
            return { success: false, error: `Momentum analysis failed: ${error.message}` };
          }
        }

        case 'iris_explain_rank': {
          try {
            const { entityId, entityType } = toolInput;

            // Query the specific entity
            const soql = `SELECT Id, Name, CreatedDate, LastModifiedDate, LastActivityDate FROM ${entityType} WHERE Id = '${entityId}'`;
            const sfResult = await this.salesforceService.query(userId, soql);

            if (!sfResult?.records?.length) {
              const notFoundFacts = {
                action_completed: false,
                entity_found: false,
                entity_id: entityId,
                entity_type: entityType,
              };
              return createMediumRiskResult(
                false,
                notFoundFacts,
                `${entityType} with ID ${entityId} not found. Cannot explain ranking.`,
                undefined,
                `${entityType} not found`
              );
            }

            const entities = await this.convertToCRMEntities(userId, sfResult.records, entityType);
            const ranked = await this.irisRank.getRankedEntities(userId, entities, {}, 1);

            if (!ranked.length) {
              const noRankFacts = {
                action_completed: false,
                entity_found: true,
                entity_id: entityId,
                entity_type: entityType,
                entity_name: sfResult.records[0].Name,
              };
              return createMediumRiskResult(
                false,
                noRankFacts,
                `Could not compute rank for ${sfResult.records[0].Name}. Insufficient data for ranking.`,
                undefined,
                'Could not compute rank'
              );
            }

            const r = ranked[0];
            const entityName = sfResult.records[0].Name;
            const overallRank = Math.round(r.rank * 100) / 100;
            const networkScore = Math.round(r.networkScore * 100) / 100;
            const activityScore = Math.round(r.activityScore * 100) / 100;
            const relevanceScore = Math.round(r.relevanceScore * 100) / 100;

            // Build grounded facts
            const rankFacts = {
              action_completed: true,
              entity_found: true,
              entity_id: entityId,
              entity_type: entityType,
              entity_name: entityName,
              overall_rank: overallRank,
              network_score: networkScore,
              activity_score: activityScore,
              relevance_score: relevanceScore,
              explanation: r.explanation || 'No specific explanation available',
              ranking_weights: {
                network: '40%',
                activity: '30%',
                relevance: '30%',
              },
            };

            // Build verified response that AI MUST use
            const verified_response = `## Why "${entityName}" is ranked ${overallRank >= 0.7 ? 'HIGH' : overallRank >= 0.4 ? 'MEDIUM' : 'LOW'} (Score: ${overallRank})

**Ranking Breakdown:**
- **Network Score:** ${networkScore} (40% weight) - Measures connections and relationships
- **Activity Score:** ${activityScore} (30% weight) - Measures recent engagement and interactions
- **Relevance Score:** ${relevanceScore} (30% weight) - Measures fit with ideal customer profile

**Analysis:** ${r.explanation || 'This entity was ranked based on the combination of network connections, recent activity patterns, and relevance to your business criteria.'}

${overallRank >= 0.7 ? 'ðŸ”¥ **Hot Lead Indicators:** High scores across multiple factors suggest strong engagement potential.' : ''}
${overallRank < 0.4 ? 'âš ï¸ **Improvement Needed:** Consider increasing engagement or qualifying this lead further.' : ''}`;

            return createMediumRiskResult(
              true,
              rankFacts,
              verified_response,
              {
                entityId: r.entityId,
                entityType,
                name: entityName,
                overallRank,
                scores: { network: networkScore, activity: activityScore, relevance: relevanceScore },
                explanation: r.explanation,
              }
            );
          } catch (error) {
            const errorFacts = {
              action_completed: false,
              entity_found: false,
              entity_id: toolInput.entityId,
              entity_type: toolInput.entityType,
            };
            return createMediumRiskResult(
              false,
              errorFacts,
              `Rank explanation failed: ${error.message}`,
              undefined,
              error.message
            );
          }
        }

        // =============================================================================
        // PAGE LAYOUT TOOLS - Case Handlers
        // =============================================================================

        case 'sf_list_page_layouts': {
          try {
            const result = await this.salesforceService.listPageLayouts(userId, toolInput.objectName);
            return {
              success: true,
              message: `Found ${result.layouts?.length || 0} page layouts for ${toolInput.objectName}`,
              data: result.layouts,
            };
          } catch (error) {
            return { success: false, error: `Failed to list page layouts: ${error.message}` };
          }
        }

        case 'sf_get_page_layout': {
          try {
            const result = await this.salesforceService.getPageLayoutDetails(userId, toolInput.layoutId);
            return {
              success: true,
              message: `Retrieved page layout details`,
              data: result,
            };
          } catch (error) {
            return { success: false, error: `Failed to get page layout: ${error.message}` };
          }
        }

        case 'sf_create_page_layout': {
          try {
            const result = await this.salesforceService.createPageLayout(
              userId,
              toolInput.objectName,
              {
                name: toolInput.name,
                sections: toolInput.sections,
              }
            );
            if (result.success) {
              return {
                success: true,
                message: `Page layout '${toolInput.name}' created successfully`,
                data: { layoutId: result.layoutId },
              };
            }
            return { success: false, error: result.error || 'Unknown error' };
          } catch (error) {
            return { success: false, error: `Failed to create page layout: ${error.message}` };
          }
        }

        case 'sf_update_page_layout': {
          try {
            const result = await this.salesforceService.updatePageLayout(
              userId,
              toolInput.layoutId,
              {
                addFields: toolInput.addFields,
                removeFields: toolInput.removeFields,
              }
            );
            if (result.success) {
              return { success: true, message: 'Page layout updated successfully' };
            }
            return { success: false, error: result.error || 'Unknown error' };
          } catch (error) {
            return { success: false, error: `Failed to update page layout: ${error.message}` };
          }
        }

        case 'sf_assign_page_layout': {
          try {
            const result = await this.salesforceService.assignPageLayoutToProfile(
              userId,
              toolInput.layoutId,
              toolInput.profileId,
              toolInput.recordTypeId
            );
            if (result.success) {
              return { success: true, message: 'Page layout assigned to profile successfully' };
            }
            return { success: false, error: result.error };
          } catch (error) {
            return { success: false, error: `Failed to assign page layout: ${error.message}` };
          }
        }

        // =============================================================================
        // APEX DEPLOYMENT TOOLS - Case Handlers
        // =============================================================================

        case 'sf_deploy_apex_class': {
          try {
            const result = await this.salesforceService.deployApexClass(userId, {
              name: toolInput.name,
              body: toolInput.body,
              apiVersion: toolInput.apiVersion || 59.0,
            });
            if (result.success) {
              return {
                success: true,
                message: `Apex class '${toolInput.name}' deployed successfully`,
                data: { classId: result.classId },
              };
            }
            return { success: false, error: result.errors?.join(', ') || 'Unknown error' };
          } catch (error) {
            return { success: false, error: `Failed to deploy Apex class: ${error.message}` };
          }
        }

        case 'sf_deploy_apex_trigger': {
          try {
            const result = await this.salesforceService.deployApexTrigger(userId, {
              name: toolInput.name,
              body: toolInput.body,
              objectName: toolInput.objectName,
              apiVersion: toolInput.apiVersion || 59.0,
            });
            if (result.success) {
              return {
                success: true,
                message: `Apex trigger '${toolInput.name}' deployed successfully`,
                data: { triggerId: result.triggerId },
              };
            }
            return { success: false, error: result.errors?.join(', ') || 'Unknown error' };
          } catch (error) {
            return { success: false, error: `Failed to deploy Apex trigger: ${error.message}` };
          }
        }

        case 'sf_delete_apex_class': {
          try {
            const result = await this.salesforceService.deleteApexClass(userId, toolInput.classId);
            if (result.success) {
              return { success: true, message: 'Apex class deleted successfully' };
            }
            return { success: false, error: result.error };
          } catch (error) {
            return { success: false, error: `Failed to delete Apex class: ${error.message}` };
          }
        }

        // =============================================================================
        // LIGHTNING WEB COMPONENT TOOLS - Case Handlers
        // =============================================================================

        case 'sf_deploy_lwc': {
          try {
            const result = await this.salesforceService.deployLwc(userId, {
              name: toolInput.name,
              jsContent: toolInput.jsContent,
              htmlContent: toolInput.htmlContent,
              cssContent: toolInput.cssContent,
              metaXml: toolInput.metaXml,
              apiVersion: toolInput.apiVersion || 59.0,
            });
            if (result.success) {
              return {
                success: true,
                message: `Lightning Web Component '${toolInput.name}' deployed successfully`,
                data: { bundleId: result.bundleId },
              };
            }
            return { success: false, error: result.errors?.join(', ') || 'Unknown error' };
          } catch (error) {
            return { success: false, error: `Failed to deploy LWC: ${error.message}` };
          }
        }

        case 'sf_list_lwc': {
          try {
            const result = await this.salesforceService.listLwcComponents(userId);
            return {
              success: true,
              message: `Found ${result.components?.length || 0} Lightning Web Components`,
              data: result.components,
            };
          } catch (error) {
            return { success: false, error: `Failed to list LWC components: ${error.message}` };
          }
        }

        case 'sf_delete_lwc': {
          try {
            const result = await this.salesforceService.deleteLwcComponent(userId, toolInput.bundleId);
            if (result.success) {
              return { success: true, message: 'Lightning Web Component deleted successfully' };
            }
            return { success: false, error: result.error || 'Unknown error' };
          } catch (error) {
            return { success: false, error: `Failed to delete LWC: ${error.message}` };
          }
        }

        // =============================================================================
        // WORKFLOW RULES TOOLS - Case Handlers
        // =============================================================================

        case 'sf_list_workflow_rules': {
          try {
            const result = await this.salesforceService.listWorkflowRules(userId, toolInput.objectName);
            return {
              success: true,
              message: `Found ${result.rules?.length || 0} workflow rules for ${toolInput.objectName}`,
              data: result.rules,
            };
          } catch (error) {
            return { success: false, error: `Failed to list workflow rules: ${error.message}` };
          }
        }

        case 'sf_create_workflow_rule': {
          try {
            const result = await this.salesforceService.createWorkflowRule(userId, {
              objectName: toolInput.objectName,
              name: toolInput.name,
              description: toolInput.description,
              triggerType: toolInput.triggerType,
            });
            if (result.success) {
              return {
                success: true,
                message: `Workflow rule '${toolInput.name}' created successfully`,
                data: { ruleId: result.ruleId },
              };
            }
            return { success: false, error: result.error || 'Unknown error' };
          } catch (error) {
            return { success: false, error: `Failed to create workflow rule: ${error.message}` };
          }
        }

        case 'sf_delete_workflow_rule': {
          try {
            const result = await this.salesforceService.deleteWorkflowRule(userId, toolInput.ruleId);
            if (result.success) {
              return { success: true, message: 'Workflow rule deleted successfully' };
            }
            return { success: false, error: result.error };
          } catch (error) {
            return { success: false, error: `Failed to delete workflow rule: ${error.message}` };
          }
        }

        // =============================================================================
        // APPROVAL PROCESS TOOLS - Case Handlers
        // =============================================================================

        case 'sf_list_approval_processes': {
          try {
            const result = await this.salesforceService.listApprovalProcesses(userId, toolInput.objectName);
            return {
              success: true,
              message: `Found ${result.processes?.length || 0} approval processes for ${toolInput.objectName}`,
              data: result.processes,
            };
          } catch (error) {
            return { success: false, error: `Failed to list approval processes: ${error.message}` };
          }
        }

        case 'sf_create_approval_process': {
          try {
            const result = await this.salesforceService.createApprovalProcess(userId, {
              objectName: toolInput.objectName,
              name: toolInput.name,
              description: toolInput.description,
              entryCriteria: toolInput.entryCriteria,
              allowRecall: toolInput.allowRecall !== false,
              approvalSteps: toolInput.approvalSteps || [],
              finalApprovalActions: toolInput.finalApprovalActions,
              finalRejectionActions: toolInput.finalRejectionActions,
            });
            if (result.success) {
              return {
                success: true,
                message: `Approval process '${toolInput.name}' created successfully`,
                data: { processId: result.processId },
              };
            }
            return { success: false, error: result.error || 'Unknown error' };
          } catch (error) {
            return { success: false, error: `Failed to create approval process: ${error.message}` };
          }
        }

        case 'sf_toggle_approval_process': {
          try {
            const result = await this.salesforceService.toggleApprovalProcess(
              userId,
              toolInput.processId,
              toolInput.active
            );
            if (result.success) {
              return {
                success: true,
                message: `Approval process ${toolInput.active ? 'activated' : 'deactivated'} successfully`,
              };
            }
            return { success: false, error: result.error };
          } catch (error) {
            return { success: false, error: `Failed to toggle approval process: ${error.message}` };
          }
        }

        case 'sf_delete_approval_process': {
          try {
            const result = await this.salesforceService.deleteApprovalProcess(userId, toolInput.processId);
            if (result.success) {
              return { success: true, message: 'Approval process deleted successfully' };
            }
            return { success: false, error: result.error };
          } catch (error) {
            return { success: false, error: `Failed to delete approval process: ${error.message}` };
          }
        }

        case 'sf_submit_for_approval': {
          try {
            const result = await this.salesforceService.submitForApproval(
              userId,
              toolInput.recordId,
              { comments: toolInput.comments }
            );
            if (result.success) {
              return {
                success: true,
                message: 'Record submitted for approval successfully',
                data: { instanceId: result.instanceId },
              };
            }
            return { success: false, error: result.errors?.join(', ') || 'Unknown error' };
          } catch (error) {
            return { success: false, error: `Failed to submit for approval: ${error.message}` };
          }
        }

        case 'sf_process_approval': {
          try {
            const result = await this.salesforceService.processApprovalRequest(
              userId,
              toolInput.workItemId,
              toolInput.action,
              toolInput.comments
            );
            if (result.success) {
              return {
                success: true,
                message: `Approval request ${toolInput.action.toLowerCase()}d successfully`,
              };
            }
            return { success: false, error: result.error || 'Unknown error' };
          } catch (error) {
            return { success: false, error: `Failed to process approval: ${error.message}` };
          }
        }

        // =============================================================================
        // REPORTS & DASHBOARDS TOOLS - Case Handlers
        // =============================================================================

        case 'sf_list_reports': {
          try {
            const result = await this.salesforceService.listReports(userId, {
              folderId: toolInput.folderId,
            });
            return {
              success: true,
              message: `Found ${result.reports?.length || 0} reports`,
              data: result.reports,
            };
          } catch (error) {
            return { success: false, error: `Failed to list reports: ${error.message}` };
          }
        }

        case 'sf_get_report_metadata': {
          try {
            const result = await this.salesforceService.getReportMetadata(userId, toolInput.reportId);
            return {
              success: true,
              message: 'Retrieved report metadata',
              data: result,
            };
          } catch (error) {
            return { success: false, error: `Failed to get report metadata: ${error.message}` };
          }
        }

        case 'sf_create_report': {
          try {
            this.logger.warn(`[SF_CREATE_REPORT] Input: name=${toolInput.name}, reportType=${toolInput.reportType}, format=${toolInput.format}, columns=${JSON.stringify(toolInput.columns)?.substring(0, 200)}`);

            const result = await this.salesforceService.createReport(userId, {
              name: toolInput.name,
              reportType: toolInput.reportType,
              format: toolInput.format,
              folderId: toolInput.folderId,
              columns: toolInput.columns,
              filters: toolInput.filters,
              groupings: toolInput.groupings,
            });

            this.logger.warn(`[SF_CREATE_REPORT] Result: success=${result.success}, reportId=${result.reportId}, error=${result.error || 'none'}`);

            if (result.success) {
              return {
                success: true,
                message: `Report '${result.reportName}' created successfully.\n\n**Report URL:** ${result.reportUrl}`,
                data: {
                  reportId: result.reportId,
                  reportUrl: result.reportUrl,
                  reportName: result.reportName,
                },
              };
            }
            return { success: false, error: result.error };
          } catch (error) {
            this.logger.error(`[SF_CREATE_REPORT] Exception: ${error.message}`);
            return { success: false, error: `Failed to create report: ${error.message}` };
          }
        }

        case 'sf_run_report': {
          try {
            const result = await this.salesforceService.runReport(
              userId,
              toolInput.reportId,
              { includeDetails: toolInput.includeDetails !== false }
            );
            return {
              success: true,
              message: `Report executed successfully (${result.factMap?.['T!T']?.rows?.length || 0} rows)`,
              data: result,
            };
          } catch (error) {
            return { success: false, error: `Failed to run report: ${error.message}` };
          }
        }

        case 'sf_update_report': {
          try {
            const result = await this.salesforceService.updateReport(userId, toolInput.reportId, {
              name: toolInput.name,
              columns: toolInput.columns,
              filters: toolInput.filters,
            });
            if (result.success) {
              const instanceUrl = await this.salesforceService.getInstanceUrl(userId);
              const reportUrl = `${instanceUrl}/lightning/r/Report/${toolInput.reportId}/view`;
              return {
                success: true,
                message: `Report updated successfully.\n\n**Report URL:** ${reportUrl}`,
                data: { reportId: toolInput.reportId, url: reportUrl },
              };
            }
            return { success: false, error: result.error };
          } catch (error) {
            return { success: false, error: `Failed to update report: ${error.message}` };
          }
        }

        case 'sf_delete_report': {
          try {
            const result = await this.salesforceService.deleteReport(userId, toolInput.reportId);
            if (result.success) {
              return { success: true, message: 'Report deleted successfully' };
            }
            return { success: false, error: result.error };
          } catch (error) {
            return { success: false, error: `Failed to delete report: ${error.message}` };
          }
        }

        case 'sf_list_report_folders': {
          try {
            const result = await this.salesforceService.listReportFolders(userId);
            return {
              success: true,
              message: `Found ${result.folders?.length || 0} report folders`,
              data: result.folders,
            };
          } catch (error) {
            return { success: false, error: `Failed to list report folders: ${error.message}` };
          }
        }

        case 'sf_get_report_types': {
          try {
            const result = await this.salesforceService.getReportTypes(userId);
            return {
              success: true,
              message: `Found ${result.reportTypes?.length || 0} report types`,
              data: result.reportTypes,
            };
          } catch (error) {
            return { success: false, error: `Failed to get report types: ${error.message}` };
          }
        }

        case 'sf_list_dashboards': {
          try {
            const result = await this.salesforceService.listDashboards(userId, { folderId: toolInput.folderId });
            return {
              success: true,
              message: `Found ${result.dashboards?.length || 0} dashboards`,
              data: result.dashboards,
            };
          } catch (error) {
            return { success: false, error: `Failed to list dashboards: ${error.message}` };
          }
        }

        case 'sf_get_dashboard_metadata': {
          try {
            const result = await this.salesforceService.getDashboardMetadata(userId, toolInput.dashboardId);
            return {
              success: true,
              message: 'Retrieved dashboard metadata',
              data: result,
            };
          } catch (error) {
            return { success: false, error: `Failed to get dashboard metadata: ${error.message}` };
          }
        }

        case 'sf_create_dashboard': {
          try {
            const result = await this.salesforceService.createDashboard(userId, {
              name: toolInput.name,
              folderId: toolInput.folderId,
              description: toolInput.description,
              components: toolInput.components,
            });
            if (result.success) {
              const instanceUrl = await this.salesforceService.getInstanceUrl(userId);
              const dashboardUrl = `${instanceUrl}/lightning/r/Dashboard/${result.dashboardId}/view`;
              return {
                success: true,
                message: `Dashboard '${toolInput.name}' created successfully.\n\n**Dashboard URL:** ${dashboardUrl}`,
                data: { dashboardId: result.dashboardId, url: dashboardUrl },
              };
            }
            return { success: false, error: result.error };
          } catch (error) {
            return { success: false, error: `Failed to create dashboard: ${error.message}` };
          }
        }

        case 'sf_refresh_dashboard': {
          try {
            const result = await this.salesforceService.refreshDashboard(userId, toolInput.dashboardId);
            if (result.success) {
              return { success: true, message: 'Dashboard refreshed successfully' };
            }
            return { success: false, error: result.error };
          } catch (error) {
            return { success: false, error: `Failed to refresh dashboard: ${error.message}` };
          }
        }

        case 'sf_delete_dashboard': {
          try {
            const result = await this.salesforceService.deleteDashboard(userId, toolInput.dashboardId);
            if (result.success) {
              return { success: true, message: 'Dashboard deleted successfully' };
            }
            return { success: false, error: result.error };
          } catch (error) {
            return { success: false, error: `Failed to delete dashboard: ${error.message}` };
          }
        }

        case 'sf_list_dashboard_folders': {
          try {
            const result = await this.salesforceService.listDashboardFolders(userId);
            return {
              success: true,
              message: `Found ${result.folders?.length || 0} dashboard folders`,
              data: result.folders,
            };
          } catch (error) {
            return { success: false, error: `Failed to list dashboard folders: ${error.message}` };
          }
        }

        // =============================================================================
        // ORACLE CX SALES CLOUD TOOLS - Direct Oracle CX Operations
        // =============================================================================

        case 'ocx_query': {
          try {
            const { resource, filters, limit, offset, orderBy, fields } = toolInput;
            // Validate and cap limit to prevent SLM hallucinations (max 500 for Oracle CX)
            let safeLimit = typeof limit === 'number' ? limit : 10;
            if (safeLimit > 500) safeLimit = 500;
            if (safeLimit < 1) safeLimit = 10;

            let result = await this.oracleCXService.query(userId, resource, {
              filters,
              limit: safeLimit,
              offset,
              orderBy,
              fields,
            });

            // SMART RETRY: If filtered query returns 0 results, retry without filter
            // This helps when filter syntax fails or doesn't match exact field values
            const recordCount = result.count || result.items?.length || 0;
            if (recordCount === 0 && filters && Object.keys(filters).length > 0) {
              this.logger.warn(`[OCX_SMART_RETRY] Filtered query returned 0 results, retrying without filter...`);
              const retryLimit = Math.max(safeLimit, 20); // Get more results for manual matching
              result = await this.oracleCXService.query(userId, resource, {
                limit: retryLimit,
                offset,
                orderBy,
                fields,
              });
              const retryCount = result.count || result.items?.length || 0;
              this.logger.log(`[OCX_SMART_RETRY] Retry returned ${retryCount} records (without filter)`);
            }

            return {
              success: true,
              message: `Query returned ${result.count || result.items?.length || 0} record(s)`,
              data: {
                totalSize: result.count || result.items?.length || 0,
                hasMore: result.hasMore || false,
                records: result.items || [],
              },
            };
          } catch (error) {
            return { success: false, error: `Oracle CX query failed: ${error.message}` };
          }
        }

        case 'ocx_get_record': {
          try {
            const { resource, recordId, expand } = toolInput;
            const result = await this.oracleCXService.getById(userId, resource, recordId, expand);
            return {
              success: true,
              message: 'Record retrieved',
              data: result,
            };
          } catch (error) {
            return { success: false, error: `Oracle CX get record failed: ${error.message}` };
          }
        }

        case 'ocx_create_lead': {
          try {
            const data = { ...toolInput };
            delete data.leadId; // Remove any ID field
            const result = await this.oracleCXService.create(userId, 'leads', data) as any;
            return {
              success: true,
              message: `Lead created successfully`,
              data: {
                id: result.LeadId || result.Id || result.id,
                name: `${result.FirstName || ''} ${result.LastName || ''}`.trim(),
                ...result,
              },
            };
          } catch (error) {
            return { success: false, error: `Oracle CX create lead failed: ${error.message}` };
          }
        }

        case 'ocx_update_lead': {
          try {
            const { leadId, ...data } = toolInput;
            const result = await this.oracleCXService.update(userId, 'leads', leadId, data);
            return {
              success: true,
              message: `Lead ${leadId} updated successfully`,
              data: result,
            };
          } catch (error) {
            return { success: false, error: `Oracle CX update lead failed: ${error.message}` };
          }
        }

        case 'ocx_create_opportunity': {
          try {
            const data = { ...toolInput };
            delete data.opportunityId;
            const result = await this.oracleCXService.create(userId, 'opportunities', data) as any;
            return {
              success: true,
              message: `Opportunity created successfully`,
              data: {
                id: result.OptyId || result.Id || result.id,
                name: result.Name,
                ...result,
              },
            };
          } catch (error) {
            return { success: false, error: `Oracle CX create opportunity failed: ${error.message}` };
          }
        }

        case 'ocx_update_opportunity': {
          try {
            const { opportunityId, ...data } = toolInput;
            const result = await this.oracleCXService.update(userId, 'opportunities', opportunityId, data);
            return {
              success: true,
              message: `Opportunity ${opportunityId} updated successfully`,
              data: result,
            };
          } catch (error) {
            return { success: false, error: `Oracle CX update opportunity failed: ${error.message}` };
          }
        }

        case 'ocx_create_contact': {
          try {
            const data = { ...toolInput };
            delete data.contactId;
            const result = await this.oracleCXService.create(userId, 'contacts', data) as any;
            return {
              success: true,
              message: `Contact created successfully`,
              data: {
                id: result.PartyId || result.Id || result.id,
                name: `${result.FirstName || ''} ${result.LastName || ''}`.trim(),
                ...result,
              },
            };
          } catch (error) {
            return { success: false, error: `Oracle CX create contact failed: ${error.message}` };
          }
        }

        case 'ocx_update_contact': {
          try {
            const { contactId, ...data } = toolInput;
            const result = await this.oracleCXService.update(userId, 'contacts', contactId, data);
            return {
              success: true,
              message: `Contact ${contactId} updated successfully`,
              data: result,
            };
          } catch (error) {
            return { success: false, error: `Oracle CX update contact failed: ${error.message}` };
          }
        }

        case 'ocx_create_account': {
          try {
            const data = { ...toolInput };
            delete data.accountId;
            const result = await this.oracleCXService.create(userId, 'accounts', data) as any;
            return {
              success: true,
              message: `Account created successfully`,
              data: {
                id: result.PartyId || result.Id || result.id,
                name: result.OrganizationName || result.Name,
                ...result,
              },
            };
          } catch (error) {
            return { success: false, error: `Oracle CX create account failed: ${error.message}` };
          }
        }

        case 'ocx_create_task': {
          try {
            const data = { ...toolInput };
            delete data.taskId;
            const result = await this.oracleCXService.create(userId, 'activities', data) as any;
            return {
              success: true,
              message: `Task created successfully`,
              data: {
                id: result.ActivityId || result.Id || result.id,
                subject: result.Subject,
                ...result,
              },
            };
          } catch (error) {
            return { success: false, error: `Oracle CX create task failed: ${error.message}` };
          }
        }

        case 'ocx_describe_resource': {
          try {
            const { resource } = toolInput;
            // Get writable fields for create/update operations
            const writableFields = await this.oracleCXService.getWritableFields(userId, resource);
            const requiredFields = writableFields.filter(f => f.required);
            const optionalFields = writableFields.filter(f => !f.required);

            return {
              success: true,
              message: `Schema for ${resource}`,
              requiredFields: requiredFields.map(f => `${f.name} (${f.type})${f.description ? ': ' + f.description : ''}`),
              optionalFields: optionalFields.slice(0, 30).map(f => `${f.name} (${f.type})`), // Limit to first 30
              totalOptionalFields: optionalFields.length,
              commonFieldHints: {
                leads: ['Name', 'CustomerPartyName', 'PrimaryContactPersonFirstName', 'PrimaryContactPersonLastName', 'PrimaryContactEmailAddress', 'PrimaryPhoneNumber', 'Description'],
                opportunities: ['Name', 'TargetPartyId', 'Revenue', 'SalesStage', 'CloseDate'],
                contacts: ['PersonFirstName', 'PersonLastName', 'EmailAddress', 'PhoneNumber'],
                accounts: ['OrganizationName', 'Industry', 'Type'],
              }[resource] || [],
            };
          } catch (error) {
            return { success: false, error: `Oracle CX describe resource failed: ${error.message}` };
          }
        }

        case 'ocx_update_record': {
          try {
            const { resource, recordId, fields } = toolInput;
            const result = await this.oracleCXService.update(userId, resource, recordId, fields);
            return {
              success: true,
              message: `${resource} record ${recordId} updated successfully`,
              data: result,
            };
          } catch (error) {
            return { success: false, error: `Oracle CX update record failed: ${error.message}` };
          }
        }

        case 'ocx_create_record': {
          try {
            const { resource, fields } = toolInput;
            const result = await this.oracleCXService.create(userId, resource, fields);
            return {
              success: true,
              message: `${resource} record created successfully`,
              data: result,
            };
          } catch (error) {
            return { success: false, error: `Oracle CX create record failed: ${error.message}` };
          }
        }

        // ==================== AI INSIGHTS & COACHING TOOLS (MVP #1 & #2) ====================
        case 'get_my_ai_insights': {
          try {
            const { agentType, priority, limit = 10 } = toolInput;
            const cutoffDate = new Date();
            cutoffDate.setDate(cutoffDate.getDate() - 30); // Last 30 days

            const where: any = {
              userId,
              status: { in: ['NEW', 'ACKNOWLEDGED'] },
              createdAt: { gte: cutoffDate },
            };

            if (agentType) where.agentType = agentType;
            if (priority) where.priority = priority;

            const alerts = await this.prisma.agentAlert.findMany({
              where,
              take: limit,
              orderBy: [
                { priority: 'asc' }, // URGENT first (enum order)
                { createdAt: 'desc' },
              ],
            });

            if (alerts.length === 0) {
              return {
                success: true,
                message: 'No active AI insights at the moment. Your pipeline looks good!',
                insights: [],
                count: 0,
              };
            }

            // Format alerts for conversational response
            const insights = alerts.map((alert: any) => ({
              id: alert.id,
              type: alert.agentType,
              priority: alert.priority,
              title: alert.title,
              description: alert.description,
              recommendation: alert.recommendation,
              entityType: alert.entityType,
              entityId: alert.entityId,
              suggestedActions: alert.suggestedActions,
              createdAt: alert.createdAt,
            }));

            return {
              success: true,
              message: `Found ${insights.length} AI insight${insights.length === 1 ? '' : 's'} for you`,
              insights,
              count: insights.length,
              summary: {
                urgent: insights.filter((i: any) => i.priority === 'URGENT').length,
                high: insights.filter((i: any) => i.priority === 'HIGH').length,
                medium: insights.filter((i: any) => i.priority === 'MEDIUM').length,
                low: insights.filter((i: any) => i.priority === 'LOW').length,
              },
            };
          } catch (error) {
            this.logger.error(`Failed to get AI insights: ${error.message}`, error.stack);
            return { success: false, error: `Failed to get AI insights: ${error.message}` };
          }
        }

        case 'get_sales_coaching': {
          try {
            const { focusArea } = toolInput;

            // Get coaching-specific alerts
            const coachingAlerts = await this.prisma.agentAlert.findMany({
              where: {
                userId,
                agentType: 'COACHING',
                status: { in: ['NEW', 'ACKNOWLEDGED'] },
                createdAt: { gte: new Date(Date.now() - 30 * 24 * 60 * 60 * 1000) },
              },
              take: 10,
              orderBy: { createdAt: 'desc' },
            });

            // Get user's performance metrics from opportunities
            const opportunities = await this.prisma.opportunity.findMany({
              where: {
                ownerId: userId,
                createdAt: { gte: new Date(Date.now() - 90 * 24 * 60 * 60 * 1000) },
              },
              include: { account: true },
            });

            const wonOpps = opportunities.filter((o: any) => o.stage === 'CLOSED_WON');
            const lostOpps = opportunities.filter((o: any) => o.stage === 'CLOSED_LOST');
            const openOpps = opportunities.filter((o: any) => !o.stage?.includes('CLOSED'));

            const winRate = (wonOpps.length + lostOpps.length) > 0
              ? Math.round((wonOpps.length / (wonOpps.length + lostOpps.length)) * 100)
              : 0;

            const avgDealSize = wonOpps.length > 0
              ? Math.round(wonOpps.reduce((sum: number, o: any) => sum + (o.amount || 0), 0) / wonOpps.length)
              : 0;

            const pipelineValue = openOpps.reduce((sum: number, o: any) => sum + (o.amount || 0), 0);

            // Build coaching response
            const tips: string[] = [];
            const coaching = {
              performance: {
                winRate: `${winRate}%`,
                avgDealSize: `$${avgDealSize.toLocaleString()}`,
                pipelineValue: `$${pipelineValue.toLocaleString()}`,
                openDeals: openOpps.length,
                closedWon: wonOpps.length,
                closedLost: lostOpps.length,
              },
              insights: coachingAlerts.map((alert: any) => ({
                id: alert.id,
                title: alert.title,
                description: alert.description,
                recommendation: alert.recommendation,
                suggestedActions: alert.suggestedActions,
              })),
              tips,
            };

            // Add contextual coaching tips based on metrics
            if (winRate < 25 && (wonOpps.length + lostOpps.length) > 3) {
              coaching.tips.push('Your win rate is below average. Focus on better qualifying deals early in the pipeline.');
            }
            if (openOpps.filter((o: any) => {
              const daysSinceUpdate = (Date.now() - new Date(o.updatedAt).getTime()) / (1000 * 60 * 60 * 24);
              return daysSinceUpdate > 14;
            }).length > 0) {
              coaching.tips.push('You have deals that haven\'t been updated in 2+ weeks. Schedule follow-ups to keep momentum.');
            }
            if (pipelineValue < avgDealSize * 3) {
              coaching.tips.push('Your pipeline coverage is thin. Consider prospecting to build more opportunities.');
            }

            if (coaching.tips.length === 0 && coachingAlerts.length === 0) {
              coaching.tips.push('Keep up the good work! Your pipeline metrics look healthy.');
            }

            return {
              success: true,
              message: 'Here\'s your personalized sales coaching analysis',
              coaching,
              focusArea: focusArea || 'general',
            };
          } catch (error) {
            this.logger.error(`Failed to get sales coaching: ${error.message}`, error.stack);
            return { success: false, error: `Failed to get sales coaching: ${error.message}` };
          }
        }

        case 'get_account_intelligence': {
          try {
            let { accountId, accountName } = toolInput;

            // If name provided, resolve to ID
            if (!accountId && accountName) {
              const account = await this.prisma.account.findFirst({
                where: {
                  ownerId: userId,
                  name: { contains: accountName, mode: 'insensitive' },
                },
              });
              if (!account) {
                return {
                  success: false,
                  error: `Account "${accountName}" not found. Try a different name or provide the account ID.`,
                };
              }
              accountId = account.id;
            }

            if (!accountId) {
              return {
                success: false,
                error: 'Please specify an account name or ID to analyze.',
              };
            }

            // Get account details
            const account = await this.prisma.account.findFirst({
              where: { id: accountId, ownerId: userId },
              include: {
                contacts: { take: 10 },
                opportunities: { take: 10 },
                activities: { take: 20, orderBy: { createdAt: 'desc' } },
              },
            });

            if (!account) {
              return { success: false, error: `Account not found or access denied.` };
            }

            // Get account-specific alerts
            const accountAlerts = await this.prisma.agentAlert.findMany({
              where: {
                userId,
                entityType: 'ACCOUNT',
                entityId: accountId,
                status: { in: ['NEW', 'ACKNOWLEDGED'] },
              },
              take: 5,
              orderBy: { createdAt: 'desc' },
            });

            // Calculate health metrics
            const recentActivities = (account as any).activities?.filter((a: any) => {
              const daysSince = (Date.now() - new Date(a.createdAt).getTime()) / (1000 * 60 * 60 * 24);
              return daysSince <= 30;
            }) || [];

            const contactCount = (account as any).contacts?.length || 0;
            const opportunityCount = (account as any).opportunities?.length || 0;
            const activeOpps = (account as any).opportunities?.filter((o: any) => !o.stage?.includes('CLOSED')) || [];
            const lastActivity = (account as any).activities?.[0];
            const daysSinceLastActivity = lastActivity
              ? Math.round((Date.now() - new Date(lastActivity.createdAt).getTime()) / (1000 * 60 * 60 * 24))
              : 999;

            // Calculate health score (0-100)
            let healthScore = 50; // Base score
            if (recentActivities.length >= 5) healthScore += 20;
            else if (recentActivities.length >= 2) healthScore += 10;
            if (contactCount >= 3) healthScore += 15;
            else if (contactCount >= 1) healthScore += 5;
            if (activeOpps.length > 0) healthScore += 15;
            if (daysSinceLastActivity <= 7) healthScore += 10;
            else if (daysSinceLastActivity > 30) healthScore -= 20;

            healthScore = Math.max(0, Math.min(100, healthScore));

            const healthStatus = healthScore >= 70 ? 'Healthy' : healthScore >= 40 ? 'Needs Attention' : 'At Risk';

            return {
              success: true,
              message: `Account intelligence for ${(account as any).name}`,
              account: {
                id: account.id,
                name: (account as any).name,
                industry: (account as any).industry,
                website: (account as any).website,
              },
              health: {
                score: healthScore,
                status: healthStatus,
                metrics: {
                  contactCoverage: contactCount,
                  activeOpportunities: activeOpps.length,
                  recentActivityCount: recentActivities.length,
                  daysSinceLastActivity,
                },
              },
              insights: accountAlerts.map((alert: any) => ({
                id: alert.id,
                priority: alert.priority,
                title: alert.title,
                description: alert.description,
                recommendation: alert.recommendation,
              })),
              recommendations: [],
            };
          } catch (error) {
            this.logger.error(`Failed to get account intelligence: ${error.message}`, error.stack);
            return { success: false, error: `Failed to get account intelligence: ${error.message}` };
          }
        }

        case 'get_deal_health': {
          try {
            const { opportunityId, riskLevel, limit = 10 } = toolInput;

            // If specific opportunity requested
            if (opportunityId) {
              const opp = await this.prisma.opportunity.findFirst({
                where: { id: opportunityId, ownerId: userId },
                include: {
                  account: true,
                  activities: { take: 10, orderBy: { createdAt: 'desc' } },
                },
              });

              if (!opp) {
                return { success: false, error: 'Opportunity not found or access denied.' };
              }

              const alerts = await this.prisma.agentAlert.findMany({
                where: {
                  userId,
                  entityType: 'OPPORTUNITY',
                  entityId: opportunityId,
                  status: { in: ['NEW', 'ACKNOWLEDGED'] },
                },
                take: 5,
              });

              // Calculate deal health
              const daysSinceUpdate = Math.round((Date.now() - new Date((opp as any).updatedAt).getTime()) / (1000 * 60 * 60 * 24));
              const recentActivities = (opp as any).activities?.length || 0;

              let healthScore = 70;
              if (daysSinceUpdate > 14) healthScore -= 30;
              else if (daysSinceUpdate > 7) healthScore -= 15;
              if (recentActivities < 2) healthScore -= 20;
              if ((opp as any).probability && (opp as any).probability < 30) healthScore -= 10;

              healthScore = Math.max(0, Math.min(100, healthScore));

              return {
                success: true,
                deal: {
                  id: opp.id,
                  name: (opp as any).name,
                  accountName: (opp as any).account?.name,
                  stage: (opp as any).stage,
                  amount: (opp as any).amount,
                  closeDate: (opp as any).closeDate,
                  probability: (opp as any).probability,
                },
                health: {
                  score: healthScore,
                  status: healthScore >= 70 ? 'Healthy' : healthScore >= 40 ? 'Needs Attention' : 'At Risk',
                  daysSinceUpdate,
                  recentActivityCount: recentActivities,
                },
                alerts: alerts.map((a: any) => ({
                  id: a.id,
                  priority: a.priority,
                  title: a.title,
                  description: a.description,
                  recommendation: a.recommendation,
                })),
              };
            }

            // Get all deals with health analysis
            const deals = await this.prisma.opportunity.findMany({
              where: {
                ownerId: userId,
                stage: { notIn: ['CLOSED_WON', 'CLOSED_LOST'] },
              },
              include: {
                account: true,
                activities: { take: 5, orderBy: { createdAt: 'desc' } },
              },
              take: 50,
            });

            // Get deal health alerts
            const dealAlerts = await this.prisma.agentAlert.findMany({
              where: {
                userId,
                agentType: 'DEAL_HEALTH',
                entityType: 'OPPORTUNITY',
                status: { in: ['NEW', 'ACKNOWLEDGED'] },
              },
            });

            const alertsByDeal = new Map<string, any[]>();
            dealAlerts.forEach((alert: any) => {
              const existing = alertsByDeal.get(alert.entityId) || [];
              existing.push(alert);
              alertsByDeal.set(alert.entityId, existing);
            });

            // Analyze each deal
            const analyzedDeals = deals.map((deal: any) => {
              const daysSinceUpdate = Math.round((Date.now() - new Date(deal.updatedAt).getTime()) / (1000 * 60 * 60 * 24));
              const recentActivities = deal.activities?.length || 0;
              const dealAlertList = alertsByDeal.get(deal.id) || [];

              let healthScore = 70;
              if (daysSinceUpdate > 14) healthScore -= 30;
              else if (daysSinceUpdate > 7) healthScore -= 15;
              if (recentActivities < 2) healthScore -= 20;
              if (deal.probability && deal.probability < 30) healthScore -= 10;
              if (dealAlertList.length > 0) healthScore -= dealAlertList.length * 5;

              healthScore = Math.max(0, Math.min(100, healthScore));

              const risk = healthScore >= 70 ? 'healthy' : healthScore >= 40 ? 'medium_risk' : 'high_risk';

              return {
                id: deal.id,
                name: deal.name,
                accountName: deal.account?.name,
                stage: deal.stage,
                amount: deal.amount,
                closeDate: deal.closeDate,
                healthScore,
                risk,
                daysSinceUpdate,
                alertCount: dealAlertList.length,
              };
            });

            // Filter by risk level if specified
            let filteredDeals = analyzedDeals;
            if (riskLevel) {
              filteredDeals = analyzedDeals.filter((d: any) => d.risk === riskLevel);
            }

            // Sort by health score (worst first)
            filteredDeals.sort((a: any, b: any) => a.healthScore - b.healthScore);

            return {
              success: true,
              message: `Analyzed ${filteredDeals.length} deal${filteredDeals.length === 1 ? '' : 's'}`,
              deals: filteredDeals.slice(0, limit),
              summary: {
                total: analyzedDeals.length,
                atRisk: analyzedDeals.filter((d: any) => d.risk === 'high_risk').length,
                needsAttention: analyzedDeals.filter((d: any) => d.risk === 'medium_risk').length,
                healthy: analyzedDeals.filter((d: any) => d.risk === 'healthy').length,
              },
            };
          } catch (error) {
            this.logger.error(`Failed to get deal health: ${error.message}`, error.stack);
            return { success: false, error: `Failed to get deal health: ${error.message}` };
          }
        }

        case 'acknowledge_ai_insight': {
          try {
            const { alertId } = toolInput;

            const alert = await this.prisma.agentAlert.findFirst({
              where: { id: alertId, userId },
            });

            if (!alert) {
              return { success: false, error: 'Alert not found or access denied.' };
            }

            await this.prisma.agentAlert.update({
              where: { id: alertId },
              data: {
                status: 'ACKNOWLEDGED',
                acknowledgedAt: new Date(),
                acknowledgedBy: userId,
              },
            });

            return {
              success: true,
              message: 'Insight acknowledged. I\'ll keep tracking this for you.',
            };
          } catch (error) {
            this.logger.error(`Failed to acknowledge insight: ${error.message}`, error.stack);
            return { success: false, error: `Failed to acknowledge insight: ${error.message}` };
          }
        }

        case 'dismiss_ai_insight': {
          try {
            const { alertId, reason } = toolInput;

            const alert = await this.prisma.agentAlert.findFirst({
              where: { id: alertId, userId },
            });

            if (!alert) {
              return { success: false, error: 'Alert not found or access denied.' };
            }

            await this.prisma.agentAlert.update({
              where: { id: alertId },
              data: {
                status: 'DISMISSED',
                dismissedAt: new Date(),
                dismissedBy: userId,
                metadata: {
                  ...((alert as any).metadata || {}),
                  dismissReason: reason,
                },
              },
            });

            return {
              success: true,
              message: 'Insight dismissed. I\'ll learn from this to give you better recommendations.',
            };
          } catch (error) {
            this.logger.error(`Failed to dismiss insight: ${error.message}`, error.stack);
            return { success: false, error: `Failed to dismiss insight: ${error.message}` };
          }
        }

        // Video Coaching Tools (MVP #2 Enhancement)
        case 'list_coaching_sessions': {
          try {
            const { scenario, status, limit } = toolInput;
            const where: any = { userId };

            if (scenario) where.scenario = scenario;
            if (status) where.status = status;

            const sessions = await this.prisma.coachingSession.findMany({
              where,
              orderBy: { createdAt: 'desc' },
              take: limit || 10,
              select: {
                id: true,
                title: true,
                scenario: true,
                status: true,
                overallScore: true,
                durationSeconds: true,
                createdAt: true,
              },
            });

            if (sessions.length === 0) {
              return {
                success: true,
                message: 'You haven\'t recorded any coaching sessions yet. Would you like to start a practice session?',
                sessions: [],
                tip: 'Record a practice pitch, discovery call, or objection handling session to get AI feedback on your sales skills.',
              };
            }

            return {
              success: true,
              totalSessions: sessions.length,
              sessions: sessions.map((s: any) => ({
                id: s.id,
                title: s.title || this.formatScenarioName(s.scenario),
                scenario: s.scenario,
                status: s.status,
                score: s.overallScore,
                duration: s.durationSeconds ? `${Math.floor(s.durationSeconds / 60)}m ${s.durationSeconds % 60}s` : null,
                date: s.createdAt.toISOString().split('T')[0],
              })),
            };
          } catch (error) {
            this.logger.error(`Failed to list coaching sessions: ${error.message}`, error.stack);
            return { success: false, error: `Failed to list sessions: ${error.message}` };
          }
        }

        case 'get_coaching_session': {
          try {
            const { sessionId } = toolInput;

            const session = await this.prisma.coachingSession.findFirst({
              where: { id: sessionId, userId },
            });

            if (!session) {
              return { success: false, error: 'Coaching session not found.' };
            }

            const feedback = session.feedback as any;

            return {
              success: true,
              session: {
                id: session.id,
                title: session.title || this.formatScenarioName(session.scenario),
                scenario: session.scenario,
                status: session.status,
                overallScore: session.overallScore,
                duration: session.durationSeconds ? `${Math.floor(session.durationSeconds / 60)}m ${session.durationSeconds % 60}s` : null,
                date: session.createdAt.toISOString(),
                transcription: session.transcription,
                feedback: feedback ? {
                  overallAssessment: feedback.overallAssessment,
                  strengths: feedback.strengths,
                  areasForImprovement: feedback.areasForImprovement,
                  scores: feedback.scores,
                  recommendations: feedback.recommendations,
                  suggestedPhrases: feedback.suggestedPhrases,
                } : null,
              },
            };
          } catch (error) {
            this.logger.error(`Failed to get coaching session: ${error.message}`, error.stack);
            return { success: false, error: `Failed to get session: ${error.message}` };
          }
        }

        case 'get_coaching_progress': {
          try {
            const sessions = await this.prisma.coachingSession.findMany({
              where: { userId, status: 'COMPLETED' },
              orderBy: { createdAt: 'desc' },
              take: 50,
            });

            const totalSessions = await this.prisma.coachingSession.count({ where: { userId } });

            if (sessions.length === 0) {
              return {
                success: true,
                message: 'No completed coaching sessions yet. Start practicing to track your progress!',
                totalSessions: 0,
                completedSessions: 0,
              };
            }

            // Calculate metrics
            const scores = sessions.filter((s: any) => s.overallScore !== null).map((s: any) => s.overallScore as number);
            const averageScore = scores.length > 0
              ? Math.round(scores.reduce((a, b) => a + b, 0) / scores.length)
              : 0;

            // Calculate trend
            let trend: 'improving' | 'stable' | 'declining' = 'stable';
            if (scores.length >= 3) {
              const recentAvg = scores.slice(0, 3).reduce((a, b) => a + b, 0) / 3;
              const olderAvg = scores.slice(3, 6).reduce((a, b) => a + b, 0) / Math.min(scores.length - 3, 3);
              if (scores.length > 3 && recentAvg > olderAvg + 5) trend = 'improving';
              else if (scores.length > 3 && recentAvg < olderAvg - 5) trend = 'declining';
            }

            // Extract common strengths/areas
            const strengthsMap: Record<string, number> = {};
            const areasMap: Record<string, number> = {};
            for (const session of sessions) {
              const feedback = session.feedback as any;
              if (feedback) {
                for (const s of feedback.strengths || []) strengthsMap[s] = (strengthsMap[s] || 0) + 1;
                for (const a of feedback.areasForImprovement || []) areasMap[a] = (areasMap[a] || 0) + 1;
              }
            }

            return {
              success: true,
              progress: {
                totalSessions,
                completedSessions: sessions.length,
                averageScore,
                trend,
                topStrengths: Object.entries(strengthsMap).sort((a, b) => b[1] - a[1]).slice(0, 3).map(([s]) => s),
                focusAreas: Object.entries(areasMap).sort((a, b) => b[1] - a[1]).slice(0, 3).map(([a]) => a),
                trendMessage: trend === 'improving' ? 'Great work! Your scores are improving.' :
                  trend === 'declining' ? 'Scores have dipped recently. Let\'s practice more!' :
                  'Consistent performance. Keep practicing to improve!',
              },
            };
          } catch (error) {
            this.logger.error(`Failed to get coaching progress: ${error.message}`, error.stack);
            return { success: false, error: `Failed to get progress: ${error.message}` };
          }
        }

        case 'get_coaching_scenarios': {
          return {
            success: true,
            scenarios: [
              { value: 'ELEVATOR_PITCH', name: 'Elevator Pitch', description: 'Practice your 30-60 second company/product pitch' },
              { value: 'DISCOVERY_CALL', name: 'Discovery Call', description: 'Practice uncovering prospect needs and challenges' },
              { value: 'DEMO_PRESENTATION', name: 'Demo Presentation', description: 'Practice demonstrating your product' },
              { value: 'OBJECTION_HANDLING', name: 'Objection Handling', description: 'Practice responding to common objections' },
              { value: 'NEGOTIATION', name: 'Negotiation', description: 'Practice discussing pricing and terms' },
              { value: 'CLOSING', name: 'Closing', description: 'Practice asking for the business' },
              { value: 'COLD_CALL', name: 'Cold Call', description: 'Practice cold outreach calls' },
              { value: 'FOLLOW_UP', name: 'Follow-up Call', description: 'Practice follow-up conversations' },
              { value: 'GENERAL_PRACTICE', name: 'General Practice', description: 'Open practice session' },
            ],
            tip: 'To start a practice session, go to the Coaching section in the app and record yourself. I\'ll analyze your delivery and provide personalized feedback!',
          };
        }

        // AI Generated Code by Deloitte + Cursor (BEGIN)
        case 'start_coaching_session': {
          try {
            const { scenario } = toolInput;
            const scenarioName = scenario ? scenario.replace(/_/g, ' ').toLowerCase() : 'general practice';
            
            return {
              success: true,
              message: `Great! Let's practice your ${scenarioName}. Here's how to get started:`,
              instructions: [
                '1. Navigate to the "Performance Lab" section in the app',
                '2. Click on the "Practice" tab',
                '3. Select the scenario you want to practice',
                '4. Click "Launch Session" to start recording',
                '5. Practice your pitch/conversation',
                '6. Stop recording when done',
                '7. I\'ll analyze your delivery and provide detailed feedback with scores!',
              ],
              tip: scenario === 'ELEVATOR_PITCH' 
                ? 'For elevator pitches, aim for 30-60 seconds. Focus on your hook, value proposition, and call to action!'
                : scenario === 'OBJECTION_HANDLING'
                ? 'Remember: Acknowledge, clarify, respond. Never dismiss objections - understand them first!'
                : 'Stay confident, speak clearly, and remember to practice regularly for best results!',
            };
          } catch (error) {
            this.logger.error(`Failed to start coaching session: ${error.message}`, error.stack);
            return { success: false, error: `Failed to guide session start: ${error.message}` };
          }
        }

        case 'compare_coaching_sessions': {
          try {
            const { sessionIds, scenario, limit } = toolInput;
            
            // Get sessions to compare
            let sessionsToCompare;
            if (sessionIds && sessionIds.length > 0) {
              sessionsToCompare = await this.prisma.coachingSession.findMany({
                where: { id: { in: sessionIds }, userId },
                orderBy: { createdAt: 'asc' },
              });
            } else {
              // Get recent sessions for comparison
              const where: any = { userId, status: 'COMPLETED' };
              if (scenario) where.scenario = scenario;
              
              sessionsToCompare = await this.prisma.coachingSession.findMany({
                where,
                orderBy: { createdAt: 'desc' },
                take: limit || 3,
              });
            }

            if (sessionsToCompare.length < 2) {
              return {
                success: false,
                error: 'Need at least 2 sessions to compare. Keep practicing!',
              };
            }

            // Calculate comparison metrics
            const comparison = sessionsToCompare.map((session, index) => ({
              sessionNumber: index + 1,
              date: session.createdAt.toLocaleDateString(),
              scenario: session.scenario,
              score: session.overallScore,
              duration: session.durationSeconds ? `${Math.round(session.durationSeconds / 60)}min` : 'N/A',
            }));

            const scores = sessionsToCompare.map(s => s.overallScore).filter(s => s !== null);
            const avgScore = scores.length > 0 ? scores.reduce((a, b) => a + b, 0) / scores.length : 0;
            const improvement = scores.length >= 2 ? scores[scores.length - 1] - scores[0] : 0;
            const trend = improvement > 5 ? 'improving' : improvement < -5 ? 'declining' : 'stable';

            return {
              success: true,
              comparison,
              analysis: {
                averageScore: Math.round(avgScore),
                improvement: Math.round(improvement),
                trend,
                message: trend === 'improving' 
                  ? `Excellent! You've improved by ${Math.round(improvement)} points. Keep up the great work!`
                  : trend === 'declining'
                  ? `Scores have dropped by ${Math.abs(Math.round(improvement))} points. Let's identify what changed and practice more.`
                  : `Consistent performance at ${Math.round(avgScore)}%. Practice regularly to push higher!`,
              },
            };
          } catch (error) {
            this.logger.error(`Failed to compare sessions: ${error.message}`, error.stack);
            return { success: false, error: `Failed to compare sessions: ${error.message}` };
          }
        }

        case 'generate_coaching_agenda': {
          try {
            const { timeframe, focusAreas } = toolInput;
            
            // Get user's recent performance
            const recentSessions = await this.prisma.coachingSession.findMany({
              where: { userId, status: 'COMPLETED' },
              orderBy: { createdAt: 'desc' },
              take: 20,
            });

            // Analyze weak areas
            const scoresByScenario: Record<string, number[]> = {};
            const feedbackAreas: Record<string, number> = {};
            
            recentSessions.forEach(session => {
              if (!scoresByScenario[session.scenario]) {
                scoresByScenario[session.scenario] = [];
              }
              if (session.overallScore) {
                scoresByScenario[session.scenario].push(session.overallScore);
              }
              
              const feedback = session.feedback as any;
              if (feedback && feedback.areasForImprovement) {
                feedback.areasForImprovement.forEach((area: string) => {
                  feedbackAreas[area] = (feedbackAreas[area] || 0) + 1;
                });
              }
            });

            // Identify lowest scoring scenarios
            const scenarioAverages = Object.entries(scoresByScenario).map(([scenario, scores]) => ({
              scenario,
              averageScore: scores.reduce((a, b) => a + b, 0) / scores.length,
              sessionCount: scores.length,
            })).sort((a, b) => a.averageScore - b.averageScore);

            // Top 3 focus areas
            const topWeakAreas = Object.entries(feedbackAreas)
              .sort((a, b) => b[1] - a[1])
              .slice(0, 3)
              .map(([area]) => area);

            // Generate agenda
            const agenda = {
              timeframe: timeframe || 'this_week',
              sessions: [
                {
                  day: 'Monday',
                  scenario: scenarioAverages[0]?.scenario || 'ELEVATOR_PITCH',
                  focus: topWeakAreas[0] || 'Overall delivery',
                  duration: '15-20 minutes',
                  priority: 'high',
                },
                {
                  day: 'Wednesday',
                  scenario: scenarioAverages[1]?.scenario || 'OBJECTION_HANDLING',
                  focus: topWeakAreas[1] || 'Confidence and clarity',
                  duration: '15-20 minutes',
                  priority: 'high',
                },
                {
                  day: 'Friday',
                  scenario: scenarioAverages[2]?.scenario || 'DEMO_PRESENTATION',
                  focus: topWeakAreas[2] || 'Pacing and engagement',
                  duration: '15-20 minutes',
                  priority: 'medium',
                },
              ],
              keyAreas: topWeakAreas,
              recommendation: scenarioAverages.length > 0
                ? `Focus on ${scenarioAverages[0].scenario.replace(/_/g, ' ').toLowerCase()} - your current average is ${Math.round(scenarioAverages[0].averageScore)}%. Let's get it to 85+!`
                : 'Start with elevator pitch practice to build confidence and establish a baseline.',
            };

            return {
              success: true,
              agenda,
              message: `I've created a personalized coaching agenda for ${timeframe || 'this week'}. Practice 3 times this week for maximum improvement!`,
            };
          } catch (error) {
            this.logger.error(`Failed to generate coaching agenda: ${error.message}`, error.stack);
            return { success: false, error: `Failed to generate agenda: ${error.message}` };
          }
        }
        // AI Generated Code by Deloitte + Cursor (END)

        default:
          return {
            success: false,
            error: `Unknown tool: ${toolName}`,
          };
      }
    } catch (error) {
      this.logger.error(`Tool execution failed: ${error.message}`, error.stack);
      return {
        success: false,
        error: error.message,
      };
    }
  }

  /**
   * Format coaching scenario name for display
   */
  private formatScenarioName(scenario: string): string {
    const names: Record<string, string> = {
      ELEVATOR_PITCH: 'Elevator Pitch',
      DISCOVERY_CALL: 'Discovery Call',
      DEMO_PRESENTATION: 'Demo Presentation',
      OBJECTION_HANDLING: 'Objection Handling',
      NEGOTIATION: 'Negotiation',
      CLOSING: 'Closing',
      COLD_CALL: 'Cold Call',
      FOLLOW_UP: 'Follow-up Call',
      GENERAL_PRACTICE: 'General Practice',
    };
    return names[scenario] || scenario;
  }

  /**
   * Get default fields for common Salesforce objects
   */
  private getDefaultFields(objectType: string): string {
    const defaultFields: Record<string, string> = {
      Lead: 'Id, FirstName, LastName, Company, Email, Phone, Title, Status, LeadSource, Industry, Rating, CreatedDate',
      Contact: 'Id, FirstName, LastName, AccountId, Email, Phone, Title, Department, CreatedDate',
      Account: 'Id, Name, Type, Industry, Phone, Website, AnnualRevenue, NumberOfEmployees, CreatedDate',
      Opportunity: 'Id, Name, AccountId, Amount, StageName, Probability, CloseDate, Type, LeadSource, CreatedDate',
      Task: 'Id, Subject, WhoId, WhatId, ActivityDate, Status, Priority, Description, Type, CreatedDate',
      Case: 'Id, Subject, Description, Status, Priority, Origin, Type, CreatedDate',
      // Event does NOT have a Type field - use Subject instead
      Event: 'Id, Subject, StartDateTime, EndDateTime, WhoId, WhatId, Location, Description, CreatedDate',
    };
    return defaultFields[objectType] || 'Id, Name, CreatedDate';
  }

  /**
   * Salesforce system fields that cannot be updated via API
   */
  private readonly SF_SYSTEM_FIELDS = [
    'Id', 'CreatedDate', 'CreatedById', 'LastModifiedDate', 'LastModifiedById', 
    'SystemModstamp', 'IsDeleted', 'attributes', 'OwnerId'
  ];

  /**
   * Filter out system fields and null/undefined values from Salesforce data
   * Accepts any fields dynamically - works with standard and custom fields
   */
  private filterSalesforceFields(data: Record<string, any>, excludeKeys: string[] = []): Record<string, any> {
    const filtered: Record<string, any> = {};
    const allExcluded = [...this.SF_SYSTEM_FIELDS, ...excludeKeys];

    for (const [key, value] of Object.entries(data)) {
      if (value !== undefined && value !== null && !allExcluded.includes(key)) {
        filtered[key] = value;
      }
    }
    return filtered;
  }

  // =============================================================================
  // IRIS RANK HELPER METHODS
  // =============================================================================

  /**
   * Build SOQL query for IRISRank entity retrieval
   */
  private buildRankQuerySOQL(entityType: 'Lead' | 'Contact' | 'Account' | 'Opportunity'): string {
    const queries: Record<string, string> = {
      Lead: `SELECT Id, Name, Company, Status, LeadSource, Rating, Email, Phone, CreatedDate, LastModifiedDate, LastActivityDate
             FROM Lead WHERE IsConverted = false ORDER BY LastActivityDate DESC NULLS LAST LIMIT 100`,
      Contact: `SELECT Id, Name, AccountId, Email, Phone, Title, CreatedDate, LastModifiedDate, LastActivityDate
                FROM Contact ORDER BY LastActivityDate DESC NULLS LAST LIMIT 100`,
      Account: `SELECT Id, Name, Type, Industry, AnnualRevenue, NumberOfEmployees, CreatedDate, LastModifiedDate, LastActivityDate
                FROM Account ORDER BY LastActivityDate DESC NULLS LAST LIMIT 100`,
      Opportunity: `SELECT Id, Name, AccountId, Amount, StageName, Probability, CloseDate, IsClosed, IsWon, CreatedDate, LastModifiedDate, LastActivityDate
                    FROM Opportunity WHERE IsClosed = false ORDER BY Amount DESC NULLS LAST LIMIT 100`,
    };
    return queries[entityType] || queries.Lead;
  }

  /**
   * Convert Salesforce records to CRMEntity format for IRISRank
   * Now includes real relationship data from Salesforce
   */
  private async convertToCRMEntities(
    userId: string,
    records: any[],
    entityType: 'Lead' | 'Contact' | 'Account' | 'Opportunity'
  ): Promise<CRMEntity[]> {
    const entities: CRMEntity[] = [];
    const recordIds = records.map(r => r.Id);

    // Build a map of all record IDs for connection lookups
    const recordIdSet = new Set(recordIds);

    // Query relationships based on entity type
    let relationships: Map<string, Array<{ targetId: string; targetType: string; relationshipType: string; createdDate: Date }>> = new Map();

    try {
      if (entityType === 'Contact' || entityType === 'Opportunity') {
        // Contacts and Opportunities connect to Accounts
        for (const record of records) {
          if (record.AccountId) {
            const conns = relationships.get(record.Id) || [];
            conns.push({
              targetId: record.AccountId,
              targetType: 'Account',
              relationshipType: entityType === 'Contact' ? 'works_at' : 'associated_to',
              createdDate: new Date(record.CreatedDate),
            });
            relationships.set(record.Id, conns);
          }
        }
      }

      // For Leads, create connections based on Company (same company = related)
      // This is crucial for PageRank to work - leads from same company are connected
      if (entityType === 'Lead') {
        const companyMap = new Map<string, string[]>(); // company -> leadIds
        const sourceMap = new Map<string, string[]>(); // source -> leadIds

        for (const record of records) {
          // Group by company
          if (record.Company) {
            const companyKey = record.Company.toLowerCase().trim();
            const leads = companyMap.get(companyKey) || [];
            leads.push(record.Id);
            companyMap.set(companyKey, leads);
          }
          // Group by lead source
          if (record.LeadSource) {
            const leads = sourceMap.get(record.LeadSource) || [];
            leads.push(record.Id);
            sourceMap.set(record.LeadSource, leads);
          }
        }

        // Create bidirectional connections between leads from same company
        for (const [company, leadIds] of companyMap) {
          if (leadIds.length > 1) {
            for (let i = 0; i < leadIds.length; i++) {
              for (let j = i + 1; j < leadIds.length; j++) {
                // Connect lead i to lead j
                const connsI = relationships.get(leadIds[i]) || [];
                connsI.push({
                  targetId: leadIds[j],
                  targetType: 'Lead',
                  relationshipType: 'related_to', // Same company relationship
                  createdDate: new Date(),
                });
                relationships.set(leadIds[i], connsI);

                // Connect lead j to lead i (bidirectional)
                const connsJ = relationships.get(leadIds[j]) || [];
                connsJ.push({
                  targetId: leadIds[i],
                  targetType: 'Lead',
                  relationshipType: 'related_to',
                  createdDate: new Date(),
                });
                relationships.set(leadIds[j], connsJ);
              }
            }
          }
        }

        // Create weaker connections between leads from same source (marketing cohort)
        for (const [source, leadIds] of sourceMap) {
          if (leadIds.length > 1 && leadIds.length <= 20) { // Only for reasonable cohort sizes
            for (let i = 0; i < leadIds.length; i++) {
              for (let j = i + 1; j < leadIds.length; j++) {
                const connsI = relationships.get(leadIds[i]) || [];
                // Only add if not already connected via company
                if (!connsI.some(c => c.targetId === leadIds[j])) {
                  connsI.push({
                    targetId: leadIds[j],
                    targetType: 'Lead',
                    relationshipType: 'partner_of', // Same source = marketing cohort
                    createdDate: new Date(),
                  });
                  relationships.set(leadIds[i], connsI);
                }
              }
            }
          }
        }
      }

      // Query related tasks/activities for engagement signals (for all entity types)
      if (recordIds.length > 0 && recordIds.length <= 100) {
        const taskSoql = `SELECT WhoId, WhatId, Status, CreatedDate FROM Task WHERE (WhoId IN ('${recordIds.join("','")}') OR WhatId IN ('${recordIds.join("','")}')) AND CreatedDate >= LAST_N_DAYS:90 ORDER BY CreatedDate DESC LIMIT 200`;
        try {
          const taskResult = await this.salesforceService.query(userId, taskSoql);
          if (taskResult?.records) {
            for (const task of taskResult.records) {
              const entityId = task.WhoId || task.WhatId;
              if (entityId && recordIdSet.has(entityId)) {
                const conns = relationships.get(entityId) || [];
                // Tasks create implicit relationships
                if (task.WhatId && task.WhatId !== entityId && recordIdSet.has(task.WhatId)) {
                  conns.push({
                    targetId: task.WhatId,
                    targetType: 'Related',
                    relationshipType: 'associated_to',
                    createdDate: new Date(task.CreatedDate),
                  });
                }
                relationships.set(entityId, conns);
              }
            }
          }
        } catch (e) {
          this.logger.debug(`Task query failed (non-critical): ${e.message}`);
        }
      }
    } catch (e) {
      this.logger.warn(`Relationship query failed: ${e.message}`);
    }

    for (const record of records) {
      // Build activity signals from Salesforce data
      const activities: EntityActivity[] = [];

      // Check LastActivityDate to infer recent activity
      if (record.LastActivityDate) {
        const lastActivity = new Date(record.LastActivityDate);
        const daysSince = (Date.now() - lastActivity.getTime()) / (1000 * 60 * 60 * 24);

        if (daysSince < 7) {
          activities.push({
            type: 'task_completed',
            date: lastActivity,
            outcome: 'positive',
          });
        } else if (daysSince > 30) {
          activities.push({
            type: 'task_overdue',
            date: lastActivity,
            outcome: 'negative',
          });
        }
      }

      // Add entity-specific signals
      if (entityType === 'Lead') {
        if (record.Rating === 'Hot') {
          activities.push({
            type: 'email_replied',
            date: new Date(record.LastModifiedDate || record.CreatedDate),
            outcome: 'positive',
          });
        }
        if (record.Status === 'Working - Contacted') {
          activities.push({
            type: 'call_answered',
            date: new Date(record.LastModifiedDate || record.CreatedDate),
            outcome: 'positive',
          });
        }
      } else if (entityType === 'Opportunity') {
        if (record.Probability > 70) {
          activities.push({
            type: 'stage_advanced',
            date: new Date(record.LastModifiedDate || record.CreatedDate),
            outcome: 'positive',
          });
        }
        if (record.IsWon) {
          activities.push({
            type: 'deal_won',
            date: new Date(record.CloseDate || record.LastModifiedDate),
            outcome: 'positive',
          });
        }
        if (record.IsClosed && !record.IsWon) {
          activities.push({
            type: 'deal_lost',
            date: new Date(record.CloseDate || record.LastModifiedDate),
            outcome: 'negative',
          });
        }
      } else if (entityType === 'Contact') {
        // Contacts with recent modifications show engagement
        const daysSinceModified = (Date.now() - new Date(record.LastModifiedDate).getTime()) / (1000 * 60 * 60 * 24);
        if (daysSinceModified < 14) {
          activities.push({
            type: 'meeting_attended',
            date: new Date(record.LastModifiedDate),
            outcome: 'positive',
          });
        }
      }

      // Get connections for this entity
      const entityConnections = relationships.get(record.Id) || [];

      // Build connection objects with proper structure
      const connections = entityConnections.map(c => ({
        targetId: c.targetId,
        targetType: c.targetType,
        relationshipType: c.relationshipType,
        createdDate: c.createdDate,
        strength: 1.0,
      }));

      entities.push({
        id: record.Id,
        type: entityType as any,
        name: record.Name || `${record.FirstName} ${record.LastName}` || 'Unknown',
        properties: { ...record },
        connections,
        activities,
        createdDate: new Date(record.CreatedDate),
        lastModifiedDate: new Date(record.LastModifiedDate || record.CreatedDate),
      });
    }

    this.logger.log(`Converted ${entities.length} ${entityType} records with ${entities.reduce((sum, e) => sum + e.connections.length, 0)} connections and ${entities.reduce((sum, e) => sum + e.activities.length, 0)} activity signals`);
    return entities;
  }

  private generateTitle(message: string) {
    // Strip document search mode prefix before generating title
    const cleanMessage = message.replace(/^\[DOCUMENT_SEARCH_MODE\]\s*/i, '');
    const words = cleanMessage.split(' ').slice(0, 6).join(' ');
    return words.length > 50 ? `${words.slice(0, 50)}...` : words;
  }

  async deleteConversation(conversationId: string, userId: string, isAdmin?: boolean) {
    const where: any = { id: conversationId };
    if (!isAdmin) {
      where.userId = userId;
    }
    const conversation = await this.prisma.conversation.findFirst({
      where,
    });

    if (!conversation) {
      throw new NotFoundException('Conversation not found');
    }

    // Delete will cascade to messages, artifacts, files, and tags
    await this.prisma.conversation.delete({
      where: { id: conversationId },
    });

    return { success: true, message: 'Conversation deleted successfully' };
  }

  async updateConversation(
    conversationId: string,
    data: { title?: string; isPinned?: boolean; isStarred?: boolean },
    userId: string,
    isAdmin?: boolean,
  ) {
    const where: any = { id: conversationId };
    if (!isAdmin) {
      where.userId = userId;
    }

    const conversation = await this.prisma.conversation.findFirst({
      where,
    });

    if (!conversation) {
      throw new NotFoundException('Conversation not found');
    }

    return this.prisma.conversation.update({
      where: { id: conversationId },
      data: {
        ...(data.title !== undefined && { title: data.title }),
        ...(data.isPinned !== undefined && { isPinned: data.isPinned }),
        ...(data.isStarred !== undefined && { isStarred: data.isStarred }),
      },
    });
  }

  async deleteAllConversations(userId: string) {
    const result = await this.prisma.conversation.deleteMany({
      where: { userId },
    });

    return { success: true, message: `Deleted ${result.count} conversations` };
  }

  /**
   * Extract metadata from user message using LLM
   * This is much more accurate than regex-based extraction for company names and artifact detection
   */
  async extractMetadata(userMessage: string, aiResponse?: string) {
    return this.aiSdk.extractMetadata(userMessage, aiResponse);
  }

  /**
   * AI-powered follow-up suggestion generator
   * Uses Claude to generate contextually relevant and meaningful follow-up questions
   * based on the actual conversation content
   *
   * @param structuredData - Optional array of structured data items (tables/charts with actual record data)
   *                         This is CRITICAL for preventing hallucination - the LLM can only reference
   *                         names that actually exist in this data.
   */
  private async generateFollowUpsAsync(
    userMessage: string,
    assistantMessage: string,
    isDocumentMode: boolean = false,
    structuredData?: Array<{ type: string; data: any[]; title?: string }>
  ): Promise<string[]> {
    // PERFORMANCE: Uses fast model (Haiku) for follow-up generation - much faster than Sonnet
    try {
      // Truncate messages for efficiency (keep last 500 chars of each)
      const truncatedUser = userMessage.length > 500 ? userMessage.slice(-500) : userMessage;
      const truncatedAssistant = assistantMessage.length > 1500 ? assistantMessage.slice(-1500) : assistantMessage;

      const contextType = isDocumentMode ? 'document search/analysis' : 'CRM (sales leads, opportunities, accounts, tasks)';

      // ANTI-HALLUCINATION: Extract ONLY the actual record names from structured data
      // This gives the LLM a concrete list of entities it CAN reference
      let actualRecordNames = '';
      if (structuredData && structuredData.length > 0) {
        const recordNames: string[] = [];
        for (const item of structuredData) {
          if (item.data && Array.isArray(item.data)) {
            for (const record of item.data.slice(0, 10)) { // Limit to first 10 records
              // Extract name-like fields from the record
              const name = record.Name || record.name || record.Subject || record.subject ||
                           record.Title || record.title || record.Company || record.company;
              if (name && typeof name === 'string' && name.length > 0) {
                recordNames.push(name);
              }
            }
          }
        }
        if (recordNames.length > 0) {
          actualRecordNames = `\n\n**ACTUAL RECORD NAMES FROM DATA (you may ONLY reference these exact names):**\n${recordNames.map(n => `- "${n}"`).join('\n')}`;
        } else {
          actualRecordNames = '\n\n**NO SPECIFIC RECORD NAMES AVAILABLE - use generic suggestions only**';
        }
      }

      const prompt = `Based on this conversation, suggest exactly 3 follow-up questions the user might want to ask next.

Context: This is a ${contextType} assistant.

User asked: "${truncatedUser}"

Assistant responded: "${truncatedAssistant}"${actualRecordNames}

Rules for generating follow-ups:
1. Each follow-up must be directly relevant to the SPECIFIC content in the response
2. ONLY reference entities (names, companies, records) that are EXPLICITLY listed in the ACTUAL RECORD NAMES section above - NEVER invent names
3. If no specific record names are provided above, suggest GENERIC actions only (e.g., "View details", "Create a task", "Export data")
4. If the response says "no records found" or shows empty results, suggest GENERIC actions only
5. Keep each suggestion under 60 characters
6. Make suggestions actionable but SAFE - prefer generic actions over specific record names if unsure
7. For documents: ask about specific sections, terms, or data points mentioned
8. For CRM: suggest related actions like creating tasks, viewing details, or filtering records
9. CRITICAL: If a name is NOT in the ACTUAL RECORD NAMES list above, DO NOT use it

Respond with ONLY a JSON array of exactly 3 strings, no explanation:
["suggestion 1", "suggestion 2", "suggestion 3"]`;

      // PERFORMANCE: Use fast model (Haiku) for follow-up generation - 5-10x faster
      const response = await this.anthropic.generateFastCompletion({
        messages: [
          { role: 'user', content: prompt }
        ],
        temperature: 0.7,
        maxTokens: 200,
      });

      // Parse the JSON response
      const jsonMatch = response.match(/\[[\s\S]*?\]/);
      if (jsonMatch) {
        const suggestions = JSON.parse(jsonMatch[0]);
        if (Array.isArray(suggestions) && suggestions.length >= 1) {
          // Clean and validate suggestions
          return suggestions
            .slice(0, 3)
            .map((s: any) => String(s).trim())
            .filter((s: string) => s.length > 5 && s.length < 100);
        }
      }

      // Fallback if parsing fails
      return this.generateFallbackFollowUps(userMessage, assistantMessage, isDocumentMode);
    } catch (error) {
      this.logger.warn(`AI follow-up generation failed: ${error.message}, using fallback`);
      return this.generateFallbackFollowUps(userMessage, assistantMessage, isDocumentMode);
    }
  }

  /**
   * Fast synchronous fallback for follow-up generation
   * Used when AI generation fails or for streaming where we need immediate response
   */
  private generateFallbackFollowUps(userMessage: string, assistantMessage: string, isDocumentMode: boolean = false): string[] {
    const lowerAssistant = assistantMessage.toLowerCase();

    // Extract potential entities from the response for more specific suggestions
    const nameMatch = assistantMessage.match(/\b([A-Z][a-z]+ [A-Z][a-z]+)\b/);
    const companyMatch = assistantMessage.match(/(?:at |from |with )([A-Z][A-Za-z]+(?: [A-Z][A-Za-z]+)*(?:\s*(?:Inc|Corp|LLC|Ltd))?)/);
    const amountMatch = assistantMessage.match(/\$[\d,]+(?:\.\d{2})?|\d+[KMB]\b/);

    if (isDocumentMode) {
      // Document-specific fallbacks based on content
      if (lowerAssistant.includes('table') || lowerAssistant.includes('data')) {
        return [
          'Export this data to a summary',
          'What are the key trends in this data?',
          'Compare these figures to other sections'
        ];
      }
      if (lowerAssistant.includes('section') || lowerAssistant.includes('clause')) {
        return [
          'What are the implications of this clause?',
          'Are there related sections I should review?',
          'Summarize the key obligations here'
        ];
      }
      return [
        'What are the most critical points?',
        'Are there any risks or concerns mentioned?',
        'Extract all dates and deadlines'
      ];
    }

    // CRM-specific fallbacks with entity references
    if (nameMatch && companyMatch) {
      return [
        `Show all activities with ${nameMatch[1]}`,
        `Create a follow-up task for ${companyMatch[1]}`,
        `What's the deal history with ${companyMatch[1]}?`
      ];
    }

    if (amountMatch) {
      return [
        `Show opportunities over ${amountMatch[0]}`,
        `What's the win rate for deals this size?`,
        `Create tasks for high-value opportunities`
      ];
    }

    if (lowerAssistant.includes('lead')) {
      return [
        'Which of these leads should I prioritize?',
        'Create outreach tasks for top leads',
        'Show lead conversion trends'
      ];
    }

    if (lowerAssistant.includes('opportunit') || lowerAssistant.includes('deal')) {
      return [
        'What actions will help close these deals?',
        'Show deals at risk of slipping',
        'Create closing tasks for this week'
      ];
    }

    if (lowerAssistant.includes('task')) {
      return [
        'Which tasks are highest priority?',
        'Show overdue tasks',
        'What is blocking task completion?'
      ];
    }

    // Generic but actionable
    return [
      'What should I focus on today?',
      'Show my pipeline health',
      'Create an action plan for this week'
    ];
  }

  /**
   * Synchronous wrapper that returns fallback immediately
   * The actual AI suggestions are generated async and could be used for future updates
   */
  private generateFollowUps(userMessage: string, assistantMessage: string, isDocumentMode: boolean = false): string[] {
    // Return smart fallback immediately for sync contexts
    return this.generateFallbackFollowUps(userMessage, assistantMessage, isDocumentMode);
  }

  /**
   * Determine if we should automatically chain to search_document after list_indexed_documents
   * Returns an object with documentId, query, and filename if search should be chained, null otherwise
   */
  private shouldSearchDocumentContent(userMessage: string, documents: any[]): { documentId: string; query: string; filename: string } | null {
    if (!documents || documents.length === 0) return null;

    const lower = userMessage.toLowerCase();

    // Keywords that indicate user wants document content (not just listing)
    const contentIndicators = [
      'what', 'tell me', 'explain', 'describe', 'summarize', 'summary',
      'show me', 'find', 'search', 'look for', 'content', 'information',
      'details', 'about', 'in the', 'from the', 'according to',
      'request', 'proposal', 'requirements', 'specs', 'specifications',
      'how', 'why', 'when', 'where', 'who', 'which',
      'main points', 'key', 'important', 'highlights'
    ];

    // Check if any content indicator is present
    const wantsContent = contentIndicators.some(indicator => lower.includes(indicator));

    // Find the target document
    const targetDoc = this.findTargetDocument(userMessage, documents);

    if (!targetDoc) return null;

    // Check if user mentions any document by name OR wants content
    const mentionsDocument = documents.some(doc => {
      const docName = (doc.filename || doc.document_id || '').toLowerCase();
      const nameParts = docName.replace(/[_\-\.]/g, ' ').split(' ');
      return nameParts.some(part => part.length > 3 && lower.includes(part.toLowerCase()));
    });

    if (wantsContent || mentionsDocument) {
      const query = this.extractSearchQuery(userMessage);
      return {
        documentId: targetDoc.document_id || targetDoc.id,
        filename: targetDoc.filename || targetDoc.document_id,
        query,
      };
    }

    return null;
  }

  /**
   * Find the most relevant document based on user's message
   */
  private findTargetDocument(userMessage: string, documents: any[]): any {
    if (!documents || documents.length === 0) return null;

    const lower = userMessage.toLowerCase();

    // First, try exact or partial name match
    for (const doc of documents) {
      const docName = (doc.filename || doc.document_id || '').toLowerCase();
      const nameParts = docName.replace(/[_\-\.]/g, ' ').split(' ').filter(p => p.length > 2);

      for (const part of nameParts) {
        if (lower.includes(part.toLowerCase())) {
          this.logger.log(`Found document match: "${doc.filename}" via term "${part}"`);
          return doc;
        }
      }
    }

    // If no name match and only one document, use it
    if (documents.length === 1) {
      this.logger.log(`Using only available document: "${documents[0].filename}"`);
      return documents[0];
    }

    // If no match found but user clearly wants document content, use most recent
    // (documents are typically sorted by upload date)
    this.logger.log(`No specific document match, using first document: "${documents[0]?.filename}"`);
    return documents[0];
  }

  /**
   * Extract a search query from the user's message
   */
  private extractSearchQuery(userMessage: string): string {
    const lower = userMessage.toLowerCase();

    // Remove common question words to get the core query
    let query = lower
      .replace(/^(what|tell me|explain|describe|summarize|show me|find|search|look for)\s+(is|are|was|were|about|for|the)?\s*/gi, '')
      .replace(/\s*(in the|from the|according to)\s+\w+(\.\w+)?$/gi, '')
      .replace(/[?!.,]/g, '')
      .trim();

    // If query is too short, use the original message
    if (query.length < 5) {
      query = userMessage.replace(/[?!.,]/g, '').trim();
    }

    this.logger.log(`Extracted search query: "${query}" from message: "${userMessage}"`);
    return query;
  }

  /**
   * Detect structured data type from tool name and data
   */
  private detectStructuredDataType(toolName: string, data: any[]): string | null {
    if (!data || data.length === 0) return null;

    const sample = data[0];

    // Detect based on tool name first (including Salesforce sf_ prefixed tools)
    if (toolName.includes('lead') || toolName === 'sf_create_lead' || toolName === 'sf_update_lead') return 'leads';
    if (toolName.includes('opportunit') || toolName === 'sf_create_opportunity' || toolName === 'sf_update_opportunity') return 'opportunities';
    if (toolName.includes('contact') || toolName === 'sf_create_contact') return 'contacts';
    if ((toolName.includes('account') && !toolName.includes('activity')) || toolName === 'sf_create_account') return 'accounts';
    if (toolName.includes('task') || toolName === 'sf_create_task') return 'tasks';
    if (toolName.includes('activit')) return 'activities';
    
    // For sf_query, detect based on the data fields (Salesforce standard object fields)
    if (toolName === 'sf_query') {
      // Check for Salesforce standard field patterns
      if (sample.StageName !== undefined || sample.Probability !== undefined || sample.CloseDate !== undefined || sample.Amount !== undefined) {
        return 'opportunities';
      }
      if (sample.LeadSource !== undefined || (sample.Company !== undefined && sample.Status !== undefined && !sample.StageName)) {
        return 'leads';
      }
      if (sample.AccountId !== undefined && sample.Email !== undefined && sample.FirstName !== undefined) {
        return 'contacts';
      }
      if (sample.Industry !== undefined || sample.AnnualRevenue !== undefined || sample.NumberOfEmployees !== undefined) {
        return 'accounts';
      }
      if (sample.Subject !== undefined && (sample.Status !== undefined || sample.Priority !== undefined)) {
        return 'tasks';
      }
      if (sample.ActivityDate !== undefined || sample.WhatId !== undefined || sample.WhoId !== undefined) {
        return 'activities';
      }
    }

    // Detect based on data fields (local database patterns)
    if (sample.leadScore !== undefined || sample.score !== undefined || sample.buyingIntent !== undefined) {
      return 'leads';
    }
    if (sample.stage !== undefined || sample.probability !== undefined || sample.closeDate !== undefined) {
      return 'opportunities';
    }
    if (sample.industry !== undefined || sample.employees !== undefined || sample.annualRevenue !== undefined) {
      return 'accounts';
    }
    if (sample.email && sample.phone && sample.firstName) {
      return 'contacts';
    }

    return 'generic';
  }

  /**
   * Get a human-readable title for a table based on tool name
   */
  private getTableTitle(toolName: string, count: number): string {
    const titles: Record<string, string> = {
      'get_top_leads': `Top ${count} Leads`,
      'search_leads': `Lead Search Results`,
      'list_leads': `All Leads`,
      'get_at_risk_opportunities': `At-Risk Opportunities`,
      'list_opportunities': `All Opportunities`,
      'search_opportunities': `Opportunity Search Results`,
      'list_contacts': `All Contacts`,
      'search_contacts': `Contact Search Results`,
      'list_accounts': `All Accounts`,
      'search_accounts': `Account Search Results`,
      'get_all_tasks': `All Tasks`,
      'get_pending_tasks': `Pending Tasks`,
      'list_activities': `Recent Activities`,
      // Salesforce tools
      'sf_query': `Salesforce Query Results (${count} records)`,
      'sf_create_lead': `Lead Created`,
      'sf_update_lead': `Lead Updated`,
      'sf_create_opportunity': `Opportunity Created`,
      'sf_update_opportunity': `Opportunity Updated`,
      'sf_create_contact': `Contact Created`,
      'sf_create_account': `Account Created`,
      'sf_create_task': `Task Created`,
    };

    return titles[toolName] || `${count} Records`;
  }

  /**
   * Extract structured data from AI response text
   * Parses numbered lists with Salesforce record patterns into table data
   * @param text - The AI response text to parse
   * @param userQuery - The original user query for generating meaningful titles
   */
  private extractStructuredDataFromText(text: string, userQuery?: string): { type: string; data: any[]; title: string; visualization: string; columns: any[] } | null {
    if (!text) return null;
    
    const records: any[] = [];
    let objectType = 'Record';
    
    // Detect object type from title/headers
    if (/leads?/i.test(text.substring(0, 200))) objectType = 'Lead';
    else if (/opportunities?|deals?/i.test(text.substring(0, 200))) objectType = 'Opportunity';
    else if (/contacts?/i.test(text.substring(0, 200))) objectType = 'Contact';
    else if (/accounts?/i.test(text.substring(0, 200))) objectType = 'Account';
    else if (/tasks?/i.test(text.substring(0, 200))) objectType = 'Task';
    
    const lines = text.split('\n');
    let currentRecord: any = null;
    
    for (let i = 0; i < lines.length; i++) {
      const line = lines[i].trim();
      
      // Pattern 1: "### 1. **John Bond** - `00QgL000004Xg5OUAS`" (markdown headers with backtick IDs)
      const headerMatch = line.match(/^#{1,4}\s*(\d+)\.\s+\*\*(.+?)\*\*\s*[-â€“â€”]\s*`?(00[A-Za-z0-9]{15,18})`?/);
      if (headerMatch) {
        if (currentRecord && Object.keys(currentRecord).length > 2) {
          records.push(currentRecord);
        }
        currentRecord = {
          _index: parseInt(headerMatch[1]),
          name: headerMatch[2].trim(),
          id: headerMatch[3],
        };
        continue;
      }
      
      // Pattern 2: "1. John Bond - 00QgL000004Xg5OUAS" (simple numbered list)
      const simpleMatch = line.match(/^(\d+)\.\s+\*?\*?([\w\s]+?)\*?\*?\s*[-â€“â€”]\s*`?(00[A-Za-z0-9]{15,18})`?/);
      if (simpleMatch) {
        if (currentRecord && Object.keys(currentRecord).length > 2) {
          records.push(currentRecord);
        }
        currentRecord = {
          _index: parseInt(simpleMatch[1]),
          name: simpleMatch[2].trim(),
          id: simpleMatch[3],
        };
        continue;
      }
      
      // Pattern 3: "1. **Name** - Company" (no ID on main line)
      const nameOnlyMatch = line.match(/^(\d+)\.\s+\*\*(.+?)\*\*/);
      if (nameOnlyMatch && !currentRecord) {
        currentRecord = {
          _index: parseInt(nameOnlyMatch[1]),
          name: nameOnlyMatch[2].trim(),
        };
        continue;
      }
      
      // Parse detail lines under current record (handles "- **Field**: Value" format)
      if (currentRecord) {
        // Company: Grand Hotels (with or without bold/bullet)
        const companyMatch = line.match(/^[-*]?\s*\*?\*?Company\*?\*?:\s*(.+)/i);
        if (companyMatch) {
          currentRecord.company = companyMatch[1].trim();
          continue;
        }
        
        // Status: Open - Not Contacted
        const statusMatch = line.match(/^[-*]?\s*\*?\*?Status\*?\*?:\s*(.+)/i);
        if (statusMatch) {
          currentRecord.status = statusMatch[1].trim();
          continue;
        }
        
        // Source: Web (high intent)
        const sourceMatch = line.match(/^[-*]?\s*\*?\*?Source\*?\*?:\s*(.+)/i);
        if (sourceMatch) {
          currentRecord.source = sourceMatch[1].replace(/\([^)]*\)/g, '').trim();
          continue;
        }
        
        // Created: March 11, 2025 (280 days ago)
        const createdMatch = line.match(/^[-*]?\s*\*?\*?Created\*?\*?:\s*(.+)/i);
        if (createdMatch) {
          currentRecord.created = createdMatch[1].replace(/\([^)]*\)/g, '').trim();
          continue;
        }
        
        // Email: john@example.com
        const emailMatch = line.match(/^[-*]?\s*\*?\*?Email\*?\*?:\s*(.+)/i);
        if (emailMatch) {
          currentRecord.email = emailMatch[1].trim();
          continue;
        }
        
        // Phone: +1234567890
        const phoneMatch = line.match(/^[-*]?\s*\*?\*?Phone\*?\*?:\s*(.+)/i);
        if (phoneMatch) {
          currentRecord.phone = phoneMatch[1].trim();
          continue;
        }
        
        // Amount: $500,000
        const amountMatch = line.match(/^[-*]?\s*\*?\*?(?:Amount|Value)\*?\*?:\s*\$?([\d,]+)/i);
        if (amountMatch) {
          currentRecord.amount = parseFloat(amountMatch[1].replace(/,/g, ''));
          continue;
        }
        
        // Stage: Negotiation
        const stageMatch = line.match(/^[-*]?\s*\*?\*?Stage\*?\*?:\s*(.+)/i);
        if (stageMatch) {
          currentRecord.stage = stageMatch[1].trim();
          continue;
        }
        
        // If we hit a new numbered item or section header, push current record
        if (/^#{1,4}\s*\d+\./.test(line) || /^\d+\.\s+\*?\*?[A-Z]/.test(line) || /^#{1,3}\s+[A-Z]/.test(line)) {
          if (currentRecord && Object.keys(currentRecord).length > 2) {
            records.push(currentRecord);
          }
          currentRecord = null;
        }
      }
    }
    
    // Don't forget the last record
    if (currentRecord && Object.keys(currentRecord).length > 2) {
      records.push(currentRecord);
    }
    
    // Need at least 1 record with meaningful data
    if (records.length === 0 || records.every(r => Object.keys(r).length <= 2)) {
      return null;
    }
    
    // Generate columns based on object type
    let columns: any[] = [];
    if (objectType === 'Lead') {
      columns = [
        { key: 'name', label: 'Name', type: 'text', priority: 1, sortable: true },
        { key: 'company', label: 'Company', type: 'text', priority: 2, sortable: true },
        { key: 'status', label: 'Status', type: 'status', priority: 3, sortable: true },
        { key: 'source', label: 'Source', type: 'text', priority: 4, sortable: true },
        { key: 'created', label: 'Created', type: 'text', priority: 5, sortable: true },
        { key: 'id', label: 'ID', type: 'text', priority: 6, sortable: false },
      ];
    } else if (objectType === 'Opportunity') {
      columns = [
        { key: 'name', label: 'Name', type: 'text', priority: 1, sortable: true },
        { key: 'stage', label: 'Stage', type: 'status', priority: 2, sortable: true },
        { key: 'amount', label: 'Amount', type: 'currency', priority: 3, sortable: true },
        { key: 'created', label: 'Created', type: 'text', priority: 4, sortable: true },
        { key: 'id', label: 'ID', type: 'text', priority: 5, sortable: false },
      ];
    } else if (objectType === 'Contact') {
      columns = [
        { key: 'name', label: 'Name', type: 'text', priority: 1, sortable: true },
        { key: 'email', label: 'Email', type: 'email', priority: 2, sortable: true },
        { key: 'phone', label: 'Phone', type: 'phone', priority: 3, sortable: true },
        { key: 'company', label: 'Company', type: 'text', priority: 4, sortable: true },
        { key: 'id', label: 'ID', type: 'text', priority: 5, sortable: false },
      ];
    } else if (objectType === 'Task') {
      columns = [
        { key: 'name', label: 'Subject', type: 'text', priority: 1, sortable: true },
        { key: 'status', label: 'Status', type: 'status', priority: 2, sortable: true },
        { key: 'created', label: 'Due Date', type: 'text', priority: 3, sortable: true },
        { key: 'id', label: 'ID', type: 'text', priority: 4, sortable: false },
      ];
    } else {
      // Generic columns based on what we found
      const sample = records[0];
      columns = Object.keys(sample)
        .filter(k => k !== '_index')
        .slice(0, 6)
        .map((key, index) => ({
          key,
          label: key.charAt(0).toUpperCase() + key.slice(1),
          type: key === 'email' ? 'email' : key === 'phone' ? 'phone' : key === 'amount' ? 'currency' : 'text',
          priority: index + 1,
          sortable: true,
        }));
    }
    
    // Remove _index from records
    const cleanRecords = records.map(r => {
      const { _index, ...rest } = r;
      return rest;
    });
    
    // Generate meaningful title based on user query or fallback to count + object type
    let title = `${cleanRecords.length} ${objectType}${cleanRecords.length > 1 ? 's' : ''}`;
    if (userQuery) {
      // Try to create a descriptive title from the user's query
      const queryLower = userQuery.toLowerCase();
      
      // Extract key descriptors from query (top, recent, open, etc.)
      const topMatch = queryLower.match(/top\s+(\d+)/i);
      const recentMatch = /recent|latest|newest|last/i.test(queryLower);
      const openMatch = /open|active|pending/i.test(queryLower);
      const closedMatch = /closed|won|lost/i.test(queryLower);
      
      if (topMatch) {
        title = `Top ${topMatch[1]} ${objectType}s`;
      } else if (recentMatch) {
        title = `Recent ${objectType}s`;
      } else if (openMatch) {
        title = `Open ${objectType}s`;
      } else if (closedMatch) {
        title = `Closed ${objectType}s`;
      }
      
      // Try to extract specific qualifiers (Q4, 2024, high priority, etc.)
      const quarterMatch = queryLower.match(/q([1-4])/i);
      const yearMatch = queryLower.match(/20\d{2}/);
      const priorityMatch = /high\s*priority/i.test(queryLower) ? 'High Priority' : null;
      
      // Add qualifiers if found
      const qualifiers = [quarterMatch ? `Q${quarterMatch[1]}` : null, yearMatch ? yearMatch[0] : null, priorityMatch].filter(Boolean);
      if (qualifiers.length > 0) {
        title = `${qualifiers.join(' ')} ${title}`;
      }
    }
    
    return {
      type: 'extracted-from-text',
      data: cleanRecords,
      title,
      visualization: 'table',
      columns,
    };
  }

  /**
   * Clean up AI response when structured data is present
   * Removes redundant numbered/bullet lists that duplicate the data table
   */
  private cleanResponseWithStructuredData(text: string): string {
    if (!text) return text;
    
    // Split into lines for processing
    const lines = text.split('\n');
    const cleanedLines: string[] = [];
    let skipUntilNextSection = false;
    let insideRecordList = false;
    let consecutiveListItems = 0;
    
    for (let i = 0; i < lines.length; i++) {
      const line = lines[i];
      const trimmedLine = line.trim();
      
      // Check if this line is a numbered list item with a Salesforce ID pattern
      // Pattern: "1. Name - 00QgL000..." or "1. **Name** - Company"
      const isNumberedRecordItem = /^\d+\.\s+\*?\*?[\w\s]+\*?\*?\s*[-â€“â€”]\s*(00[A-Za-z0-9]{15,18}|Company:|Status:|Source:|Created:)/i.test(trimmedLine);
      
      // Check for bullet list items that look like record details
      const isBulletRecordItem = /^[-*]\s+(Name|Company|Status|Source|Email|Phone|Stage|Amount|Created|Why Top|Id):/i.test(trimmedLine);
      
      // Check if this is a section header (## or bold text at start)
      const isSectionHeader = /^#{1,3}\s+/.test(trimmedLine) || /^\*\*[^*]+\*\*\s*$/.test(trimmedLine);
      
      // Check if line contains Salesforce ID pattern (indicates record listing)
      const hasSalesforceId = /00[A-Za-z0-9]{13,18}/.test(trimmedLine);
      
      // Detect start of a record listing section
      if (isNumberedRecordItem || (hasSalesforceId && /^\d+\./.test(trimmedLine))) {
        insideRecordList = true;
        consecutiveListItems++;
        continue; // Skip this line
      }
      
      // Skip detail lines under numbered items (indented or starting with detail keywords)
      if (insideRecordList) {
        // Detail line patterns
        const isDetailLine = /^(Company|Status|Source|Email|Phone|Stage|Amount|Created|Why Top|Description|Priority|Due):/i.test(trimmedLine) ||
          isBulletRecordItem ||
          /^\s{2,}/.test(line) || // Indented lines
          trimmedLine === '';
        
        if (isDetailLine && consecutiveListItems > 0) {
          continue; // Skip detail lines
        }
        
        // If we hit a new section or non-detail line, end the record list
        if (isSectionHeader || (!isDetailLine && trimmedLine !== '')) {
          insideRecordList = false;
          consecutiveListItems = 0;
        }
      }
      
      // Skip sections that are clearly just listings (e.g., "## Record Details")
      if (isSectionHeader && /^#{1,3}\s*(Top \d+|Records?|Leads?|Opportunities?|Contacts?|Accounts?|Tasks?|Details?)\s*$/i.test(trimmedLine)) {
        skipUntilNextSection = true;
        continue;
      }
      
      // Reset skip flag when we hit a new valid section
      if (skipUntilNextSection && isSectionHeader && !/^#{1,3}\s*(Top \d+|Records?|Leads?|Opportunities?|Contacts?|Accounts?|Tasks?|Details?)\s*$/i.test(trimmedLine)) {
        skipUntilNextSection = false;
      }
      
      if (skipUntilNextSection) {
        continue;
      }
      
      // Keep this line
      cleanedLines.push(line);
    }
    
    // Join lines and clean up excess whitespace
    let result = cleanedLines.join('\n');
    
    // Remove multiple consecutive blank lines (keep max 2)
    result = result.replace(/\n{3,}/g, '\n\n');
    
    // Remove trailing whitespace
    result = result.trim();
    
    // If we stripped too much, return original (but cleaned of obvious duplicates)
    if (result.length < 50 && text.length > 200) {
      // Try a simpler approach: just extract intro and insights sections
      const introMatch = text.match(/^([\s\S]*?)(?=\n\s*\d+\.\s+)/);
      const insightMatch = text.match(/(\*\*(?:Key\s+)?Insight[s]?\*\*[\s\S]*?)(?=\n\s*\*\*(?:Recommend|Next|Action)|$)/i);
      const recommendMatch = text.match(/(\*\*(?:Recommend|Next|Action|Priority)[^*]*\*\*[\s\S]*?)$/i);
      
      const parts: string[] = [];
      if (introMatch && introMatch[1].trim()) parts.push(introMatch[1].trim());
      if (insightMatch && insightMatch[1].trim()) parts.push(insightMatch[1].trim());
      if (recommendMatch && recommendMatch[1].trim()) parts.push(recommendMatch[1].trim());
      
      if (parts.length > 0) {
        result = parts.join('\n\n');
      }
    }
    
    return result || text;
  }

  /**
   * Check if a tool name matches a data type
   */
  private isToolMatchingDataType(toolName: string, dataType: string): boolean {
    const toolDataTypeMap: Record<string, string[]> = {
      'leads': ['get_top_leads', 'search_leads', 'list_leads', 'create_lead', 'update_lead', 'sf_create_lead', 'sf_update_lead', 'sf_query'],
      'opportunities': ['get_at_risk_opportunities', 'list_opportunities', 'search_opportunities', 'create_opportunity', 'update_opportunity', 'sf_create_opportunity', 'sf_update_opportunity', 'sf_query'],
      'contacts': ['list_contacts', 'search_contacts', 'create_contact', 'update_contact', 'sf_create_contact', 'sf_query'],
      'accounts': ['list_accounts', 'search_accounts', 'create_account', 'update_account', 'sf_create_account', 'sf_query'],
      'tasks': ['get_all_tasks', 'get_pending_tasks', 'create_task', 'update_task', 'complete_task', 'sf_create_task', 'sf_query'],
      'activities': ['list_activities', 'create_activity', 'sf_query'],
      'quote': ['get_quote_details'], // Quote artifact type
      'generic': ['sf_query', 'sf_search', 'search_leads', 'search_contacts', 'search_accounts', 'search_opportunities'], // These can match any type
    };

    const tools = toolDataTypeMap[dataType];
    return tools ? tools.includes(toolName) : false;
  }

  /**
   * Detect best visualization type for structured data
   */
  private detectVisualization(dataType: string, data: any[], toolName: string): string {
    if (!data || data.length === 0) return 'table';
    
    // KPI for very small datasets (1-3 records with numeric values)
    if (data.length <= 3) {
      const sample = data[0];
      const keys = Object.keys(sample);
      const numericKeys = keys.filter(k => typeof sample[k] === 'number');
      if (numericKeys.length >= 1) {
        return 'kpi';
      }
    }
    
    // Cards for small-medium datasets (4-6 records)
    if (data.length >= 4 && data.length <= 6) {
      return 'cards';
    }
    
    // Check for aggregation/summary queries (often have Stage, Status grouping)
    if (toolName === 'sf_query') {
      const sample = data[0];
      // If data looks like grouped counts (e.g., stage + count)
      if (data.length <= 10 && (sample.StageName || sample.Status || sample.LeadSource)) {
        const hasCount = Object.values(sample).some(v => typeof v === 'number' && !String(Object.keys(sample).find(k => sample[k] === v)).includes('Amount'));
        if (hasCount) {
          return 'bar';
        }
      }
    }
    
    // Timeline for activities
    if (dataType === 'activities' || dataType === 'tasks') {
      if (data.length >= 3 && data.length <= 20) {
        return 'timeline';
      }
    }
    
    // Default to table for larger datasets
    return 'table';
  }

  /**
   * Generate column definitions for structured data
   */
  private generateColumns(dataType: string, data: any[]): any[] {
    if (!data || data.length === 0) return [];
    
    const sample = data[0];
    const columns: any[] = [];
    
    // Salesforce field mappings
    const sfFieldTypes: Record<string, { type: string; label: string; sortable?: boolean }> = {
      'Name': { type: 'string', label: 'Name', sortable: true },
      'Amount': { type: 'currency', label: 'Amount', sortable: true },
      'StageName': { type: 'status', label: 'Stage', sortable: true },
      'Probability': { type: 'percentage', label: 'Probability', sortable: true },
      'CloseDate': { type: 'date', label: 'Close Date', sortable: true },
      'Status': { type: 'status', label: 'Status', sortable: true },
      'Priority': { type: 'status', label: 'Priority' },
      'LeadSource': { type: 'string', label: 'Lead Source' },
      'Industry': { type: 'string', label: 'Industry' },
      'Email': { type: 'string', label: 'Email' },
      'Phone': { type: 'string', label: 'Phone' },
      'Title': { type: 'string', label: 'Title' },
      'Company': { type: 'string', label: 'Company' },
      'AnnualRevenue': { type: 'currency', label: 'Annual Revenue', sortable: true },
      'NumberOfEmployees': { type: 'number', label: 'Employees', sortable: true },
      'CreatedDate': { type: 'date', label: 'Created', sortable: true },
      'LastModifiedDate': { type: 'date', label: 'Modified', sortable: true },
      'OwnerId': { type: 'string', label: 'Owner' },
      'AccountId': { type: 'string', label: 'Account' },
      'Id': { type: 'string', label: 'ID' },
    };
    
    // Build columns from sample data
    for (const key of Object.keys(sample)) {
      // Skip internal Salesforce attributes
      if (key === 'attributes' || key.startsWith('__')) continue;
      
      const fieldConfig = sfFieldTypes[key];
      if (fieldConfig) {
        columns.push({
          key,
          label: fieldConfig.label,
          type: fieldConfig.type,
          sortable: fieldConfig.sortable || false,
        });
      } else {
        // Infer type from value
        const value = sample[key];
        let type = 'string';
        if (typeof value === 'number') {
          type = key.toLowerCase().includes('amount') || key.toLowerCase().includes('revenue') ? 'currency' : 'number';
        } else if (typeof value === 'boolean') {
          type = 'boolean';
        } else if (value && typeof value === 'string') {
          // Check for date patterns
          if (/^\d{4}-\d{2}-\d{2}/.test(value)) {
            type = 'date';
          }
        }
        
        columns.push({
          key,
          label: key.replace(/([A-Z])/g, ' $1').trim(), // CamelCase to Title Case
          type,
          sortable: type === 'number' || type === 'currency' || type === 'date',
        });
      }
    }
    
    return columns;
  }

  /**
   * Public method to execute CRM tools for realtime voice API
   * This allows the RealtimeService to execute tools on behalf of the user
   * @param dataSource - Optional preference: 'salesforce' or 'local'
   */
  async executeRealtimeTool(
    userId: string,
    toolName: string,
    toolInput: Record<string, any>,
    dataSource?: 'salesforce' | 'local',
  ): Promise<any> {
    this.logger.log(`Realtime tool execution: ${toolName}, dataSource: ${dataSource || 'auto'}`);
    try {
      const result = await this.executeTool(toolName, toolInput, userId, dataSource);
      return {
        success: true,
        toolName,
        result,
      };
    } catch (error) {
      this.logger.error(`Realtime tool execution error: ${error.message}`);
      return {
        success: false,
        toolName,
        error: error.message,
      };
    }
  }
}