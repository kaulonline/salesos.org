// This is your Prisma schema file,
// learn more about it in the docs: https://pris.ly/d/prisma-schema

// Looking for ways to speed up your queries, or scale easily with your serverless or edge functions?
// Try Prisma Accelerate: https://pris.ly/cli/accelerate-init

generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

model User {
  id           String     @id @default(cuid())
  email        String     @unique
  passwordHash String
  name         String?
  avatarUrl    String?
  role         UserRole   @default(USER)
  status       UserStatus @default(ACTIVE)
  settings     Json?
  lastLoginAt  DateTime?
  createdAt    DateTime   @default(now())
  updatedAt    DateTime   @updatedAt

  // Core relations
  conversations Conversation[]
  files         UploadedFile[]
  templates     Template[]
  researchJobs  ResearchJob[]

  // Sales CRM relations
  leads         Lead[]
  accounts      Account[]
  contacts      Contact[]
  opportunities Opportunity[]
  tasksOwned    Task[]        @relation("TaskOwner")
  tasksAssigned Task[]        @relation("TaskAssignee")
  activities    Activity[]
  quotes        Quote[]
  contracts     Contract[]
  campaigns     Campaign[]
  notes         Note[]
  products      Product[]

  // RLHF relations
  feedbackEntries FeedbackEntry[]
  preferencePairs PreferencePair[]

  // Meeting Intelligence relations
  meetingSessions       MeetingSession[]
  pendingMeetingActions PendingMeetingAction[]

  // Salesforce Integration
  salesforceConnection SalesforceConnection?

  // Licensing - User license assignments
  userLicenses       UserLicense[]
  claimedLicenseKeys PreGeneratedLicenseKey[] @relation("ClaimedLicenseKeys")

  // Salesforce Package Integration
  salesforcePackageUsers SalesforcePackageUser[] @relation("SalesforcePackageUsers")

  // Device tracking & notifications
  devices       UserDevice[]
  sessions      UserSession[]
  notifications PushNotification[]

  // Support ticket system
  submittedTickets SupportTicket[]             @relation("SubmittedTickets")
  assignedTickets  SupportTicket[]             @relation("AssignedTickets")
  ticketResponses  TicketResponse[]            @relation("TicketResponses")
  reviewedActions  SupportAgentPendingAction[] @relation("SupportAgentActionReviewer")

  // Voice call history
  callHistory CallHistory[] @relation("UserCallHistory")

  // Video Coaching sessions (MVP #2)
  coachingSessions CoachingSession[]

  // Organization membership (enterprise B2B)
  organizationMemberships OrganizationMember[]

  // Team Messaging
  teamChannelMemberships TeamChannelMember[]
  teamMessagesSent       TeamMessage[]
  directConversations1   DirectConversation[] @relation("DirectConversationUser1")
  directConversations2   DirectConversation[] @relation("DirectConversationUser2")

  // Payment & Billing
  billingCustomer BillingCustomer?

  // Quote Documents (uploaded by user)
  quoteDocuments QuoteDocument[]

  // Territories
  territories Territory[]

  // Playbooks
  playbooks Playbook[]

  // Revenue Splits
  opportunitySplits      OpportunitySplit[] @relation("SplitUser")
  approvedSplits         OpportunitySplit[] @relation("SplitApprover")

  // Partner Management
  partnerMemberships     PartnerUser[]      @relation("PartnerUsers")
  managedPartners        Partner[]          @relation("PartnerManager")
  approvedDealRegs       DealRegistration[] @relation("DealRegApprover")
  rejectedDealRegs       DealRegistration[] @relation("DealRegRejecter")
  convertedDealRegs      DealRegistration[] @relation("DealRegConverter")

  // Access Requests (assigned for follow-up)
  assignedAccessRequests AccessRequest[]    @relation("AssignedAccessRequests")

  // Approval Workflows
  createdApprovalWorkflows ApprovalWorkflow[]  @relation("ApprovalWorkflowCreator")
  approvalStepsAssigned    ApprovalStep[]      @relation("ApprovalStepApprover")
  approvalRequestsSubmitted ApprovalRequest[]  @relation("ApprovalRequestor")
  approvalDecisionsMade    ApprovalDecision[]  @relation("ApprovalDecisionApprover")
  approvalDelegationsReceived ApprovalDecision[] @relation("ApprovalDecisionDelegate")
}

// Salesforce OAuth Connection
model SalesforceConnection {
  id           String    @id @default(cuid())
  userId       String    @unique
  instanceUrl  String
  accessToken  String // Encrypted
  refreshToken String // Encrypted
  expiresAt    DateTime
  orgId        String
  username     String
  displayName  String?
  email        String?
  isSandbox    Boolean   @default(false)
  scopes       String[]  @default([])
  syncSettings Json? // Sync configuration
  lastSyncAt   DateTime?
  createdAt    DateTime  @default(now())
  updatedAt    DateTime  @updatedAt

  user User @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@index([orgId])
}

// ==================== CRM INTEGRATION CONFIGURATION ====================

// CRM Provider type enum
enum CrmProvider {
  SALESFORCE
  HUBSPOT
  DYNAMICS365
  ZOHO
  ORACLE_CX
  CUSTOM
}

// CRM Integration Configuration (Admin-managed)
model CrmIntegration {
  id           String      @id @default(cuid())
  provider     CrmProvider @unique
  name         String // Display name (e.g., "Salesforce CRM")
  isEnabled    Boolean     @default(false)
  isConfigured Boolean     @default(false)

  // OAuth Configuration (encrypted)
  clientId     String? // Encrypted Consumer Key
  clientSecret String? // Encrypted Consumer Secret
  callbackUrl  String? // OAuth callback URL
  loginUrl     String? // Auth endpoint (e.g., https://login.salesforce.com)
  apiVersion   String? // API version (e.g., v59.0)

  // Additional provider-specific config
  config Json? // Provider-specific settings

  // Metadata
  createdBy String?
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  // Relations
  connections CrmConnection[]

  @@index([provider])
  @@index([isEnabled])
}

// CRM User Connection (per-user OAuth tokens)
model CrmConnection {
  id            String @id @default(cuid())
  userId        String
  integrationId String

  // Connection details
  instanceUrl  String // e.g., https://mycompany.my.salesforce.com
  accessToken  String // Encrypted
  refreshToken String // Encrypted
  expiresAt    DateTime

  // CRM org/tenant info
  externalOrgId  String? // Salesforce Org ID, HubSpot Portal ID, etc.
  externalUserId String? // User ID in the external CRM
  username       String? // Username in CRM
  displayName    String?
  email          String?

  // Connection status
  isActive  Boolean  @default(true)
  isSandbox Boolean  @default(false)
  scopes    String[] @default([])

  // Sync settings
  syncSettings Json?
  lastSyncAt   DateTime?
  lastError    String?

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  // Relations
  integration CrmIntegration @relation(fields: [integrationId], references: [id], onDelete: Cascade)

  @@unique([userId, integrationId])
  @@index([integrationId])
  @@index([externalOrgId])
}

// OAuth State for CSRF protection (stored in DB for cluster support)
model OAuthState {
  id        String      @id @default(cuid())
  state     String      @unique
  userId    String
  provider  CrmProvider
  createdAt DateTime    @default(now())
  expiresAt DateTime // Auto-expire after 10 minutes

  @@index([state])
  @@index([expiresAt])
}

// User role enum for access control
enum UserRole {
  ADMIN
  MANAGER
  USER
  VIEWER
}

// User status enum
enum UserStatus {
  ACTIVE
  INACTIVE
  SUSPENDED
  PENDING
}

model Conversation {
  id        String   @id @default(cuid())
  title     String
  userId    String
  isPinned  Boolean  @default(false)
  isStarred Boolean  @default(false)
  metadata  Json?
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  user       User              @relation(fields: [userId], references: [id], onDelete: Cascade)
  messages   Message[]
  artifacts  Artifact[]
  files      UploadedFile[]
  tags       ConversationTag[]
  activities Activity[]
}

model Message {
  id                  String         @id @default(cuid())
  conversationId      String
  role                MessageRole
  content             String
  thinkingTimeSeconds Float?
  suggestedFollowUps  String[]
  feedback            FeedbackValue?
  feedbackComment     String? // Optional user comment explaining feedback
  feedbackAt          DateTime? // When feedback was given
  isEdited            Boolean        @default(false)
  metadata            Json?
  createdAt           DateTime       @default(now())

  conversation Conversation @relation(fields: [conversationId], references: [id], onDelete: Cascade)
  artifact     Artifact?    @relation("MessageArtifact")

  // RLHF Relations
  feedbackEntry   FeedbackEntry?
  chosenInPairs   PreferencePair[] @relation("ChosenResponse")
  rejectedInPairs PreferencePair[] @relation("RejectedResponse")
}

// RLHF FEEDBACK ENTRY - Detailed feedback for training
model FeedbackEntry {
  id        String @id @default(cuid())
  messageId String @unique
  userId    String

  // The feedback
  rating  FeedbackValue
  comment String? // Why was this good/bad?

  // Context for training
  userQuery    String // The user's original question
  systemPrompt String? // System prompt used (for A/B testing)
  toolsUsed    String[] // Which tools were called
  responseTime Float? // Response latency in seconds

  // Categorization for analysis
  category String? // e.g., "lead_query", "document_search", "email_draft"
  tags     String[] // Custom tags for filtering

  // Quality dimensions (1-5 scale, optional detailed feedback)
  accuracyScore    Int? // Was the information correct?
  helpfulnessScore Int? // Did it answer the question?
  clarityScore     Int? // Was it easy to understand?

  createdAt DateTime @default(now())

  message Message @relation(fields: [messageId], references: [id], onDelete: Cascade)
  user    User    @relation(fields: [userId], references: [id], onDelete: Cascade)
}

// PREFERENCE PAIRS - For DPO/RLHF training
// Stores pairs of responses where one was preferred over another
model PreferencePair {
  id     String @id @default(cuid())
  userId String

  // The prompt that generated both responses
  prompt       String
  systemPrompt String?

  // The two responses being compared
  chosenId   String // The preferred response
  rejectedId String // The rejected response

  // Preference strength (how much better was chosen vs rejected)
  preferenceStrength Float? // 0.5 = slight, 1.0 = strong preference

  // Context
  category  String?
  createdAt DateTime @default(now())

  user     User    @relation(fields: [userId], references: [id], onDelete: Cascade)
  chosen   Message @relation("ChosenResponse", fields: [chosenId], references: [id], onDelete: Cascade)
  rejected Message @relation("RejectedResponse", fields: [rejectedId], references: [id], onDelete: Cascade)
}

// GOLDEN EXAMPLES - High-quality responses to use as few-shot examples
model GoldenExample {
  id String @id @default(cuid())

  // The example
  userQuery         String
  assistantResponse String

  // Quality metrics
  avgRating  Float @default(5.0)
  usageCount Int   @default(0) // How often used in prompts

  // Categorization
  category String // e.g., "lead_search", "opportunity_analysis"
  tags     String[]

  // Source tracking
  sourceMessageId String? // Original message this came from
  isManuallyAdded Boolean @default(false)

  isActive  Boolean  @default(true)
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
}

model Artifact {
  id             String       @id @default(cuid())
  conversationId String
  messageId      String?      @unique
  type           ArtifactType
  title          String
  data           Json
  createdAt      DateTime     @default(now())

  conversation Conversation @relation(fields: [conversationId], references: [id], onDelete: Cascade)
  message      Message?     @relation("MessageArtifact", fields: [messageId], references: [id])
}

model UploadedFile {
  id             String     @id @default(cuid())
  userId         String
  conversationId String?
  name           String
  mimeType       String
  sizeBytes      Int
  checksum       String?
  storagePath    String
  source         FileSource @default(UPLOAD)
  isContext      Boolean    @default(false)
  metadata       Json?
  createdAt      DateTime   @default(now())

  user            User             @relation(fields: [userId], references: [id], onDelete: Cascade)
  conversation    Conversation?    @relation(fields: [conversationId], references: [id], onDelete: Cascade)
  indexedDocument IndexedDocument?
}

// INDEXED DOCUMENT - Documents indexed by PageIndex service for AI search
model IndexedDocument {
  id             String  @id @default(cuid())
  uploadedFileId String? @unique

  // Document metadata
  filename   String
  documentId String @unique // PageIndex document ID
  mimeType   String @default("application/pdf")
  sizeBytes  Int?

  // Indexing status
  status       IndexingStatus @default(PENDING)
  progress     Int            @default(0)
  errorMessage String?

  // Indexed content
  treeStructure Json? // The hierarchical tree structure from PageIndex
  summary       String? // Document-level summary
  pageCount     Int?

  // Timestamps
  createdAt DateTime  @default(now())
  indexedAt DateTime?
  updatedAt DateTime  @updatedAt

  uploadedFile UploadedFile? @relation(fields: [uploadedFileId], references: [id], onDelete: SetNull)
}

enum IndexingStatus {
  PENDING
  PROCESSING
  COMPLETE
  ERROR
}

model Template {
  id          String   @id @default(cuid())
  userId      String
  title       String
  description String?
  category    String
  prompt      String
  tags        String[]
  isPremium   Boolean  @default(false)
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt

  user User @relation(fields: [userId], references: [id], onDelete: Cascade)
}

model Tag {
  id            String            @id @default(cuid())
  name          String            @unique
  conversations ConversationTag[]
}

model ConversationTag {
  conversationId String
  tagId          String

  conversation Conversation @relation(fields: [conversationId], references: [id], onDelete: Cascade)
  tag          Tag          @relation(fields: [tagId], references: [id], onDelete: Cascade)

  @@id([conversationId, tagId])
}

model ResearchJob {
  id          String         @id @default(cuid())
  userId      String
  url         String
  status      ResearchStatus @default(PENDING)
  result      Json?
  createdAt   DateTime       @default(now())
  completedAt DateTime?

  user User @relation(fields: [userId], references: [id], onDelete: Cascade)
}

enum MessageRole {
  USER
  ASSISTANT
  SYSTEM
}

enum FeedbackValue {
  POSITIVE
  NEGATIVE
}

enum ArtifactType {
  EMAIL_DRAFT
  CALL_SCRIPT
  RESEARCH_BRIEF
  ACCOUNT_REPORT
  CRM_CARD
}

enum FileSource {
  UPLOAD
  WEB_RESEARCH
  CRM
}

enum ResearchStatus {
  PENDING
  PROCESSING
  COMPLETE
  FAILED
}

// ============================================
// STANDARD SALES CRM - LEAD TO CASH
// ============================================

// LEAD - Initial prospect before qualification
model Lead {
  id             String  @id @default(cuid())
  ownerId        String
  organizationId String? // Multi-tenant isolation
  salesforceId   String? @unique // Salesforce Lead ID for sync

  // Lead Information
  firstName String
  lastName  String
  company   String?
  title     String?
  email     String? @unique
  phone     String?
  website   String?

  // Lead Details
  leadSource        LeadSource  @default(OTHER)
  status            LeadStatus  @default(NEW)
  rating            LeadRating?
  industry          String?
  numberOfEmployees Int?
  annualRevenue     Float?

  // Address
  street     String?
  city       String?
  state      String?
  postalCode String?
  country    String?

  // Qualification
  isQualified        Boolean   @default(false)
  qualifiedDate      DateTime?
  disqualifiedReason String?

  // AI Insights
  leadScore    Int? // 0-100 AI-calculated lead score
  buyingIntent BuyingIntent?
  painPoints   String[]
  budget       Float?
  timeline     String?

  // Conversion tracking
  convertedDate          DateTime?
  convertedAccountId     String?
  convertedContactId     String?
  convertedOpportunityId String?

  // Engagement tracking
  lastContactedAt DateTime?

  metadata  Json?
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  owner           User             @relation(fields: [ownerId], references: [id], onDelete: Cascade)
  organization    Organization?    @relation("OrganizationLeads", fields: [organizationId], references: [id], onDelete: SetNull)
  tasks           Task[]
  activities      Activity[]
  notes           Note[]
  emailThreads    EmailThread[]
  meetingSessions MeetingSession[] // Meeting Intelligence
  callHistory     CallHistory[]    @relation("LeadCallHistory") // Voice call history

  // Access Request conversion tracking
  accessRequest   AccessRequest?   @relation("AccessRequestLead")

  @@index([organizationId])
  @@index([organizationId, ownerId])
}

// ACCOUNT - Qualified company/organization
model Account {
  id              String  @id @default(cuid())
  ownerId         String
  organizationId  String? // Multi-tenant isolation
  salesforceId    String? @unique // Salesforce Account ID for sync
  parentAccountId String? // For account hierarchies

  // Account Information
  name     String
  website  String?
  domain   String?     @unique
  phone    String?
  fax      String?
  industry String?
  type     AccountType @default(PROSPECT)

  // Company Details
  numberOfEmployees Int?
  annualRevenue     Float?
  description       String?

  // Address
  billingStreet     String?
  billingCity       String?
  billingState      String?
  billingPostalCode String?
  billingCountry    String?

  shippingStreet     String?
  shippingCity       String?
  shippingState      String?
  shippingPostalCode String?
  shippingCountry    String?

  // Account Status
  accountStatus AccountStatus  @default(ACTIVE)
  rating        AccountRating?

  // AI Insights
  healthScore   Int? // 0-100 relationship health
  lifetimeValue Float? // Total value from this account
  churnRisk     ChurnRisk?
  painPoints    String[]
  techStack     String[]
  competitors   String[]

  // Strategic Account (Digital Worker)
  isStrategic Boolean @default(false) // Strategic account flag
  tier        String? // TIER_1, TIER_2, TIER_3
  region      String? // NA, EMEA, APAC, LATAM
  externalId  String? // ID in Snowflake/MDM

  // Engagement
  lastActivityDate DateTime?
  nextActivityDate DateTime?

  metadata  Json?
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  owner           User             @relation(fields: [ownerId], references: [id], onDelete: Cascade)
  parentAccount   Account?         @relation("AccountHierarchy", fields: [parentAccountId], references: [id], onDelete: SetNull)
  childAccounts   Account[]        @relation("AccountHierarchy")
  contacts        Contact[]
  opportunities   Opportunity[]
  quotes          Quote[]
  contracts       Contract[]
  tasks           Task[]
  activities      Activity[]
  notes           Note[]
  emailThreads    EmailThread[]
  meetingSessions MeetingSession[] // Meeting Intelligence
  callHistory     CallHistory[]    @relation("AccountCallHistory") // Voice call history
  orders          Order[] // CPQ orders

  // Territories
  territories TerritoryAccount[]

  // Digital Worker - Account Signals
  signals AccountSignal[]

  // Asset/Installed Base
  assets           Asset[]
  supportContracts SupportContract[]

  // Partner Relationships
  partnerAccounts  PartnerAccount[]
  dealRegistrations DealRegistration[]

  // Multi-tenant
  organization Organization? @relation("OrganizationAccounts", fields: [organizationId], references: [id], onDelete: SetNull)

  @@index([organizationId])
  @@index([organizationId, ownerId])
}

// CONTACT - Person at an Account
model Contact {
  id             String  @id @default(cuid())
  accountId      String?
  ownerId        String
  organizationId String? // Multi-tenant isolation
  reportsToId    String? // Contact hierarchy

  // Contact Information
  salutation  String? // Mr., Mrs., Dr., etc.
  firstName   String
  lastName    String
  email       String? @unique
  phone       String?
  mobilePhone String?

  // Professional Details
  title          String?
  department     String?
  role           ContactRole?
  seniorityLevel SeniorityLevel?
  buyingPower    BuyingPower?

  // Address (if different from Account)
  mailingStreet     String?
  mailingCity       String?
  mailingState      String?
  mailingPostalCode String?
  mailingCountry    String?

  // Social & Engagement
  linkedinUrl   String?
  twitterHandle String?
  avatarUrl     String?

  // AI Insights
  engagementScore    Int? // 0-100
  responseRate       Float? // Email response rate
  communicationStyle String?
  interests          String[]
  influenceLevel     InfluenceLevel?

  // Status
  contactStatus ContactStatus @default(ACTIVE)
  doNotCall     Boolean       @default(false)
  doNotEmail    Boolean       @default(false)
  emailOptOut   Boolean       @default(false)

  // Engagement tracking
  lastContactedAt DateTime?
  lastEmailDate   DateTime?
  lastCallDate    DateTime?

  metadata  Json?
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  account             Account?                 @relation(fields: [accountId], references: [id], onDelete: SetNull)
  owner               User                     @relation(fields: [ownerId], references: [id], onDelete: Cascade)
  reportsTo           Contact?                 @relation("ContactHierarchy", fields: [reportsToId], references: [id], onDelete: SetNull)
  directReports       Contact[]                @relation("ContactHierarchy")
  opportunityRoles    OpportunityContactRole[]
  tasks               Task[]
  activities          Activity[]
  notes               Note[]
  emailThreads        EmailThread[]
  meetingParticipants MeetingParticipant[] // Meeting Intelligence
  callHistory         CallHistory[]            @relation("ContactCallHistory") // Voice call history

  // Multi-tenant
  organization Organization? @relation("OrganizationContacts", fields: [organizationId], references: [id], onDelete: SetNull)

  @@index([organizationId])
  @@index([organizationId, ownerId])
}

// Deal/Opportunity entity
// OPPORTUNITY - Sales opportunity/deal
model Opportunity {
  id             String  @id @default(cuid())
  accountId      String
  ownerId        String
  organizationId String? // Multi-tenant isolation
  campaignId     String?
  pipelineId     String? // Custom pipeline reference
  stageId        String? // Custom pipeline stage reference
  salesforceId   String? @unique // Salesforce Opportunity ID for sync

  // Basic Information
  name              String
  opportunitySource OpportunitySource?
  type              OpportunityType?
  stage             OpportunityStage   @default(PROSPECTING)

  // Financial
  amount          Float?
  probability     Int? // 0-100 based on stage
  expectedRevenue Float? // amount * probability
  discount        Float? @default(0)

  // Timeline
  closeDate        DateTime?
  createdDate      DateTime  @default(now())
  lastActivityDate DateTime?
  nextActivityDate DateTime?

  // Qualification
  needsAnalysis    String?
  proposedSolution String?
  competitors      String[]
  nextStep         String?

  // AI Insights
  winProbability     Float? // AI-calculated 0-1
  riskFactors        String[]
  recommendedActions String[]
  dealVelocity       Int? // Days in current stage

  // Status
  isClosed   Boolean   @default(false)
  isWon      Boolean   @default(false)
  lostReason String?
  closedDate DateTime?

  metadata  Json?
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  account         Account                  @relation(fields: [accountId], references: [id], onDelete: Cascade)
  owner           User                     @relation(fields: [ownerId], references: [id], onDelete: Cascade)
  campaign        Campaign?                @relation(fields: [campaignId], references: [id], onDelete: SetNull)
  pipeline        Pipeline?                @relation(fields: [pipelineId], references: [id], onDelete: SetNull)
  pipelineStage   PipelineStage?           @relation(fields: [stageId], references: [id], onDelete: SetNull)
  contactRoles    OpportunityContactRole[]
  quotes          Quote[]
  tasks           Task[]
  activities      Activity[]
  notes           Note[]
  emailThreads    EmailThread[]
  meetingSessions MeetingSession[] // Meeting Intelligence
  callHistory     CallHistory[]            @relation("OpportunityCallHistory") // Voice call history

  // Revenue Splits
  splits              OpportunitySplit[]

  // Competitor Intelligence
  opportunityCompetitors OpportunityCompetitor[]

  // Partner Deal Registration
  dealRegistration    DealRegistration?

  // Multi-tenant
  organization Organization? @relation("OrganizationOpportunities", fields: [organizationId], references: [id], onDelete: SetNull)

  @@index([pipelineId])
  @@index([stageId])
  @@index([organizationId])
  @@index([organizationId, ownerId])
}

// ==================== SALES PIPELINE CONFIGURATION ====================

// Custom Sales Pipeline (e.g., "Enterprise Sales", "SMB Sales", "Renewals")
model Pipeline {
  id             String   @id @default(cuid())
  organizationId String? // Multi-tenant isolation
  name           String
  description    String?
  isDefault   Boolean  @default(false)
  isActive    Boolean  @default(true)
  color       String? // Hex color for UI display
  sortOrder   Int      @default(0)
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt

  stages        PipelineStage[]
  opportunities Opportunity[]

  // Multi-tenant
  organization Organization? @relation("OrganizationPipelines", fields: [organizationId], references: [id], onDelete: SetNull)

  @@index([isDefault])
  @@index([isActive])
  @@index([organizationId])
}

// Pipeline Stage (custom stages within a pipeline)
model PipelineStage {
  id             String   @id @default(cuid())
  pipelineId     String
  organizationId String? // Multi-tenant isolation
  name           String // Internal name (e.g., "PROSPECTING")
  displayName  String // Display name (e.g., "Prospecting")
  color        String // Hex color for UI display
  probability  Int      @default(0) // 0-100 default probability
  isClosedWon  Boolean  @default(false)
  isClosedLost Boolean  @default(false)
  sortOrder    Int      @default(0)
  createdAt    DateTime @default(now())
  updatedAt    DateTime @updatedAt

  pipeline      Pipeline      @relation(fields: [pipelineId], references: [id], onDelete: Cascade)
  opportunities Opportunity[]

  // Multi-tenant
  organization Organization? @relation("OrganizationPipelineStages", fields: [organizationId], references: [id], onDelete: SetNull)

  @@unique([pipelineId, name])
  @@index([pipelineId])
  @@index([sortOrder])
  @@index([organizationId])
}

// Junction table for Opportunity-Contact roles
model OpportunityContactRole {
  id            String       @id @default(cuid())
  opportunityId String
  contactId     String
  role          ContactRole?
  isPrimary     Boolean      @default(false)
  createdAt     DateTime     @default(now())

  opportunity Opportunity @relation(fields: [opportunityId], references: [id], onDelete: Cascade)
  contact     Contact     @relation(fields: [contactId], references: [id], onDelete: Cascade)

  @@unique([opportunityId, contactId])
}

// Activity/Interaction log (calls, emails, meetings extracted from chat)
// TASK - To-do items
model Task {
  id             String  @id @default(cuid())
  ownerId        String
  organizationId String? // Multi-tenant isolation
  assignedToId   String?

  // Related records (polymorphic-like)
  leadId           String?
  accountId        String?
  contactId        String?
  opportunityId    String?
  meetingSessionId String? // Meeting Intelligence

  subject     String
  description String?
  status      TaskStatus   @default(NOT_STARTED)
  priority    TaskPriority @default(NORMAL)

  dueDate       DateTime?
  reminderDate  DateTime?
  reminderSent  Boolean   @default(false)
  completedDate DateTime?

  metadata  Json?
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  owner          User            @relation("TaskOwner", fields: [ownerId], references: [id], onDelete: Cascade)
  assignedTo     User?           @relation("TaskAssignee", fields: [assignedToId], references: [id], onDelete: SetNull)
  lead           Lead?           @relation(fields: [leadId], references: [id], onDelete: Cascade)
  account        Account?        @relation(fields: [accountId], references: [id], onDelete: Cascade)
  contact        Contact?        @relation(fields: [contactId], references: [id], onDelete: Cascade)
  opportunity    Opportunity?    @relation(fields: [opportunityId], references: [id], onDelete: Cascade)
  meetingSession MeetingSession? @relation("MeetingGeneratedTasks", fields: [meetingSessionId], references: [id], onDelete: SetNull)

  // Multi-tenant
  organization Organization? @relation("OrganizationTasks", fields: [organizationId], references: [id], onDelete: SetNull)

  @@index([organizationId])
}

// ACTIVITY - Activity history (calls, emails, meetings)
model Activity {
  id             String  @id @default(cuid())
  userId         String
  organizationId String? // Multi-tenant isolation

  // Related records (polymorphic-like)
  leadId           String?
  accountId        String?
  contactId        String?
  opportunityId    String?
  conversationId   String?
  meetingSessionId String? // Meeting Intelligence

  type        ActivityType
  subject     String
  description String?
  outcome     String?
  sentiment   Sentiment?

  activityDate DateTime @default(now())
  duration     Int? // minutes

  // AI extraction
  keyPoints   String[]
  actionItems String[]
  concerns    String[]
  nextSteps   String[]

  metadata  Json?
  createdAt DateTime @default(now())

  user           User            @relation(fields: [userId], references: [id], onDelete: Cascade)
  lead           Lead?           @relation(fields: [leadId], references: [id], onDelete: Cascade)
  account        Account?        @relation(fields: [accountId], references: [id], onDelete: Cascade)
  contact        Contact?        @relation(fields: [contactId], references: [id], onDelete: Cascade)
  opportunity    Opportunity?    @relation(fields: [opportunityId], references: [id], onDelete: Cascade)
  conversation   Conversation?   @relation(fields: [conversationId], references: [id], onDelete: SetNull)
  meetingSession MeetingSession? @relation("MeetingGeneratedActivities", fields: [meetingSessionId], references: [id], onDelete: SetNull)

  // Email tracking relation
  emailThread   EmailThread? @relation(fields: [emailThreadId], references: [id], onDelete: SetNull)
  emailThreadId String?

  // Multi-tenant
  organization Organization? @relation("OrganizationActivities", fields: [organizationId], references: [id], onDelete: SetNull)

  @@index([organizationId])
}

// ============================================
// EMAIL TRACKING SYSTEM
// ============================================

// EMAIL THREAD - Conversation thread for email exchanges
model EmailThread {
  id             String  @id @default(cuid())
  userId         String
  organizationId String? // Multi-tenant isolation

  // Related CRM records
  leadId        String?
  accountId     String?
  contactId     String?
  opportunityId String?

  // Thread metadata
  subject String
  status  EmailThreadStatus @default(ACTIVE)

  // Tracking stats
  totalEmails    Int       @default(1)
  totalResponses Int       @default(0)
  lastEmailAt    DateTime  @default(now())
  lastResponseAt DateTime?

  // AI insights
  sentiment        Sentiment?
  engagementLevel  EngagementLevel?
  suggestedActions String[]

  metadata  Json?
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  // Relations
  emails      EmailMessage[]
  drafts      EmailDraft[]
  activities  Activity[]
  lead        Lead?          @relation(fields: [leadId], references: [id], onDelete: SetNull)
  account     Account?       @relation(fields: [accountId], references: [id], onDelete: SetNull)
  contact     Contact?       @relation(fields: [contactId], references: [id], onDelete: SetNull)
  opportunity Opportunity?   @relation(fields: [opportunityId], references: [id], onDelete: SetNull)

  // Multi-tenant
  organization Organization? @relation("OrganizationEmailThreads", fields: [organizationId], references: [id], onDelete: SetNull)

  @@index([organizationId])
}

// EMAIL MESSAGE - Individual email in a thread
model EmailMessage {
  id       String  @id @default(cuid())
  threadId String
  userId   String? // null for inbound emails

  // Email details
  messageId  String   @unique // Email Message-ID header for threading
  inReplyTo  String? // In-Reply-To header
  references String[] // References header

  // Sender/Recipient
  fromEmail String
  fromName  String?
  toEmails  String[]
  ccEmails  String[]
  bccEmails String[]

  // Content
  subject  String
  bodyHtml String?
  bodyText String?

  // Direction & Status
  direction EmailDirection
  status    EmailMessageStatus @default(SENT)

  // Tracking (for outbound)
  sentAt      DateTime?
  deliveredAt DateTime?
  openedAt    DateTime?
  clickedAt   DateTime?
  bouncedAt   DateTime?

  // For inbound
  receivedAt  DateTime?
  processedAt DateTime?

  // AI analysis (for inbound responses)
  sentiment            Sentiment?
  intent               EmailIntent?
  keyPoints            String[]
  actionItemsExtracted String[]
  urgency              EmailUrgency?
  requiresResponse     Boolean       @default(false)
  suggestedResponse    String?

  // Draft response (auto-generated, ready to send)
  draftResponse EmailDraft?

  // CRM actions taken
  crmActionsPerformed Json? // Record of CRM updates made

  metadata  Json?
  createdAt DateTime @default(now())

  thread EmailThread @relation(fields: [threadId], references: [id], onDelete: Cascade)
}

// EMAIL DRAFT - Auto-generated response drafts ready to review and send
model EmailDraft {
  id                 String @id @default(cuid())
  threadId           String
  inReplyToMessageId String @unique // The inbound message this is a reply to

  // Draft content
  subject  String
  bodyHtml String
  bodyText String?

  // Recipients (pre-filled from original sender)
  toEmails String[]
  ccEmails String[]

  // Status
  status DraftStatus @default(PENDING_REVIEW)

  // AI generation metadata
  generatedAt      DateTime @default(now())
  generationPrompt String? // What context was used to generate
  confidence       Float? // AI confidence in the response (0-1)
  tone             String? // e.g., "professional", "friendly", "urgent"

  // User interaction
  reviewedAt    DateTime?
  reviewedBy    String?
  editedContent String? // If user edited the draft
  sentAt        DateTime?
  sentMessageId String? // Reference to the sent EmailMessage

  // Rejection/feedback
  rejectedAt      DateTime?
  rejectionReason String?

  metadata  Json?
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  // Relations
  thread           EmailThread  @relation(fields: [threadId], references: [id], onDelete: Cascade)
  inReplyToMessage EmailMessage @relation(fields: [inReplyToMessageId], references: [id], onDelete: Cascade)
}

enum DraftStatus {
  PENDING_REVIEW // Draft created, waiting for user review
  APPROVED // User approved, ready to send
  SENT // Draft was sent
  REJECTED // User rejected the draft
  EXPIRED // Too old, no longer relevant
}

// Enums for email tracking
enum EmailThreadStatus {
  ACTIVE // Ongoing conversation
  AWAITING_RESPONSE // Sent email, waiting for reply
  RESPONDED // Got a response
  CLOSED // Thread closed/completed
  BOUNCED // Email bounced
  UNSUBSCRIBED // Recipient unsubscribed
}

enum EmailDirection {
  OUTBOUND // Sent by us
  INBOUND // Received from contact
}

enum EmailMessageStatus {
  DRAFT
  QUEUED
  SENT
  DELIVERED
  OPENED
  CLICKED
  BOUNCED
  FAILED
  RECEIVED // For inbound
}

enum EmailIntent {
  POSITIVE_REPLY // Interested, wants to proceed
  NEGATIVE_REPLY // Not interested, declining
  QUESTION // Has questions
  MEETING_REQUEST // Wants to schedule meeting
  REFERRAL // Referring to someone else
  OUT_OF_OFFICE // Auto-reply
  UNSUBSCRIBE // Wants to unsubscribe
  NEUTRAL // General response
  FOLLOW_UP // Following up on something
}

enum EmailUrgency {
  HIGH
  MEDIUM
  LOW
}

// ============================================
// EMAIL TEMPLATES & CAMPAIGNS
// ============================================

// Email template category
enum EmailTemplateCategory {
  NOTIFICATION // System notifications
  TRANSACTIONAL // Transactional emails (password reset, etc.)
  MARKETING // Marketing campaigns
  SALES // Sales outreach
  FOLLOW_UP // Follow-up emails
  MEETING // Meeting invites & reminders
  DIGEST // Daily/weekly digests
  CUSTOM // Custom templates
}

// Email template status
enum EmailTemplateStatus {
  DRAFT
  ACTIVE
  ARCHIVED
}

// Email campaign status
enum EmailCampaignStatus {
  DRAFT
  SCHEDULED
  SENDING
  COMPLETED
  PAUSED
  CANCELLED
}

// Email queue status
enum EmailQueueStatus {
  PENDING
  PROCESSING
  SENT
  FAILED
  CANCELLED
}

// Reusable email templates (admin-managed)
model EmailTemplate {
  id String @id @default(cuid())

  // Template identity
  name        String  @unique
  slug        String  @unique
  description String?

  // Content
  subject   String // Supports {{variable}} placeholders
  bodyHtml  String  @db.Text // HTML content
  bodyText  String? @db.Text // Plain text fallback
  preheader String? // Email preview text

  // Configuration
  category EmailTemplateCategory @default(CUSTOM)
  status   EmailTemplateStatus   @default(DRAFT)

  // Variables supported in this template
  variables String[] @default([]) // e.g., ["firstName", "companyName"]

  // Design settings
  useIrisBranding Boolean @default(true) // Use IRIS brand wrapper
  ctaText         String? // Default CTA button text
  ctaUrl          String? // Default CTA URL (supports variables)

  // Targeting (optional restrictions)
  targetRoles String[] @default([]) // Empty = all roles

  // Tracking
  sendCount  Int @default(0)
  openCount  Int @default(0)
  clickCount Int @default(0)

  // Audit
  createdBy    String?
  lastEditedBy String?

  metadata  Json?
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  // Relations
  campaigns    EmailCampaign[]
  queuedEmails EmailQueueItem[]

  @@index([category])
  @@index([status])
  @@index([slug])
  @@map("email_templates")
}

// Email campaigns for bulk sending
model EmailCampaign {
  id String @id @default(cuid())

  // Campaign identity
  name        String
  description String?

  // Template reference
  templateId String

  // Targeting
  recipientType String   @default("all") // all, role, custom
  targetRoles   String[] @default([])
  recipientList String[] @default([]) // Custom email list

  // Scheduling
  status       EmailCampaignStatus @default(DRAFT)
  scheduledFor DateTime?
  startedAt    DateTime?
  completedAt  DateTime?

  // Statistics
  totalRecipients  Int @default(0)
  sentCount        Int @default(0)
  failedCount      Int @default(0)
  openCount        Int @default(0)
  clickCount       Int @default(0)
  bounceCount      Int @default(0)
  unsubscribeCount Int @default(0)

  // Audit
  createdBy String?

  metadata  Json?
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  // Relations
  template     EmailTemplate    @relation(fields: [templateId], references: [id], onDelete: Cascade)
  queuedEmails EmailQueueItem[]

  @@index([status])
  @@index([scheduledFor])
  @@index([templateId])
  @@map("email_campaigns")
}

// Email queue for reliable delivery
model EmailQueueItem {
  id String @id @default(cuid())

  // Template/Campaign reference (optional)
  templateId String?
  campaignId String?

  // Email details
  toEmail   String
  toName    String?
  fromEmail String? // Override default sender
  fromName  String?
  replyTo   String?

  subject  String
  bodyHtml String  @db.Text
  bodyText String? @db.Text

  // CC/BCC
  ccEmails  String[] @default([])
  bccEmails String[] @default([])

  // Status
  status   EmailQueueStatus @default(PENDING)
  priority Int              @default(0) // Higher = more urgent

  // Scheduling
  scheduledFor DateTime?

  // Retry logic
  attempts      Int       @default(0)
  maxAttempts   Int       @default(3)
  lastAttemptAt DateTime?
  nextRetryAt   DateTime?

  // Tracking
  sentAt      DateTime?
  deliveredAt DateTime?
  openedAt    DateTime?
  clickedAt   DateTime?
  bouncedAt   DateTime?

  // Error handling
  errorMessage String?
  errorCode    String?

  // CRM linking
  userId        String?
  leadId        String?
  contactId     String?
  accountId     String?
  opportunityId String?

  // Source tracking
  source      String  @default("system") // system, admin, trigger, campaign
  triggeredBy String? // Event that triggered this email

  metadata  Json?
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  // Relations
  template EmailTemplate? @relation(fields: [templateId], references: [id], onDelete: SetNull)
  campaign EmailCampaign? @relation(fields: [campaignId], references: [id], onDelete: SetNull)

  @@index([status])
  @@index([priority])
  @@index([scheduledFor])
  @@index([toEmail])
  @@index([source])
  @@index([campaignId])
  @@map("email_queue")
}

// User email notification preferences
model EmailNotificationPreferences {
  id     String @id @default(cuid())
  userId String @unique

  // Master toggle
  emailsEnabled Boolean @default(true)

  // Notification types
  dailyDigest   Boolean @default(true)
  weeklyReport  Boolean @default(true)
  monthlyReport Boolean @default(false)

  // CRM notifications
  newLeadAssigned  Boolean @default(true)
  leadStatusChange Boolean @default(true)
  dealStageChange  Boolean @default(true)
  dealWonLost      Boolean @default(true)
  taskAssigned     Boolean @default(true)
  taskDueReminder  Boolean @default(true)
  meetingReminder  Boolean @default(true)

  // AI insights
  aiInsights Boolean @default(true)

  // System notifications
  systemAlerts   Boolean @default(true)
  securityAlerts Boolean @default(true)

  // Marketing (opt-in)
  marketingEmails Boolean @default(false)
  productUpdates  Boolean @default(true)

  // Digest schedule
  digestTime     String?  @default("08:00") // Time of day for digest
  digestTimezone String?  @default("UTC")
  digestDays     String[] @default(["MON", "TUE", "WED", "THU", "FRI"])

  // Unsubscribe tracking
  unsubscribedAt   DateTime?
  unsubscribeToken String?   @unique

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@index([userId])
  @@map("email_notification_preferences")
}

// AI-generated insights about companies
// QUOTE - Sales quotes
model Quote {
  id             String  @id @default(cuid())
  opportunityId  String
  accountId      String
  ownerId        String
  organizationId String? // Multi-tenant isolation

  quoteNumber String      @unique
  name        String
  status      QuoteStatus @default(DRAFT)

  // Pricing
  subtotal         Float  @default(0)
  discount         Float  @default(0)
  discountPercent  Float?
  tax              Float  @default(0)
  shippingHandling Float  @default(0)
  totalPrice       Float  @default(0)

  // Terms
  validUntil   DateTime?
  paymentTerms String?
  description  String?

  // Delivery
  billingStreet     String?
  billingCity       String?
  billingState      String?
  billingPostalCode String?
  billingCountry    String?

  shippingStreet     String?
  shippingCity       String?
  shippingState      String?
  shippingPostalCode String?
  shippingCountry    String?

  // Status tracking
  sentDate       DateTime?
  acceptedDate   DateTime?
  rejectedDate   DateTime?
  rejectedReason String?

  metadata  Json?
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  opportunity        Opportunity         @relation(fields: [opportunityId], references: [id], onDelete: Cascade)
  account            Account             @relation(fields: [accountId], references: [id], onDelete: Cascade)
  owner              User                @relation(fields: [ownerId], references: [id], onDelete: Cascade)
  lineItems          QuoteLineItem[]
  contract           Contract?
  esignatureRequests ESignatureRequest[] // CPQ e-signature requests
  documents          QuoteDocument[] // Attached documents with AI summaries

  // Multi-tenant
  organization Organization? @relation("OrganizationQuotes", fields: [organizationId], references: [id], onDelete: SetNull)

  @@index([organizationId])
  @@index([organizationId, ownerId])
}

// QUOTE DOCUMENT - Attached documents with AI-extracted content
model QuoteDocument {
  id      String @id @default(cuid())
  quoteId String

  // Document info
  filename  String
  fileUrl   String // S3/storage URL
  mimeType  String @default("application/pdf")
  sizeBytes Int?

  // AI extraction results
  summary       String?  @db.Text // AI-generated summary
  extractedText String?  @db.Text // Full extracted text
  keyTerms      String[] // Key terms/entities extracted
  tableCount    Int? // Number of tables detected
  pageCount     Int? // Page count

  // Processing status
  status       DocumentProcessingStatus @default(PENDING)
  processedAt  DateTime?
  errorMessage String?

  // Metadata
  uploadedBy String
  createdAt  DateTime @default(now())
  updatedAt  DateTime @updatedAt

  quote    Quote @relation(fields: [quoteId], references: [id], onDelete: Cascade)
  uploader User  @relation(fields: [uploadedBy], references: [id])

  @@index([quoteId])
}

enum DocumentProcessingStatus {
  PENDING
  PROCESSING
  COMPLETE
  ERROR
}

// QUOTE LINE ITEM - Products/services on a quote
model QuoteLineItem {
  id      String @id @default(cuid())
  quoteId String

  productName String
  productCode String?
  description String?

  quantity  Float @default(1)
  listPrice Float
  unitPrice Float
  discount  Float @default(0)

  totalPrice Float // quantity * unitPrice

  sortOrder Int?

  metadata  Json?
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  quote     Quote    @relation(fields: [quoteId], references: [id], onDelete: Cascade)
  product   Product? @relation(fields: [productId], references: [id])
  productId String?
}

// PRODUCT ENUMS
enum ProductType {
  PRODUCT
  SERVICE
  SUBSCRIPTION
  LICENSE
  BUNDLE
}

enum ProductCategory {
  SOFTWARE
  HARDWARE
  CONSULTING
  TRAINING
  SUPPORT
  OTHER
}

enum BillingFrequency {
  ONE_TIME
  MONTHLY
  QUARTERLY
  ANNUAL
  USAGE_BASED
}

// PRODUCT - Product catalog for quotes and opportunities
model Product {
  id             String  @id @default(cuid())
  ownerId        String
  organizationId String? // Multi-tenant isolation

  // Product Information
  name        String
  sku         String  @unique
  description String?

  // Classification
  type     ProductType     @default(PRODUCT)
  category ProductCategory @default(OTHER)

  // Pricing
  listPrice        Float
  unitPrice        Float? // Can differ from list price
  costPrice        Float? // Internal cost
  currency         String           @default("USD")
  billingFrequency BillingFrequency @default(ONE_TIME)

  // Availability
  isActive Boolean @default(true)

  // Metadata
  features String[] // Feature list
  tags     String[] // Searchable tags
  metadata Json?

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  // Relations
  owner     User            @relation(fields: [ownerId], references: [id])
  lineItems QuoteLineItem[]

  // Asset/Installed Base
  assets            Asset[]            @relation("AssetProduct")
  competitorProducts CompetitorProduct[] @relation("ComparableProduct")

  // Multi-tenant
  organization Organization? @relation("OrganizationProducts", fields: [organizationId], references: [id], onDelete: SetNull)

  @@index([ownerId])
  @@index([sku])
  @@index([type])
  @@index([category])
  @@index([isActive])
  @@index([organizationId])
}

// CONTRACT - Legal contracts with customers
model Contract {
  id             String  @id @default(cuid())
  accountId      String
  quoteId        String? @unique
  ownerId        String
  organizationId String? // Multi-tenant isolation

  contractNumber String         @unique
  contractName   String
  status         ContractStatus @default(DRAFT)

  // Terms
  startDate    DateTime?
  endDate      DateTime?
  contractTerm Int? // months

  // Financial
  contractValue    Float?
  billingFrequency String? // Monthly, Quarterly, Annually

  // Renewal
  autoRenew         Boolean   @default(false)
  renewalDate       DateTime?
  renewalNoticeDate DateTime?
  renewalReminder   Boolean   @default(false)

  // Status
  signedDate        DateTime?
  activatedDate     DateTime?
  terminatedDate    DateTime?
  terminationReason String?

  description  String?
  specialTerms String?

  metadata  Json?
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  account Account @relation(fields: [accountId], references: [id], onDelete: Cascade)
  quote   Quote?  @relation(fields: [quoteId], references: [id], onDelete: SetNull)
  owner   User    @relation(fields: [ownerId], references: [id], onDelete: Cascade)

  // Multi-tenant
  organization Organization? @relation("OrganizationContracts", fields: [organizationId], references: [id], onDelete: SetNull)

  @@index([organizationId])
}

// CAMPAIGN - Marketing campaigns
model Campaign {
  id             String  @id @default(cuid())
  ownerId        String
  organizationId String? // Multi-tenant isolation

  name         String
  campaignType String? // Email, Event, Webinar, etc.
  status       CampaignStatus @default(PLANNED)

  startDate DateTime?
  endDate   DateTime?

  budgetedCost    Float?
  actualCost      Float?
  expectedRevenue Float?

  description String?

  // Metrics
  numSent      Int @default(0)
  numResponses Int @default(0)
  numConverted Int @default(0)

  metadata  Json?
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  owner         User          @relation(fields: [ownerId], references: [id], onDelete: Cascade)
  opportunities Opportunity[]

  // Multi-tenant
  organization Organization? @relation("OrganizationCampaigns", fields: [organizationId], references: [id], onDelete: SetNull)

  @@index([organizationId])
}

// NOTE - General notes on any record
// Supports both local IRIS entity linking and Salesforce entity linking
// Enhanced with voice capture, AI processing, and auto-actions
model Note {
  id             String  @id @default(cuid())
  userId         String
  organizationId String? // Multi-tenant isolation

  // Related records - Local IRIS entity IDs (polymorphic-like)
  leadId        String?
  accountId     String?
  contactId     String?
  opportunityId String?

  // Salesforce entity IDs (for Salesforce mode linking)
  // These allow notes to be linked to Salesforce records without requiring local sync
  sfLeadId        String? // Salesforce Lead ID (e.g., 00Qxx...)
  sfAccountId     String? // Salesforce Account ID (e.g., 001xx...)
  sfContactId     String? // Salesforce Contact ID (e.g., 003xx...)
  sfOpportunityId String? // Salesforce Opportunity ID (e.g., 006xx...)

  title     String?
  body      String
  isPrivate Boolean @default(false)

  // Voice/Audio fields
  audioUrl      String? // Storage URL for voice recording
  transcription String? // Transcribed text from audio

  // AI Processing fields
  sourceType       NoteSourceType       @default(TEXT)
  processingStatus NoteProcessingStatus @default(DRAFT)
  processedAt      DateTime? // When AI processing completed
  extractedData    Json? // AI extraction results: {entities, actionItems, crmUpdates, sentiment, summary}

  // Salesforce sync tracking
  salesforceNoteId String? // If synced to Salesforce ContentNote

  metadata  Json?
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  user        User         @relation(fields: [userId], references: [id], onDelete: Cascade)
  lead        Lead?        @relation(fields: [leadId], references: [id], onDelete: Cascade)
  account     Account?     @relation(fields: [accountId], references: [id], onDelete: Cascade)
  contact     Contact?     @relation(fields: [contactId], references: [id], onDelete: Cascade)
  opportunity Opportunity? @relation(fields: [opportunityId], references: [id], onDelete: Cascade)

  // Pending actions generated from this note
  pendingActions PendingNoteAction[]

  // Multi-tenant
  organization Organization? @relation("OrganizationNotes", fields: [organizationId], references: [id], onDelete: SetNull)

  @@index([sfLeadId])
  @@index([sfAccountId])
  @@index([sfContactId])
  @@index([sfOpportunityId])
  @@index([processingStatus])
  @@index([sourceType])
  @@index([organizationId])
}

// PENDING NOTE ACTION - AI-suggested actions requiring user approval
// Enables human-in-the-loop workflow for note automation
model PendingNoteAction {
  id     String @id @default(cuid())
  noteId String
  userId String

  actionType NoteActionType
  status     NoteActionStatus @default(PENDING)

  // What this action will do
  targetEntity   String? // 'lead', 'opportunity', 'account', 'contact', 'task'
  targetEntityId String? // ID of entity to update (local or Salesforce)
  fieldName      String? // Field to update (for UPDATE_* actions)
  proposedValue  Json // The value to set or task data

  // AI confidence and reasoning
  confidence Float   @default(0.5)
  reasoning  String? // Why AI suggested this action

  // Source context
  sourceText String? // The text that triggered this action

  // Execution tracking
  executedAt      DateTime?
  executionResult Json? // Result of action execution
  errorMessage    String? // Error if execution failed

  // Salesforce sync
  salesforceId String? // If synced to Salesforce (e.g., Task ID)

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  note Note @relation(fields: [noteId], references: [id], onDelete: Cascade)

  @@index([noteId])
  @@index([userId, status])
  @@index([status])
}

// ============================================
// NOTE INTELLIGENCE ENUMS
// ============================================

// Source type for notes (how it was created)
enum NoteSourceType {
  TEXT // Typed note
  VOICE // Voice recording transcription
  HANDWRITTEN // From smart capture OCR
  MEETING // From meeting transcript
  EMAIL // From email capture
}

// Processing status for AI-powered notes
enum NoteProcessingStatus {
  DRAFT // Just created, not processed
  TRANSCRIBING // Audio being transcribed
  PROCESSING // AI extraction in progress
  PENDING_REVIEW // Waiting for user approval of actions
  COMPLETED // All actions applied
  FAILED // Processing failed
}

// Types of actions AI can suggest from notes
enum NoteActionType {
  CREATE_TASK // Create a follow-up task
  UPDATE_OPPORTUNITY // Update opportunity fields (amount, stage, etc.)
  UPDATE_LEAD // Update lead fields (status, rating, etc.)
  UPDATE_ACCOUNT // Update account fields
  UPDATE_CONTACT // Update contact fields
  LINK_TO_ENTITY // Link note to CRM entity
  SYNC_TO_SALESFORCE // Sync note to Salesforce ContentNote
}

// Status of pending note actions
enum NoteActionStatus {
  PENDING // Waiting for user approval
  APPROVED // User approved, queued for execution
  EXECUTING // Currently being executed
  COMPLETED // Successfully executed
  REJECTED // User rejected
  FAILED // Execution failed
}

// ============================================
// CRM ENUMS
// ============================================

// ==================== LEAD ENUMS ====================
enum LeadSource {
  WEB
  PHONE_INQUIRY
  PARTNER_REFERRAL
  PURCHASED_LIST
  EXTERNAL_REFERRAL
  EMPLOYEE_REFERRAL
  TRADE_SHOW
  WEB_FORM
  SOCIAL_MEDIA
  EMAIL_CAMPAIGN
  WEBINAR
  COLD_CALL
  OTHER
}

enum LeadStatus {
  NEW
  CONTACTED
  QUALIFIED
  UNQUALIFIED
  NURTURING
  CONVERTED
  LOST
}

enum LeadRating {
  HOT
  WARM
  COLD
}

enum BuyingIntent {
  HIGH
  MEDIUM
  LOW
  UNKNOWN
}

// ==================== ACCOUNT ENUMS ====================
enum AccountType {
  PROSPECT
  CUSTOMER
  PARTNER
  RESELLER
  COMPETITOR
  OTHER
}

enum AccountStatus {
  ACTIVE
  INACTIVE
  PENDING
  CHURNED
}

enum AccountRating {
  HOT
  WARM
  COLD
}

enum ChurnRisk {
  HIGH
  MEDIUM
  LOW
  NONE
}

// ==================== CONTACT ENUMS ====================
enum ContactRole {
  CHAMPION
  ECONOMIC_BUYER
  DECISION_MAKER
  INFLUENCER
  END_USER
  GATEKEEPER
  BLOCKER
  TECHNICAL_BUYER
}

enum SeniorityLevel {
  IC // Individual Contributor
  MANAGER
  SENIOR_MANAGER
  DIRECTOR
  SENIOR_DIRECTOR
  VP
  SVP
  C_LEVEL
  BOARD
  OWNER
}

enum BuyingPower {
  NONE
  INFLUENCER
  RECOMMENDER
  DECISION_MAKER
  BUDGET_HOLDER
}

enum InfluenceLevel {
  HIGH
  MEDIUM
  LOW
}

enum ContactStatus {
  ACTIVE
  INACTIVE
  BOUNCED
  UNSUBSCRIBED
}

// ==================== OPPORTUNITY ENUMS ====================
enum OpportunitySource {
  EXISTING_CUSTOMER
  NEW_CUSTOMER
  PARTNER
  EMPLOYEE_REFERRAL
  EXTERNAL_REFERRAL
  ADVERTISEMENT
  TRADE_SHOW
  WEB
  WORD_OF_MOUTH
  OTHER
}

enum OpportunityType {
  NEW_BUSINESS
  EXISTING_BUSINESS
  UPSELL
  CROSS_SELL
  RENEWAL
}

enum OpportunityStage {
  PROSPECTING
  QUALIFICATION
  NEEDS_ANALYSIS
  VALUE_PROPOSITION
  DECISION_MAKERS_IDENTIFIED
  PERCEPTION_ANALYSIS
  PROPOSAL_PRICE_QUOTE
  NEGOTIATION_REVIEW
  CLOSED_WON
  CLOSED_LOST
}

// ==================== TASK ENUMS ====================
enum TaskStatus {
  NOT_STARTED
  IN_PROGRESS
  WAITING
  DEFERRED
  COMPLETED
}

enum TaskPriority {
  LOW
  NORMAL
  HIGH
  URGENT
}

// ==================== ACTIVITY ENUMS ====================
enum ActivityType {
  CALL
  EMAIL
  MEETING
  DEMO
  PRESENTATION
  PROPOSAL_SENT
  CONTRACT_SENT
  FOLLOW_UP
  RESEARCH
  INTERNAL_NOTE
  LINKEDIN_MESSAGE
  SITE_VISIT
  WEBINAR
  OTHER
}

enum Sentiment {
  VERY_POSITIVE
  POSITIVE
  NEUTRAL
  NEGATIVE
  VERY_NEGATIVE
}

// ==================== QUOTE ENUMS ====================
enum QuoteStatus {
  DRAFT
  SENT
  ACCEPTED
  REJECTED
  EXPIRED
}

// ==================== CONTRACT ENUMS ====================
enum ContractStatus {
  DRAFT
  IN_REVIEW
  APPROVED
  ACTIVATED
  EXPIRED
  TERMINATED
}

// ==================== CAMPAIGN ENUMS ====================
enum CampaignStatus {
  PLANNED
  ACTIVE
  COMPLETED
  ABORTED
}

// ==================== INSIGHT ENUMS ====================
enum InsightType {
  PAIN_POINT
  BUYING_SIGNAL
  RISK_ALERT
  OPPORTUNITY
  COMPETITOR_MENTION
  BUDGET_INFO
  TIMELINE_INFO
  OBJECTION
  DECISION_CRITERIA
  NEXT_ACTION
  FEATURE_REQUEST
  PRICING_CONCERN
  TECHNICAL_REQUIREMENT
}

enum Priority {
  LOW
  MEDIUM
  HIGH
  URGENT
}

// ==================== MEETING INTELLIGENCE ENUMS ====================
enum MeetingPlatform {
  ZOOM
  TEAMS
  GOOGLE_MEET
  WEBEX
  OTHER
}

enum MeetingSessionStatus {
  SCHEDULED
  IN_PROGRESS
  COMPLETED
  CANCELLED
  FAILED
}

enum RecordingStatus {
  NOT_STARTED
  RECORDING
  PROCESSING
  COMPLETED
  FAILED
}

enum EngagementLevel {
  VERY_LOW
  LOW
  MEDIUM
  HIGH
  VERY_HIGH
}

enum RiskLevel {
  NONE
  LOW
  MEDIUM
  HIGH
  CRITICAL
}

// Meeting RSVP status for tracking participant responses
enum MeetingRsvpStatus {
  PENDING
  ACCEPTED
  DECLINED
  TENTATIVE
  NO_RESPONSE
}

// ==================== MEETING INTELLIGENCE MODELS ====================

// Main meeting session model
model MeetingSession {
  id String @id @default(cuid())

  // Platform details
  platform          MeetingPlatform
  externalMeetingId String? // Platform-specific meeting ID
  meetingUrl        String? // URL to join the meeting

  // Meeting info
  title          String
  description    String?
  scheduledStart DateTime
  scheduledEnd   DateTime?
  actualStart    DateTime?
  actualEnd      DateTime?
  duration       Int? // Actual duration in minutes
  timezone       String    @default("UTC")

  // Status tracking
  status          MeetingSessionStatus @default(SCHEDULED)
  recordingStatus RecordingStatus      @default(NOT_STARTED)

  // Recording and transcript
  recordingUrl      String? // URL to the recording
  recordingDuration Int? // Recording duration in seconds
  transcriptText    String? // Full transcript text
  transcriptUrl     String? // URL to transcript file

  // Bot/Agent info
  botJoinedAt DateTime?
  botLeftAt   DateTime?
  botStatus   String? // "joining", "in_meeting", "left", "error"

  // CRM relationships
  ownerId String
  owner   User   @relation(fields: [ownerId], references: [id])

  leadId String?
  lead   Lead?   @relation(fields: [leadId], references: [id])

  accountId String?
  account   Account? @relation(fields: [accountId], references: [id])

  opportunityId String?
  opportunity   Opportunity? @relation(fields: [opportunityId], references: [id])

  // Related entities
  participants       MeetingParticipant[]
  transcriptSegments TranscriptSegment[]
  analysis           MeetingAnalysis?
  insights           MeetingInsight[]
  tasks              Task[]                  @relation("MeetingGeneratedTasks")
  activities         Activity[]              @relation("MeetingGeneratedActivities")
  inviteResponses    MeetingInviteResponse[]
  pendingActions     PendingMeetingAction[]

  // Salesforce integration
  salesforceEventId String? // Linked Salesforce Event ID for sync

  // Cancellation tracking
  cancelledAt                  DateTime?
  cancelledBy                  String?
  cancellationReason           String?
  cancellationNotificationSent Boolean   @default(false)

  // Metadata
  metadata  Json? // Additional platform-specific data
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@index([ownerId])
  @@index([leadId])
  @@index([accountId])
  @@index([opportunityId])
  @@index([platform])
  @@index([status])
  @@index([scheduledStart])
  @@index([externalMeetingId])
  @@map("meeting_sessions")
}

// Meeting participant tracking
model MeetingParticipant {
  id String @id @default(cuid())

  // Session reference
  meetingSessionId String
  meetingSession   MeetingSession @relation(fields: [meetingSessionId], references: [id], onDelete: Cascade)

  // Participant info
  name       String
  email      String?
  role       String? // "host", "co-host", "attendee", "presenter"
  isInternal Boolean @default(false)
  isBot      Boolean @default(false)

  // Contact reference (if known)
  contactId String?
  contact   Contact? @relation(fields: [contactId], references: [id])

  // RSVP/Response tracking
  responseStatus     MeetingRsvpStatus @default(PENDING)
  responseAt         DateTime?
  responseNote       String?
  inviteSentAt       DateTime?
  reminderSentAt     DateTime?
  cancellationSentAt DateTime?

  // Attendance tracking
  joinedAt DateTime?
  leftAt   DateTime?
  duration Int? // Time in meeting in seconds

  // Participation metrics
  speakingDuration Int? // Seconds spent speaking
  speakingCount    Int? // Number of speaking turns
  engagementLevel  EngagementLevel?

  // Platform-specific ID
  externalParticipantId String?

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@index([meetingSessionId])
  @@index([contactId])
  @@index([email])
  @@map("meeting_participants")
}

// Meeting invite response history - audit trail for RSVP changes
model MeetingInviteResponse {
  id String @id @default(cuid())

  // Session reference
  meetingSessionId String
  meetingSession   MeetingSession @relation(fields: [meetingSessionId], references: [id], onDelete: Cascade)

  // Participant info
  participantEmail String
  participantName  String?

  // Response details
  previousStatus MeetingRsvpStatus?
  newStatus      MeetingRsvpStatus
  responseSource String? // "calendar", "email", "manual", "zoom", "teams"
  responseNote   String?

  // Metadata
  rawResponse Json? // Raw response data from platform
  createdAt   DateTime @default(now())

  @@index([meetingSessionId])
  @@index([participantEmail])
  @@index([createdAt])
  @@map("meeting_invite_responses")
}

// Transcript segments with speaker attribution
model TranscriptSegment {
  id String @id @default(cuid())

  // Session reference
  meetingSessionId String
  meetingSession   MeetingSession @relation(fields: [meetingSessionId], references: [id], onDelete: Cascade)

  // Segment content
  speakerName  String
  speakerEmail String?
  text         String

  // Timing
  startTime Float // Seconds from start
  endTime   Float // Seconds from start
  duration  Float // Duration in seconds

  // Analysis metadata
  sentiment  String? // "positive", "negative", "neutral"
  confidence Float? // Confidence score 0-1
  language   String? @default("en")

  // Keywords/topics detected
  keywords String[]
  topics   String[]

  createdAt DateTime @default(now())

  @@index([meetingSessionId])
  @@index([startTime])
  @@index([speakerName])
  @@map("transcript_segments")
}

// AI-generated meeting analysis
model MeetingAnalysis {
  id String @id @default(cuid())

  // Session reference (1:1)
  meetingSessionId String         @unique
  meetingSession   MeetingSession @relation(fields: [meetingSessionId], references: [id], onDelete: Cascade)

  // Summary content
  summary     String // Executive summary
  keyPoints   String[] // Main discussion points
  decisions   String[] // Decisions made
  actionItems Json[] // {task, assignee, dueDate, priority}

  // Sentiment analysis
  overallSentiment String? // "positive", "negative", "neutral", "mixed"
  sentimentScore   Float? // -1 to 1

  // Sales-specific analysis
  buyingSignals      String[] // Detected buying signals
  objections         String[] // Objections raised
  nextSteps          String[] // Suggested next steps
  competitorMentions String[] // Competitors mentioned

  // Deal impact
  dealRiskLevel    RiskLevel?
  dealRiskFactors  String[]
  opportunityScore Float? // 0-100 score change indicator

  // Topics covered
  topicsDiscussed String[]
  questionsAsked  Json[] // {question, askedBy, answered}

  // Follow-up recommendations
  followUpRecommendations Json[] // {type, description, priority, suggestedDate}

  // Processing info
  modelUsed      String? // AI model used for analysis
  processingTime Int? // Time to generate analysis in ms

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@map("meeting_analyses")
}

// Individual insights extracted from meetings
model MeetingInsight {
  id String @id @default(cuid())

  // Session reference
  meetingSessionId String
  meetingSession   MeetingSession @relation(fields: [meetingSessionId], references: [id], onDelete: Cascade)

  // Insight details
  type        InsightType
  title       String
  description String

  // Source reference
  sourceText      String? // The transcript text that generated this
  sourceTimestamp Float? // When in the meeting this occurred
  speakerName     String? // Who said it

  // CRM Impact - for intelligent entity tracking
  impactedEntity   String? // "Opportunity", "Lead", "Account", etc.
  impactedEntityId String? // ID of the impacted entity
  suggestedAction  String? // AI-recommended action to take

  // Priority and status
  priority   Priority  @default(MEDIUM)
  isActioned Boolean   @default(false)
  actionedAt DateTime?
  actionedBy String?

  // Confidence
  confidence Float? // 0-1 confidence score

  // Metadata
  metadata Json? // Additional context

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@index([meetingSessionId])
  @@index([type])
  @@index([priority])
  @@index([isActioned])
  @@index([impactedEntity, impactedEntityId])
  @@map("meeting_insights")
}

// =============================================================================
// VIDEO COACHING - Sales Practice & AI Feedback (MVP #2)
// =============================================================================

enum CoachingScenario {
  ELEVATOR_PITCH
  DISCOVERY_CALL
  DEMO_PRESENTATION
  OBJECTION_HANDLING
  NEGOTIATION
  CLOSING
  COLD_CALL
  FOLLOW_UP
  GENERAL_PRACTICE
}

enum CoachingSessionStatus {
  RECORDING
  UPLOADING
  TRANSCRIBING
  ANALYZING
  COMPLETED
  FAILED
}

// Video coaching session - user records practice and gets AI feedback
model CoachingSession {
  id String @id @default(cuid())

  // User who recorded this session
  userId String
  user   User   @relation(fields: [userId], references: [id], onDelete: Cascade)

  // Session details
  title    String? // Optional title (auto-generated if not provided)
  scenario CoachingScenario      @default(GENERAL_PRACTICE)
  status   CoachingSessionStatus @default(RECORDING)

  // Optional: Link to a specific deal they're practicing for
  opportunityId String?
  accountId     String?

  // Recording details
  videoUrl        String? // URL to stored video file
  audioUrl        String? // URL to extracted audio (if separate)
  thumbnailUrl    String? // Preview thumbnail
  durationSeconds Int? // Recording duration
  fileSize        Int? // File size in bytes

  // Transcription
  transcription         String? // Full transcribed text
  transcriptionSegments Json[] // [{start, end, text, confidence}]

  // AI Coaching Feedback
  overallScore Int? // 0-100 overall performance score
  feedback     Json? // Structured AI feedback
  // feedback structure:
  // {
  //   summary: string,
  //   strengths: string[],
  //   improvements: string[],
  //   metrics: {
  //     paceWordsPerMinute: number,
  //     fillerWordCount: number,
  //     fillerWords: string[],
  //     clarityScore: number,
  //     confidenceScore: number,
  //     valuePropsmentioned: string[],
  //     keyPointsCovered: string[],
  //     keyPointsMissed: string[]
  //   },
  //   recommendations: {
  //     immediate: string[],
  //     practice: string[],
  //     resources: string[]
  //   },
  //   dealSpecificAdvice: string | null
  // }

  // Processing info
  processingTimeMs Int? // Time to analyze in milliseconds
  errorMessage     String? // Error details if failed

  // Metadata
  metadata Json? // Additional context (browser, device, etc.)

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  // Digital Worker - Playbook Analysis
  playbookAnalysis PlaybookAnalysis?

  @@index([userId])
  @@index([status])
  @@index([scenario])
  @@index([createdAt])
  @@map("coaching_sessions")
}

// CRM Audit Log - tracks all changes made by Meeting Intelligence
model CrmAuditLog {
  id String @id @default(cuid())

  // Change details
  changeType String // TASK_CREATED, OPPORTUNITY_UPDATED, etc.
  source     String // MEETING_INTELLIGENCE, AI_ANALYSIS, USER_MANUAL

  // Entity reference
  entityType String // Task, Opportunity, Lead, etc.
  entityId   String

  // Meeting context
  meetingSessionId String?
  userId           String?

  // Change data (JSON strings for flexibility)
  previousValue String? // JSON of previous state
  newValue      String? // JSON of new state
  metadata      String? // JSON of additional context

  createdAt DateTime @default(now())

  @@index([entityType, entityId])
  @@index([meetingSessionId])
  @@index([changeType])
  @@index([createdAt])
  @@index([source])
  @@map("crm_audit_logs")
}

// Pending Meeting Actions - Human-in-the-loop approval queue
// Stores proposed CRM actions from meeting analysis awaiting user approval
model PendingMeetingAction {
  id String @id @default(cuid())

  // Meeting context
  meetingSessionId String
  meetingSession   MeetingSession @relation(fields: [meetingSessionId], references: [id], onDelete: Cascade)
  userId           String
  user             User           @relation(fields: [userId], references: [id], onDelete: Cascade)

  // Action details
  actionType  PendingActionType
  title       String // Human-readable action title
  description String? // Detailed description of what will happen

  // Target entity
  targetEntity   String // Task, Lead, Opportunity, Contact, Account, Activity
  targetEntityId String? // Existing entity ID (for updates)

  // Proposed data (JSON)
  proposedData     Json // The data to create/update
  originalAnalysis Json? // Reference to source analysis

  // Data source scope
  dataSource           DataSourceType @default(LOCAL) // LOCAL or SALESFORCE
  salesforceObjectType String? // SF object type if Salesforce

  // Priority and confidence
  priority   Priority @default(MEDIUM)
  confidence Float? // AI confidence score 0-1

  // Status
  status          PendingActionStatus @default(PENDING)
  reviewedAt      DateTime?
  reviewedBy      String?
  rejectionReason String?

  // Execution result
  executedAt     DateTime?
  resultEntityId String? // ID of created/updated entity
  executionError String?

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@index([meetingSessionId])
  @@index([userId])
  @@index([status])
  @@index([actionType])
  @@index([dataSource])
  @@index([createdAt])
  @@map("pending_meeting_actions")
}

enum PendingActionType {
  CREATE_TASK
  CREATE_ACTIVITY
  UPDATE_OPPORTUNITY
  UPDATE_LEAD
  UPDATE_CONTACT
  UPDATE_ACCOUNT
  CREATE_NOTE
  SYNC_TO_SALESFORCE
}

enum PendingActionStatus {
  PENDING // Awaiting user review
  APPROVED // User approved, ready to execute
  EXECUTING // Currently being executed
  COMPLETED // Successfully executed
  REJECTED // User rejected
  FAILED // Execution failed
  EXPIRED // Not acted upon in time
}

enum DataSourceType {
  LOCAL
  SALESFORCE
}

// ============================================
// LICENSING SYSTEM
// ============================================

// License tier/plan type enum
enum LicenseTier {
  FREE
  STARTER
  PROFESSIONAL
  ENTERPRISE
  CUSTOM
}

// License status enum
enum LicenseStatus {
  ACTIVE
  EXPIRED
  SUSPENDED
  CANCELLED
  PENDING
  TRIAL
}

// License types define the available license plans
model LicenseType {
  id String @id @default(cuid())

  // Identity
  name        String      @unique // e.g., "Professional Plan", "Enterprise Plan"
  slug        String      @unique // e.g., "professional", "enterprise"
  description String?
  tier        LicenseTier @default(PROFESSIONAL)

  // Pricing (stored in cents for precision)
  priceMonthly Int? // Monthly price in cents
  priceYearly  Int? // Yearly price in cents
  currency     String @default("USD")

  // Duration defaults
  defaultDurationDays Int @default(365) // Default license duration
  trialDurationDays   Int @default(14) // Trial period duration

  // Usage limits
  maxUsers         Int? // Max users allowed (null = unlimited)
  maxConversations Int? // Max AI conversations per month
  maxMeetings      Int? // Max meetings per month
  maxDocuments     Int? // Max documents indexed
  maxApiCalls      Int? // Max API calls per day

  // Feature entitlements (which features are included)
  features LicenseFeature[]

  // Status
  isActive  Boolean @default(true)
  isPublic  Boolean @default(true) // Show in pricing page
  sortOrder Int     @default(0)

  // Metadata
  metadata Json? // Additional plan-specific settings

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  // Relations
  userLicenses         UserLicense[]
  preGeneratedKeys     PreGeneratedLicenseKey[]
  organizationLicenses OrganizationLicense[]
  subscriptions        Subscription[]

  @@index([tier])
  @@index([isActive])
  @@map("license_types")
}

// License features - granular feature control
model LicenseFeature {
  id String @id @default(cuid())

  // Feature identity
  featureKey  String  @unique // e.g., "ai_chat", "crm_salesforce", "meetings"
  name        String // Display name
  description String?
  category    String // ai, crm, meetings, data, integrations, advanced
  icon        String? // Lucide icon name

  // Feature configuration
  isEnabled       Boolean @default(true) // Master switch
  requiresLicense Boolean @default(true) // If false, available to all

  // Usage limits (null = unlimited, 0 = disabled)
  defaultLimit Int? // Default usage limit

  // Feature metadata
  metadata Json? // Feature-specific configuration

  // Sorting & display
  sortOrder Int @default(0)

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  // Relations - which license types include this feature
  licenseTypes LicenseType[]
  entitlements LicenseEntitlement[]

  @@index([category])
  @@index([featureKey])
  @@map("license_features")
}

// User license assignments - links users to license types
model UserLicense {
  id String @id @default(cuid())

  // User and license type
  userId        String
  licenseTypeId String

  // Organization (if issued from org license pool)
  organizationId String? // If set, this license was allocated from an org pool

  // License period
  startDate DateTime @default(now())
  endDate   DateTime // Expiry date

  // Status
  status LicenseStatus @default(ACTIVE)

  // License key for validation
  licenseKey String @unique @default(cuid())

  // Trial information
  isTrial      Boolean   @default(false)
  trialEndDate DateTime?

  // Auto-renewal
  autoRenew Boolean @default(true)

  // Custom overrides for this specific user license
  customLimits Json? // Override default limits

  // Notes
  notes String?

  // Audit fields
  assignedBy     String? // Admin who assigned the license
  lastVerifiedAt DateTime? // Last time license was validated

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  // Relations
  user         User                 @relation(fields: [userId], references: [id], onDelete: Cascade)
  licenseType  LicenseType          @relation(fields: [licenseTypeId], references: [id], onDelete: Cascade)
  entitlements LicenseEntitlement[]
  usageRecords LicenseUsage[]

  @@unique([userId, licenseTypeId])
  @@index([userId])
  @@index([licenseTypeId])
  @@index([organizationId])
  @@index([status])
  @@index([endDate])
  @@index([licenseKey])
  @@map("user_licenses")
}

// Pre-generated license keys - for bulk key generation before user assignment
model PreGeneratedLicenseKey {
  id String @id @default(cuid())

  // License key
  licenseKey String @unique

  // License type this key is for
  licenseTypeId String

  // Key status
  status PreGeneratedKeyStatus @default(AVAILABLE)

  // Configuration
  durationDays Int     @default(365)
  isTrial      Boolean @default(false)

  // When claimed, store the user license reference
  claimedByUserId String?
  claimedAt       DateTime?
  userLicenseId   String? // Reference to created UserLicense

  // Expiry for unclaimed keys (optional)
  expiresAt DateTime?

  // Audit
  generatedBy String? // Admin who generated
  notes       String?

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  // Relations
  licenseType LicenseType @relation(fields: [licenseTypeId], references: [id], onDelete: Cascade)
  claimedBy   User?       @relation("ClaimedLicenseKeys", fields: [claimedByUserId], references: [id])

  @@index([status])
  @@index([licenseTypeId])
  @@index([licenseKey])
  @@map("pre_generated_license_keys")
}

enum PreGeneratedKeyStatus {
  AVAILABLE // Ready to be claimed
  CLAIMED // Already used by a user
  EXPIRED // Key expired before being claimed
  REVOKED // Manually revoked by admin
}

// License entitlements - specific feature access per user license
model LicenseEntitlement {
  id String @id @default(cuid())

  userLicenseId String
  featureId     String

  // Override settings for this specific entitlement
  isEnabled    Boolean @default(true)
  usageLimit   Int? // Custom limit (null = use default)
  currentUsage Int     @default(0)

  // Usage tracking period
  usagePeriod   String    @default("monthly") // daily, weekly, monthly, yearly
  periodResetAt DateTime? // When the usage counter resets

  // Metadata
  metadata Json?

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  // Relations
  userLicense UserLicense    @relation(fields: [userLicenseId], references: [id], onDelete: Cascade)
  feature     LicenseFeature @relation(fields: [featureId], references: [id], onDelete: Cascade)

  @@unique([userLicenseId, featureId])
  @@index([userLicenseId])
  @@index([featureId])
  @@map("license_entitlements")
}

// License usage tracking - detailed usage history
model LicenseUsage {
  id String @id @default(cuid())

  userLicenseId String
  featureKey    String // Which feature was used

  // Usage details
  usageCount Int      @default(1)
  usageDate  DateTime @default(now())

  // Context
  action       String? // What action was performed
  resourceId   String? // Related resource ID
  resourceType String? // Type of resource

  // Metadata
  metadata Json?

  createdAt DateTime @default(now())

  // Relations
  userLicense UserLicense @relation(fields: [userLicenseId], references: [id], onDelete: Cascade)

  @@index([userLicenseId])
  @@index([featureKey])
  @@index([usageDate])
  @@map("license_usage")
}

// License audit log - tracks all license-related changes
model LicenseAuditLog {
  id String @id @default(cuid())

  // What changed
  action     String // ASSIGN, REVOKE, RENEW, EXPIRE, SUSPEND, UPGRADE, DOWNGRADE
  entityType String // UserLicense, LicenseType, LicenseFeature
  entityId   String

  // Who made the change
  performedBy      String // User ID of admin
  performedByName  String?
  performedByEmail String?

  // Change details
  oldValue Json?
  newValue Json?
  reason   String?

  // Context
  ipAddress String?
  userAgent String?

  createdAt DateTime @default(now())

  @@index([entityType, entityId])
  @@index([performedBy])
  @@index([action])
  @@index([createdAt])
  @@map("license_audit_logs")
}

// ============================================
// ORGANIZATION SYSTEM (Enterprise B2B)
// ============================================

// Organization status enum
enum OrganizationStatus {
  ACTIVE // Organization is active and operational
  SUSPENDED // Temporarily suspended (e.g., payment issues)
  PENDING // Awaiting approval or setup completion
  INACTIVE // Deactivated but data preserved
}

// Organization member role enum
enum OrganizationMemberRole {
  OWNER // Full control, can delete organization
  ADMIN // Can manage members, licenses, settings
  MANAGER // Can manage team members, view reports
  MEMBER // Standard user access
}

// Organization code status enum
enum OrganizationCodeStatus {
  ACTIVE // Code can be used for registration
  EXHAUSTED // Max uses reached
  EXPIRED // Code has expired
  REVOKED // Manually disabled by admin
}

// Organization - represents an enterprise customer/company
model Organization {
  id String @id @default(cuid())

  // Identity
  name   String // Company name
  slug   String  @unique // URL-friendly identifier
  domain String? @unique // Company domain for email validation (optional)

  // Contact information
  contactEmail String // Primary contact email
  contactPhone String?
  billingEmail String? // Billing contact (defaults to contactEmail)

  // Address
  address    String?
  city       String?
  state      String?
  country    String?
  postalCode String?

  // Branding
  logoUrl      String?
  primaryColor String? // Brand color hex

  // Status
  status OrganizationStatus @default(PENDING)

  // Configuration
  settings Json? // Organization-specific settings
  metadata Json? // Additional metadata

  // Limits (can override license defaults)
  maxMembers Int? // Max organization members (null = use license limit)

  // Audit fields
  createdBy String? // Admin who created
  notes     String?

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  // Relations
  members  OrganizationMember[]
  codes    OrganizationCode[]
  licenses OrganizationLicense[]

  // Integration configurations (organization-scoped for security)
  integrationConfigs IntegrationConfig[] @relation("OrganizationIntegrations")

  // CRM entity relations (multi-tenant)
  leads          Lead[]          @relation("OrganizationLeads")
  accounts       Account[]       @relation("OrganizationAccounts")
  contacts       Contact[]       @relation("OrganizationContacts")
  opportunities  Opportunity[]   @relation("OrganizationOpportunities")
  quotes         Quote[]         @relation("OrganizationQuotes")
  orders         Order[]         @relation("OrganizationOrders")
  tasks          Task[]          @relation("OrganizationTasks")
  activities     Activity[]      @relation("OrganizationActivities")
  contracts      Contract[]      @relation("OrganizationContracts")
  crmNotes       Note[]          @relation("OrganizationNotes")
  pipelines      Pipeline[]      @relation("OrganizationPipelines")
  pipelineStages PipelineStage[] @relation("OrganizationPipelineStages")
  emailThreads   EmailThread[]   @relation("OrganizationEmailThreads")
  campaigns      Campaign[]      @relation("OrganizationCampaigns")
  products       Product[]       @relation("OrganizationProducts")
  territories    Territory[]     @relation("OrganizationTerritories")
  playbooks      Playbook[]      @relation("OrganizationPlaybooks")

  // Siebel CRM Concepts
  competitors        Competitor[]       @relation("OrganizationCompetitors")
  assets             Asset[]            @relation("OrganizationAssets")
  supportContracts   SupportContract[]  @relation("OrganizationSupportContracts")
  partners           Partner[]          @relation("OrganizationPartners")
  dealRegistrations  DealRegistration[] @relation("OrganizationDealRegistrations")

  // Outcome-based billing
  outcomePricingPlan OutcomePricingPlan?

  // Approval Workflows
  approvalWorkflows  ApprovalWorkflow[]  @relation("OrganizationApprovalWorkflows")
  approvalRequests   ApprovalRequest[]   @relation("OrganizationApprovalRequests")

  // Integration persistence
  integrationSyncLogs        IntegrationSyncLog[]        @relation("OrganizationSyncLogs")
  integrationEntityMappings  IntegrationEntityMapping[]   @relation("OrganizationEntityMappings")
  integrationAttachments     IntegrationAttachment[]      @relation("OrganizationIntegrationAttachments")

  @@index([status])
  @@index([domain])
  @@index([slug])
  @@map("organizations")
}

// OrganizationCode - registration codes for joining an organization
model OrganizationCode {
  id String @id @default(cuid())

  // Code details
  code           String @unique // The registration code (e.g., "ACME-2024-ENT")
  organizationId String

  // Code configuration
  description String? // Internal description

  // Usage limits
  maxUses     Int? // Max times code can be used (null = unlimited)
  currentUses Int  @default(0)

  // Validity period
  validFrom  DateTime  @default(now())
  validUntil DateTime? // Expiry date (null = never expires)

  // Status
  status OrganizationCodeStatus @default(ACTIVE)

  // Default role for users who register with this code
  defaultRole OrganizationMemberRole @default(MEMBER)

  // Auto-assign license on registration
  autoAssignLicenseId String? // If set, assign this license type on join

  // Audit fields
  createdBy String? // Admin who created the code
  notes     String?

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  // Relations
  organization Organization @relation(fields: [organizationId], references: [id], onDelete: Cascade)

  @@index([code])
  @@index([organizationId])
  @@index([status])
  @@map("organization_codes")
}

// OrganizationMember - links users to organizations
model OrganizationMember {
  id String @id @default(cuid())

  // User and organization
  userId         String
  organizationId String

  // Role within organization
  role OrganizationMemberRole @default(MEMBER)

  // Status
  isActive Boolean @default(true)

  // Join information
  joinedAt         DateTime @default(now())
  invitedBy        String? // User ID who invited/approved
  registrationCode String? // Code used to join (for audit)

  // Department/Team info (optional)
  department String?
  title      String?

  // Metadata
  metadata Json?

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  // Relations
  user         User         @relation(fields: [userId], references: [id], onDelete: Cascade)
  organization Organization @relation(fields: [organizationId], references: [id], onDelete: Cascade)

  @@unique([userId, organizationId])
  @@index([userId])
  @@index([organizationId])
  @@index([role])
  @@map("organization_members")
}

// OrganizationLicense - license pools for organizations (seat-based licensing)
model OrganizationLicense {
  id String @id @default(cuid())

  // Organization and license type
  organizationId String
  licenseTypeId  String

  // License period
  startDate DateTime @default(now())
  endDate   DateTime // Expiry date

  // Status
  status LicenseStatus @default(ACTIVE)

  // Seat management
  totalSeats Int @default(1) // Total purchased seats
  usedSeats  Int @default(0) // Currently assigned seats

  // License key for organization-level validation
  licenseKey String @unique @default(cuid())

  // Auto-renewal
  autoRenew Boolean @default(true)

  // Custom overrides
  customLimits Json? // Override default limits for this org

  // Purchase/Contract reference
  purchaseOrderId String?
  contractId      String?

  // Notes
  notes String?

  // Audit fields
  assignedBy     String? // Admin who assigned
  lastVerifiedAt DateTime?

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  // Relations
  organization Organization @relation(fields: [organizationId], references: [id], onDelete: Cascade)
  licenseType  LicenseType  @relation(fields: [licenseTypeId], references: [id], onDelete: Cascade)

  @@unique([organizationId, licenseTypeId])
  @@index([organizationId])
  @@index([licenseTypeId])
  @@index([status])
  @@index([endDate])
  @@index([licenseKey])
  @@map("organization_licenses")
}

// ============================================
// ADMIN CONFIGURATION SYSTEM
// ============================================

// System-wide configuration settings
model SystemConfig {
  id           String  @id @default(cuid())
  key          String  @unique
  value        String // JSON-encoded value
  category     String // general, ai, meeting_intelligence, etc.
  type         String // string, number, boolean, json, secret, select
  label        String
  description  String?
  isSecret     Boolean @default(false)
  validation   Json? // Validation rules (min, max, pattern, options)
  defaultValue String? // JSON-encoded default

  updatedAt DateTime @updatedAt
  updatedBy String?

  @@index([category])
  @@map("system_configs")
}

// Feature flags for gradual rollout and A/B testing
model FeatureFlag {
  id                String   @id @default(cuid())
  key               String   @unique
  name              String
  description       String?
  enabled           Boolean  @default(false)
  category          String // ai, crm, meetings, analytics, integrations, experimental
  rolloutPercentage Int      @default(100) // 0-100 for gradual rollout
  allowedRoles      String[] // admin, manager, user, viewer
  allowedUsers      String[] // Specific user IDs
  metadata          Json? // Additional configuration

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@index([category])
  @@index([enabled])
  @@map("feature_flags")
}

// Admin audit log - tracks all admin actions
model AdminAuditLog {
  id         String  @id @default(cuid())
  action     String // CREATE, UPDATE, DELETE, CONFIG_CHANGE, etc.
  entityType String // SystemConfig, FeatureFlag, User, etc.
  entityId   String
  userId     String
  userName   String?
  userEmail  String?
  oldValue   Json? // Previous state
  newValue   Json? // New state
  ipAddress  String?
  userAgent  String?
  metadata   Json? // Additional context

  timestamp DateTime @default(now())

  @@index([userId])
  @@index([action])
  @@index([entityType])
  @@index([timestamp])
  @@map("admin_audit_logs")
}

// Application Error & Transaction Log - Comprehensive logging for all system events
model ApplicationLog {
  id String @id @default(cuid())

  // Log categorization
  level    String // ERROR, WARN, INFO, DEBUG, TRACE
  category String // API, AUTH, DATABASE, INTEGRATION, AI, MEETING, EMAIL, SYSTEM, TRANSACTION
  source   String // Service/Controller name that generated the log

  // Error/Event details
  message String // Human-readable message
  code    String? // Error code (e.g., ERR_AUTH_001, TX_PAYMENT_FAILED)

  // Context information
  userId        String? // User who triggered the action (if applicable)
  sessionId     String? // Session identifier
  requestId     String? // Unique request ID for tracing
  correlationId String? // ID to correlate related logs across services

  // Request details (for API logs)
  method     String? // HTTP method (GET, POST, etc.)
  path       String? // API endpoint path
  statusCode Int? // HTTP response status code
  duration   Int? // Request duration in milliseconds
  ipAddress  String? // Client IP address
  userAgent  String? // Client user agent

  // Error-specific fields
  errorType  String? // Exception/Error class name
  stackTrace String? // Full stack trace (for errors)

  // Transaction details (for transactional logging)
  transactionType   String? // LEAD_CREATE, PAYMENT, EMAIL_SEND, AI_COMPLETION, etc.
  transactionId     String? // External transaction ID if applicable
  transactionStatus String? // PENDING, SUCCESS, FAILED, ROLLED_BACK

  // Related entity
  entityType String? // Lead, Account, Opportunity, Meeting, etc.
  entityId   String? // ID of the affected entity

  // Additional context
  metadata Json? // Flexible JSON for additional data
  tags     String[] // Tags for filtering (e.g., ['critical', 'payment', 'retry-needed'])

  // Environment context
  environment    String? // production, staging, development
  serverInstance String? // Server/pod identifier

  // Client/Mobile specific fields (for CLIENT category logs)
  clientSource String? // web, mobile_ios, mobile_android, tablet_ios, tablet_android, desktop
  screenName   String? // Screen/page where error occurred (e.g., "DashboardPage", "QuotesPage")
  platform     String? // iOS, Android, Web, macOS, Windows
  osVersion    String? // OS version (e.g., "17.2", "14", "Windows 11")
  appVersion   String? // App version (e.g., "1.0.0", "2.1.3")
  buildNumber  String? // Build number for precise version tracking
  deviceModel  String? // Device model (e.g., "iPhone 14 Pro", "iPad Pro 12.9", "Pixel 8")
  deviceId     String? // Anonymous device identifier for tracking device-specific issues
  isFatal      Boolean @default(false) // Whether this was a fatal/crash error

  createdAt DateTime @default(now())

  // Indexes for efficient querying
  @@index([level])
  @@index([category])
  @@index([source])
  @@index([userId])
  @@index([requestId])
  @@index([correlationId])
  @@index([transactionType])
  @@index([transactionStatus])
  @@index([entityType, entityId])
  @@index([createdAt])
  @@index([tags])
  @@index([clientSource])
  @@index([screenName])
  @@index([platform])
  @@index([appVersion])
  @@index([isFatal])
  @@map("application_logs")
}

// Integration configuration for third-party services (organization-scoped)
model IntegrationConfig {
  id          String    @id @default(cuid())
  provider    String // salesforce, hubspot, zoom, teams, etc.
  name        String
  status      String    @default("disconnected") // connected, disconnected, error, pending
  credentials Json? // Encrypted credentials (API keys, tokens, etc.)
  settings    Json? // Provider-specific settings
  lastSyncAt  DateTime?
  syncError   String?

  // Multi-tenancy: scope to organization for data isolation
  organizationId String
  organization   Organization @relation("OrganizationIntegrations", fields: [organizationId], references: [id], onDelete: Cascade)

  // Audit trail: who configured this integration
  configuredById String? // User ID who set up/modified this config
  configuredAt   DateTime?

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  // Each organization can have ONE config per provider (prevents duplicates within org)
  @@unique([organizationId, provider])
  @@index([organizationId])
  @@index([provider])
  @@map("integration_configs")
}

// ==================== API USAGE TRACKING ====================

// Enum for API service types
enum ApiServiceType {
  LLM_CLAUDE
  LLM_OPENAI
  LLM_AZURE
  SALESFORCE
  ORACLE_CX
  HUBSPOT
  GOOGLE_SEARCH
  DOCUMENT_AI
  MEETING_BOT
  EMAIL_SERVICE
  OTHER
}

// Individual API usage log entry
model ApiUsageLog {
  id String @id @default(cuid())

  // User context
  userId    String
  userName  String?
  userEmail String?

  // Service details
  serviceType ApiServiceType
  serviceName String // e.g., "claude-3-opus", "gpt-4", "salesforce-query"
  operation   String // e.g., "chat_completion", "soql_query", "document_analysis"

  // Usage metrics
  inputTokens  Int @default(0)
  outputTokens Int @default(0)
  totalTokens  Int @default(0)

  // Cost tracking (in cents for precision)
  inputCost  Float @default(0) // Cost for input tokens
  outputCost Float @default(0) // Cost for output tokens
  totalCost  Float @default(0) // Total cost in cents

  // API call metrics
  apiCalls  Int  @default(1) // Number of API calls
  latencyMs Int? // Response time in milliseconds

  // Request context
  requestId      String? // Correlation ID
  conversationId String? // Related conversation
  sessionId      String? // User session

  // Status
  success      Boolean @default(true)
  errorMessage String?
  errorCode    String?

  // Additional metadata
  metadata Json? // Flexible storage for additional info

  // Timestamps
  createdAt DateTime @default(now())

  // Indexes for efficient querying
  @@index([userId])
  @@index([serviceType])
  @@index([serviceName])
  @@index([createdAt])
  @@index([userId, serviceType])
  @@index([userId, createdAt])
  @@map("api_usage_logs")
}

// Daily aggregated usage per user (for faster dashboard queries)
model ApiUsageSummary {
  id String @id @default(cuid())

  // Aggregation key
  userId      String
  userName    String?
  userEmail   String?
  serviceType ApiServiceType
  date        DateTime       @db.Date // Date only, no time

  // Aggregated metrics
  totalInputTokens  Int    @default(0)
  totalOutputTokens Int    @default(0)
  totalTokens       Int    @default(0)
  totalCost         Float  @default(0) // In cents
  totalApiCalls     Int    @default(0)
  avgLatencyMs      Float?

  // Success/failure counts
  successCount Int @default(0)
  failureCount Int @default(0)

  // Timestamps
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  // Unique constraint for upsert operations
  @@unique([userId, serviceType, date])
  // Indexes
  @@index([userId])
  @@index([serviceType])
  @@index([date])
  @@index([userId, date])
  @@map("api_usage_summaries")
}

// ==================== AGENT FRAMEWORK ====================

// Agent type enum
enum AgentTypeEnum {
  DEAL_HEALTH
  PIPELINE_ACCELERATION
  ACCOUNT_INTELLIGENCE
  OUTREACH_OPTIMIZATION
  MEETING_PREP
  COACHING
  COMPETITIVE_INTELLIGENCE
  DATA_ENRICHMENT
  WORKFLOW_AUTOMATION
  // Digital Worker Agents
  LISTENING
  REASONING
  LEARN_MORE
  EMAIL_ACTION
  CRM_ACTION
  MEETING_ACTION
}

// Agent execution tracking
model AgentExecution {
  id String @id @default(cuid())

  // Agent info
  agentType   AgentTypeEnum
  triggerType String // SCHEDULED, EVENT, USER_REQUEST, AGENT_CHAIN
  triggerId   String? // What triggered this execution

  // Status
  status String // PENDING, RUNNING, COMPLETED, FAILED, CANCELLED, RATE_LIMITED

  // Timing
  startedAt   DateTime
  completedAt DateTime?

  // Results
  alertsCreated    Int @default(0)
  actionsGenerated Int @default(0)

  // Context
  userId     String?
  entityType String?
  entityId   String?

  // Metadata (llmCalls, tokensUsed, insights, errors)
  metadata Json?

  createdAt DateTime @default(now())

  @@index([agentType])
  @@index([status])
  @@index([userId])
  @@index([createdAt])
  @@index([entityType, entityId])
  @@map("agent_executions")
}

// Agent-generated alerts
model AgentAlert {
  id String @id @default(cuid())

  // Agent info
  agentType AgentTypeEnum
  alertType String // URGENT_ACTION, ATTENTION_NEEDED, FYI, DEAL_AT_RISK, etc.
  priority  String // LOW, MEDIUM, HIGH, URGENT

  // Content
  title          String
  description    String
  recommendation String?

  // Target user
  userId String

  // Related entity
  entityType String
  entityId   String

  // Lifecycle
  status    String    @default("PENDING") // PENDING, ACKNOWLEDGED, ACTIONED, DISMISSED, EXPIRED
  expiresAt DateTime?

  // Suggested actions (JSON array)
  suggestedActions Json?

  // Metadata
  metadata Json?

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  // User acknowledgment
  acknowledgedAt DateTime?
  acknowledgedBy String?
  actionedAt     DateTime?
  actionedBy     String?
  dismissedAt    DateTime?
  dismissedBy    String?

  @@index([userId, status])
  @@index([agentType])
  @@index([entityType, entityId])
  @@index([createdAt])
  @@index([priority])
  @@map("agent_alerts")
}

// Agent actions (queued or executed)
model AgentAction {
  id String @id @default(cuid())

  // Action details
  actionType  String // CREATE_TASK, UPDATE_OPPORTUNITY, SEND_EMAIL, etc.
  priority    String // LOW, MEDIUM, HIGH, URGENT
  description String
  params      Json // Action parameters

  // Target entity
  entityType String?
  entityId   String?

  // Approval workflow
  requiresApproval Boolean   @default(false)
  approvedBy       String?
  approvedAt       DateTime?
  rejectedBy       String?
  rejectedAt       DateTime?
  rejectionReason  String?

  // Execution
  status     String    @default("PENDING") // PENDING_APPROVAL, APPROVED, REJECTED, EXECUTING, COMPLETED, FAILED
  executedAt DateTime?
  result     Json?
  error      String?

  // Context
  executionId String? // Link to AgentExecution
  userId      String?

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@index([status])
  @@index([actionType])
  @@index([executionId])
  @@index([userId])
  @@map("agent_actions")
}

// ==================== DYNAMIC AGENT BUILDER MODELS ====================

// User-defined agent definitions (the "agent builder")
model AgentDefinition {
  id String @id @default(cuid())

  // Identity
  name        String
  slug        String  @unique // URL-friendly identifier
  description String
  category    String  @default("custom") // sales, engagement, analytics, automation, custom
  icon        String? // Lucide icon name
  color       String? // Hex color

  // Version control
  version     String  @default("1.0.0")
  isPublished Boolean @default(false)
  isDraft     Boolean @default(true)

  // AI Configuration
  systemPrompt   String  @db.Text // The main instruction prompt
  analysisPrompt String? @db.Text // Optional analysis-specific prompt
  outputFormat   String? @db.Text // Expected output structure (JSON schema)

  // Model settings
  modelId     String @default("claude-sonnet") // claude-sonnet, claude-haiku, gpt-4o
  temperature Float  @default(0.3)
  maxTokens   Int    @default(4000)

  // Tools configuration (which CRM tools this agent can use)
  enabledTools String[] @default([]) // ["search_opportunities", "get_account_details", etc.]
  customTools  Json? // User-defined tool configurations

  // External CRM Data Source Configuration
  useExternalCrmData  Boolean @default(false) // When true, agent queries external CRM (Salesforce) instead of local DB
  externalCrmProvider String? // SALESFORCE, HUBSPOT, etc. - which external CRM to use

  // Triggers
  triggerConfig Json? // { schedule: { cron, enabled }, events: [...], manual: true }

  // Execution limits
  maxExecutionTimeMs Int @default(60000)
  maxLLMCalls        Int @default(10)
  maxAlertsPerRun    Int @default(20)
  rateLimitPerHour   Int @default(10)
  rateLimitPerDay    Int @default(100)

  // Target scope
  targetEntityTypes String[] @default([]) // ["Opportunity", "Lead", "Account"]
  targetFilters     Json? // Additional filters for target entities

  // Output configuration
  alertTypes       String[] @default(["INFORMATION"]) // Types of alerts this agent can create
  actionTypes      String[] @default([]) // Actions this agent can perform
  requiresApproval Boolean  @default(true)

  // Ownership
  createdById    String
  organizationId String?
  isGlobal       Boolean @default(false) // Available to all users
  isTemplate     Boolean @default(false) // Can be used as template

  // Status
  isEnabled    Boolean   @default(false)
  lastRunAt    DateTime?
  runCount     Int       @default(0)
  successCount Int       @default(0)
  failureCount Int       @default(0)

  // Timestamps
  createdAt   DateTime  @default(now())
  updatedAt   DateTime  @updatedAt
  publishedAt DateTime?

  // Relations
  versions   AgentVersion[]
  executions AgentDefinitionExecution[]
  logs       AgentExecutionLog[]

  @@index([createdById])
  @@index([isPublished, isEnabled])
  @@index([category])
  @@index([isTemplate])
  @@index([slug])
  @@map("agent_definitions")
}

// Version history for agent definitions
model AgentVersion {
  id      String @id @default(cuid())
  agentId String
  version String

  // Snapshot of configuration at this version
  configSnapshot Json // Full agent config at this version

  // Change tracking
  changeNotes String?
  changedBy   String

  createdAt DateTime @default(now())

  agent AgentDefinition @relation(fields: [agentId], references: [id], onDelete: Cascade)

  @@unique([agentId, version])
  @@index([agentId])
  @@map("agent_versions")
}

// Execution records for user-defined agents
model AgentDefinitionExecution {
  id      String @id @default(cuid())
  agentId String

  // Execution context
  triggeredBy String // USER_REQUEST, SCHEDULED, EVENT
  userId      String?

  // Target
  entityType String?
  entityId   String?
  scope      Json? // Execution scope configuration

  // Status
  status String @default("PENDING") // PENDING, RUNNING, COMPLETED, FAILED, CANCELLED

  // Timing
  startedAt       DateTime  @default(now())
  completedAt     DateTime?
  executionTimeMs Int?

  // LLM metrics
  llmCalls      Int   @default(0)
  inputTokens   Int   @default(0)
  outputTokens  Int   @default(0)
  estimatedCost Float @default(0)

  // Results
  alertsCreated  Int @default(0)
  actionsCreated Int @default(0)
  insightsFound  Int @default(0)

  // Output data
  resultSummary String? @db.Text
  resultData    Json? // Full result data

  // Error handling
  errorMessage String?
  errorStack   String? @db.Text

  createdAt DateTime @default(now())

  agent AgentDefinition     @relation(fields: [agentId], references: [id], onDelete: Cascade)
  logs  AgentExecutionLog[]

  @@index([agentId])
  @@index([status])
  @@index([userId])
  @@index([startedAt])
  @@map("agent_definition_executions")
}

// Detailed execution logs for debugging
model AgentExecutionLog {
  id          String  @id @default(cuid())
  executionId String
  agentId     String?

  // Log entry
  level    String // DEBUG, INFO, WARN, ERROR
  category String // INIT, TOOL_CALL, LLM_CALL, RESULT, ERROR
  message  String

  // Details
  data Json? // Additional structured data

  // For LLM calls
  promptTokens     Int?
  completionTokens Int?
  latencyMs        Int?
  modelUsed        String?

  // For tool calls
  toolName    String?
  toolInput   Json?
  toolOutput  Json?
  toolSuccess Boolean?

  // Timing
  timestamp  DateTime @default(now())
  durationMs Int?

  execution AgentDefinitionExecution @relation(fields: [executionId], references: [id], onDelete: Cascade)
  agent     AgentDefinition?         @relation(fields: [agentId], references: [id], onDelete: SetNull)

  @@index([executionId])
  @@index([agentId])
  @@index([level])
  @@index([category])
  @@index([timestamp])
  @@map("agent_execution_logs")
}

// Pre-built agent templates
model AgentTemplate {
  id String @id @default(cuid())

  // Identity
  name            String
  slug            String  @unique
  description     String
  longDescription String? @db.Text
  category        String // sales, engagement, analytics, automation
  icon            String
  color           String

  // Difficulty/complexity
  complexity         String  @default("intermediate") // beginner, intermediate, advanced
  estimatedSetupTime String? // e.g., "5 minutes"

  // Template configuration (same structure as AgentDefinition)
  templateConfig Json // Full agent configuration

  // Use cases and examples
  useCases       String[] @default([])
  exampleOutputs Json? // Sample outputs

  // Popularity
  useCount Int    @default(0)
  rating   Float?

  // Visibility
  isActive   Boolean @default(true)
  isFeatured Boolean @default(false)
  sortOrder  Int     @default(0)

  // Tags for filtering
  tags String[] @default([])

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@index([category])
  @@index([isActive, isFeatured])
  @@index([slug])
  @@map("agent_templates")
}

// ============================================
// SALESFORCE PACKAGE INTEGRATION
// ============================================

/// Salesforce Package Installation tracking
/// Each Salesforce org that installs the IRIS package gets an installation record
model SalesforcePackageInstallation {
  id          String @id @default(cuid())
  orgId       String @unique // Salesforce Organization ID (15 or 18 char)
  orgName     String // Organization name
  instanceUrl String // e.g., https://acme.my.salesforce.com
  adminEmail  String // Installation admin email

  // Authentication
  packageApiKey String @unique // Encrypted API key for package auth
  packageSecret String // Encrypted secret for token signing

  // Status
  isActive       Boolean  @default(true)
  installDate    DateTime @default(now())
  lastActivityAt DateTime @default(now())

  // Features & Limits
  features      Json     @default("[]") // Enabled features array
  apiCallsToday Int      @default(0)
  apiCallLimit  Int      @default(10000) // Daily limit per org
  lastResetDate DateTime @default(now())

  // Metadata
  salesforceVersion String?
  packageVersion    String?
  metadata          Json?

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  // Relations
  users SalesforcePackageUser[]

  @@index([orgId])
  @@index([packageApiKey])
  @@map("salesforce_package_installations")
}

/// Individual Salesforce users using the package
model SalesforcePackageUser {
  id               String @id @default(cuid())
  salesforceUserId String // Salesforce User ID
  email            String
  name             String

  // Link to installation
  installationId String
  installation   SalesforcePackageInstallation @relation(fields: [installationId], references: [id], onDelete: Cascade)

  // Link to IRIS user (if they have full account)
  irisUserId String?
  irisUser   User?   @relation("SalesforcePackageUsers", fields: [irisUserId], references: [id], onDelete: SetNull)

  // Authentication
  accessToken    String // Encrypted JWT token (short-lived)
  refreshToken   String // Encrypted Refresh token (long-lived)
  tokenExpiresAt DateTime

  // Activity tracking
  lastActiveAt      DateTime @default(now())
  conversationCount Int      @default(0)
  messageCount      Int      @default(0)

  // Preferences
  preferences Json @default("{}")

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@unique([installationId, salesforceUserId])
  @@index([salesforceUserId])
  @@index([installationId])
  @@map("salesforce_package_users")
}

// ============================================
// DEVICE TRACKING & OBSERVABILITY
// ============================================

// Device type enum for mobile/tablet/desktop tracking
enum DeviceType {
  MOBILE_IOS
  MOBILE_ANDROID
  TABLET_IPAD
  TABLET_ANDROID
  DESKTOP_WEB
  UNKNOWN
}

// Push token type enum
enum PushTokenType {
  APNS // Apple Push Notification service
  FCM // Firebase Cloud Messaging
}

// Session status enum
enum SessionStatus {
  ACTIVE
  ENDED
  EXPIRED
}

// User device registration
model UserDevice {
  id     String @id @default(cuid())
  userId String

  // Device identification
  deviceType  DeviceType
  deviceId    String // Unique identifier from device (UUID)
  deviceName  String? // e.g., "iPhone 15 Pro", "iPad Pro 12.9"
  deviceModel String? // e.g., "iPhone15,2"
  osVersion   String? // e.g., "iOS 17.2", "Android 14"
  appVersion  String? // IRIS app version

  // Push notification tokens
  pushToken          String? // APNs token (iOS) or FCM token (Android)
  pushTokenType      PushTokenType? // APNS or FCM
  pushTokenUpdatedAt DateTime? // When the token was last updated
  pushEnabled        Boolean        @default(true) // User preference for push notifications

  // Status
  isActive   Boolean  @default(true)
  lastSeenAt DateTime @default(now())

  // Metadata
  metadata Json? // Additional device-specific data

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  // Relations
  user         User                 @relation(fields: [userId], references: [id], onDelete: Cascade)
  sessions     UserSession[]
  featureUsage DeviceFeatureUsage[]

  @@unique([userId, deviceId])
  @@index([userId])
  @@index([deviceType])
  @@index([lastSeenAt])
  @@index([pushToken])
  @@map("user_devices")
}

// User session tracking
model UserSession {
  id       String  @id @default(cuid())
  userId   String
  deviceId String?

  // Session details
  sessionToken String        @unique @default(cuid())
  status       SessionStatus @default(ACTIVE)

  // Timing
  startedAt       DateTime  @default(now())
  endedAt         DateTime?
  lastActivityAt  DateTime  @default(now())
  durationSeconds Int? // Calculated on session end

  // Context
  ipAddress String?
  userAgent String?

  // Stats during session
  apiCallCount Int @default(0)

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  // Relations
  user   User        @relation(fields: [userId], references: [id], onDelete: Cascade)
  device UserDevice? @relation(fields: [deviceId], references: [id], onDelete: SetNull)

  @@index([userId])
  @@index([deviceId])
  @@index([status])
  @@index([startedAt])
  @@map("user_sessions")
}

// Feature usage per device per day
model DeviceFeatureUsage {
  id       String @id @default(cuid())
  deviceId String
  userId   String

  // Feature tracking
  featureKey String // e.g., "ai_chat", "crm_salesforce"
  usageCount Int      @default(1)
  lastUsedAt DateTime @default(now())

  // Period tracking
  date DateTime @db.Date // Date-only for aggregation

  createdAt DateTime @default(now())

  device UserDevice @relation(fields: [deviceId], references: [id], onDelete: Cascade)

  @@unique([deviceId, featureKey, date])
  @@index([deviceId])
  @@index([userId])
  @@index([featureKey])
  @@index([date])
  @@map("device_feature_usage")
}

// ============================================
// PUSH NOTIFICATIONS
// ============================================

// Notification priority enum
enum NotificationPriority {
  LOW
  NORMAL
  HIGH
  URGENT
}

// Notification status enum
enum NotificationStatus {
  PENDING
  SENT
  DELIVERED
  READ
  FAILED
}

// Notification type enum
enum NotificationType {
  DEAL_UPDATE
  TASK_REMINDER
  AI_INSIGHT
  SYSTEM_ALERT
  ADMIN_BROADCAST
  CUSTOM
}

// Notification templates (admin-managed)
model NotificationTemplate {
  id String @id @default(cuid())

  // Template identity
  name        String  @unique
  slug        String  @unique
  description String?

  // Content
  titleTemplate String // Supports {{variable}} placeholders
  bodyTemplate  String

  // Configuration
  type     NotificationType     @default(CUSTOM)
  priority NotificationPriority @default(NORMAL)
  channel  String // deals, tasks, ai_insights, general

  // Targeting
  targetRoles        String[] @default([]) // Empty = all roles
  targetLicenseTiers String[] @default([]) // Empty = all tiers

  // Settings
  isActive Boolean @default(true)

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  notifications PushNotification[]

  @@index([type])
  @@index([isActive])
  @@map("notification_templates")
}

// Push notifications
model PushNotification {
  id String @id @default(cuid())

  // Targeting
  userId String? // null = broadcast

  // Content
  title    String
  body     String
  type     NotificationType
  priority NotificationPriority @default(NORMAL)

  // Template reference
  templateId String?

  // Deep link / action
  action     String? // Route to navigate on tap
  actionData Json? // Additional action parameters

  // Status
  status NotificationStatus @default(PENDING)

  // Timestamps
  scheduledFor DateTime? // Scheduled delivery time
  sentAt       DateTime?
  deliveredAt  DateTime?
  readAt       DateTime?

  // Error tracking
  errorMessage String?

  // Source tracking
  createdBy String? // Admin user or system
  source    String  @default("system") // system, admin, agent, trigger

  metadata Json?

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  user     User?                 @relation(fields: [userId], references: [id], onDelete: Cascade)
  template NotificationTemplate? @relation(fields: [templateId], references: [id], onDelete: SetNull)

  @@index([userId])
  @@index([status])
  @@index([type])
  @@index([scheduledFor])
  @@index([createdAt])
  @@map("push_notifications")
}

// ============================================
// APP CONTENT MANAGEMENT
// ============================================

// Content type for app-managed content pages
enum AppContentType {
  // Legal
  TERMS_OF_SERVICE
  PRIVACY_SECURITY
  SECURITY
  DATA_PROCESSING_AGREEMENT
  OSS_LICENSES

  // Product
  FEATURES
  INTEGRATIONS
  PRICING
  API_DOCS

  // Company
  ABOUT_IRIS
  BLOG
  CAREERS
  CONTACT

  // Help
  HELP_SUPPORT
}

// App content management for legal, help, and informational pages
model AppContent {
  id String @id @default(cuid())

  // Content identification
  type    AppContentType
  title   String
  content String         @db.Text // Large text for markdown/HTML
  version String // Versioning for tracking changes

  // Status
  isActive Boolean @default(true)

  // Audit
  lastUpdatedBy String? // User ID or identifier of who last updated

  // Flexible additional data
  metadata Json?

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@unique([type, version]) // Each content type can have multiple versions
  @@index([type])
  @@index([isActive])
  @@index([type, isActive]) // Composite for quick active content lookup
  @@map("app_content")
}

// ============================================
// FEATURE VISIBILITY RULES
// ============================================

// Feature visibility rules (admin-configurable per device/license)
model FeatureVisibilityRule {
  id String @id @default(cuid())

  // Feature reference
  featureKey String @unique // References LicenseFeature.featureKey

  // Platform-specific visibility
  showOnMobile  Boolean @default(true)
  showOnTablet  Boolean @default(true)
  showOnDesktop Boolean @default(true)

  // License tier requirements (null = available to all)
  minLicenseTier String? // FREE, STARTER, PROFESSIONAL, ENTERPRISE

  // UI configuration
  uiPosition Int? // Sort order in menus

  // Behavior when not available
  showWhenDisabled Boolean @default(false) // Show grayed out?
  upgradeMessage   String? // Message to show for upgrade

  isActive Boolean @default(true)

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@index([featureKey])
  @@index([minLicenseTier])
  @@map("feature_visibility_rules")
}

// ============================================
// DATA PRIVACY & GDPR REQUESTS
// ============================================

// Data request type enum
enum DataRequestType {
  EXPORT // GDPR data export request
  DELETION // Account/data deletion request
  RECTIFICATION // Data correction request
}

// Data request status enum
enum DataRequestStatus {
  PENDING // Request submitted
  PROCESSING // Request being processed
  COMPLETED // Request fulfilled
  FAILED // Request failed
  CANCELLED // Request cancelled by user
}

// User data privacy requests (GDPR compliance)
model DataRequest {
  id     String @id @default(cuid())
  userId String

  // Request details
  type   DataRequestType
  status DataRequestStatus @default(PENDING)

  // Request metadata
  reason String? // User-provided reason
  notes  String? // Admin notes

  // For export requests
  downloadUrl       String? // Secure download URL
  downloadExpiresAt DateTime? // URL expiry time

  // Processing details
  processedAt  DateTime?
  processedBy  String? // Admin who processed
  errorMessage String?

  // Metadata
  ipAddress String?
  userAgent String?
  metadata  Json?

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@index([userId])
  @@index([type])
  @@index([status])
  @@index([createdAt])
  @@map("data_requests")
}

// User privacy preferences (separate from general settings)
model PrivacyPreferences {
  id     String @id @default(cuid())
  userId String @unique

  // Analytics & tracking
  analyticsEnabled       Boolean @default(false)
  personalizationEnabled Boolean @default(true)
  crashReportingEnabled  Boolean @default(true)

  // AI training consent
  aiTrainingConsent       Boolean @default(false)
  contextRetentionEnabled Boolean @default(true)

  // Marketing preferences
  marketingEmailsEnabled Boolean @default(false)
  productUpdatesEnabled  Boolean @default(true)

  // Data retention preference
  retentionPeriodDays Int? // null = use default

  // Consent tracking
  lastConsentUpdate DateTime @default(now())
  consentVersion    String   @default("1.0")

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@index([userId])
  @@map("privacy_preferences")
}

// System-wide settings (admin configurable)
model SystemSettings {
  id          String   @id @default(cuid())
  key         String   @unique
  value       String // JSON-encoded value
  description String? // Human-readable description
  category    String   @default("general") // For grouping settings
  updatedBy   String? // Admin who last updated
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt

  @@index([category])
  @@map("system_settings")
}

// ============================================
// DATABASE BACKUP MANAGEMENT
// ============================================

enum BackupStatus {
  PENDING
  IN_PROGRESS
  COMPLETED
  FAILED
  DELETED
}

enum BackupType {
  FULL           // Full database backup
  INCREMENTAL    // Incremental since last full
  SCHEMA_ONLY    // Schema without data
  DATA_ONLY      // Data without schema
}

// Database backup records
model DatabaseBackup {
  id           String       @id @default(cuid())
  type         BackupType   @default(FULL)
  status       BackupStatus @default(PENDING)

  // File information
  filename     String       // Backup file name
  filePath     String?      // Full path to backup file
  size         BigInt       @default(0) // Size in bytes
  checksum     String?      // MD5/SHA256 for integrity verification

  // Metadata
  description  String?      // User-provided description
  compressed   Boolean      @default(true)
  encrypted    Boolean      @default(false)

  // Timing
  startedAt    DateTime?    // When backup started
  completedAt  DateTime?    // When backup completed
  duration     Int?         // Duration in milliseconds

  // Retention
  expiresAt    DateTime?    // Auto-delete date (retention policy)
  retentionDays Int         @default(30)

  // Error handling
  errorMessage String?      // Error message if failed

  // Audit
  createdBy    String       // User ID who initiated
  createdAt    DateTime     @default(now())
  updatedAt    DateTime     @updatedAt

  // Database info at time of backup
  databaseName String?
  tableCount   Int?
  rowCount     BigInt?

  @@index([status])
  @@index([type])
  @@index([createdAt])
  @@index([createdBy])
  @@index([expiresAt])
  @@map("database_backups")
}

// Backup schedule configuration
model BackupSchedule {
  id           String   @id @default(cuid())
  name         String
  enabled      Boolean  @default(true)

  // Schedule (cron format)
  cronExpression String  @default("0 2 * * *") // Default: 2 AM daily
  timezone     String   @default("UTC")

  // Backup settings
  backupType   BackupType @default(FULL)
  compressed   Boolean  @default(true)
  retentionDays Int     @default(30)

  // Status
  lastRunAt    DateTime?
  lastRunStatus BackupStatus?
  nextRunAt    DateTime?

  createdBy    String
  createdAt    DateTime @default(now())
  updatedAt    DateTime @updatedAt

  @@map("backup_schedules")
}

// ============================================
// SUPPORT TICKET SYSTEM
// ============================================

// Support ticket category
enum TicketCategory {
  BUG_REPORT
  FEATURE_REQUEST
  ACCOUNT_ISSUE
  BILLING
  INTEGRATION
  PERFORMANCE
  SECURITY
  OTHER
}

// Support ticket priority
enum TicketPriority {
  LOW
  MEDIUM
  HIGH
  CRITICAL
}

// Support ticket status
enum TicketStatus {
  OPEN
  IN_PROGRESS
  WAITING_ON_CUSTOMER
  RESOLVED
  CLOSED
}

// Support ticket submitted by users
model SupportTicket {
  id     String @id @default(cuid())
  caseId String @unique // IR-YYYY-XX format

  // Submitter Info
  email  String
  name   String?
  userId String? // If logged in user

  // Ticket Details
  subject     String
  description String         @db.Text
  category    TicketCategory
  priority    TicketPriority @default(MEDIUM)
  status      TicketStatus   @default(OPEN)

  // AI Draft
  aiDraftResponse String? @db.Text

  // Resolution
  assignedToId String?
  resolvedAt   DateTime?
  resolution   String?   @db.Text

  // AI Agent & Queue Assignment
  aiAgentId String? // Assigned AI agent
  queueId   String? // Queue this ticket is in

  // CSAT (Customer Satisfaction)
  csatRating      Int? // 1-5 star rating
  csatFeedback    String?   @db.Text // Optional feedback text
  csatSubmittedAt DateTime?
  feedbackToken   String?   @unique // Token for secure feedback submission
  feedbackSentAt  DateTime? // When feedback request was sent

  // SLA (Service Level Agreement) Tracking
  firstResponseDue DateTime? // When first response is due (based on priority)
  firstRespondedAt DateTime? // When first response was actually sent
  resolutionDue    DateTime? // When resolution is due (based on priority)
  slaBreached      Boolean   @default(false) // Whether any SLA has been breached
  slaBreachType    String? // FIRST_RESPONSE, RESOLUTION, or BOTH
  escalationLevel  Int       @default(0) // 0=normal, 1=warning(50%), 2=critical(75%), 3=breached

  // Customer Progress Updates
  lastCustomerUpdateAt DateTime? // Last time customer was proactively updated
  customerUpdateCount  Int       @default(0) // Number of progress updates sent

  // Internal Alerts
  lastInternalAlertAt DateTime? // Last time internal alert was sent
  internalAlertCount  Int       @default(0) // Number of internal alerts sent

  // Metadata
  deviceInfo  String? // Browser, OS, app version
  attachments Json? // URLs to uploaded files
  metadata    Json?

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  // Relations
  user           User?                       @relation("SubmittedTickets", fields: [userId], references: [id], onDelete: SetNull)
  assignedTo     User?                       @relation("AssignedTickets", fields: [assignedToId], references: [id], onDelete: SetNull)
  aiAgent        SupportAIAgent?             @relation("AIAgentTickets", fields: [aiAgentId], references: [id], onDelete: SetNull)
  queue          SupportQueue?               @relation("QueueTickets", fields: [queueId], references: [id], onDelete: SetNull)
  responses      TicketResponse[]
  agentActions   SupportAgentAction[]
  pendingActions SupportAgentPendingAction[]

  @@index([email])
  @@index([status])
  @@index([category])
  @@index([priority])
  @@index([caseId])
  @@index([userId])
  @@index([assignedToId])
  @@index([aiAgentId])
  @@index([queueId])
  @@index([createdAt])
  @@index([feedbackToken])
  @@index([firstResponseDue])
  @@index([resolutionDue])
  @@index([slaBreached])
  @@index([escalationLevel])
  @@map("support_tickets")
}

// Response/comment on a support ticket
model TicketResponse {
  id       String @id @default(cuid())
  ticketId String

  content       String  @db.Text
  isAiGenerated Boolean @default(false)
  isInternal    Boolean @default(false) // Internal notes vs customer-visible

  responderId    String? // Admin who responded
  aiAgentId      String? // AI agent who responded (if AI-generated)
  emailMessageId String? // Email Message-ID for deduplication

  createdAt DateTime @default(now())

  // Relations
  ticket    SupportTicket   @relation(fields: [ticketId], references: [id], onDelete: Cascade)
  responder User?           @relation("TicketResponses", fields: [responderId], references: [id], onDelete: SetNull)
  aiAgent   SupportAIAgent? @relation("AIAgentResponses", fields: [aiAgentId], references: [id], onDelete: SetNull)

  @@index([ticketId])
  @@index([responderId])
  @@index([aiAgentId])
  @@index([createdAt])
  @@index([emailMessageId])
  @@map("ticket_responses")
}

// Email verification for support ticket submission
model TicketVerification {
  id        String   @id @default(cuid())
  email     String
  token     String   @unique
  formData  Json // Stores submitted form data
  expiresAt DateTime // 24 hours
  verified  Boolean  @default(false)
  createdAt DateTime @default(now())

  @@index([token])
  @@index([email])
  @@index([expiresAt])
  @@map("ticket_verifications")
}

// Support Agent executed actions log
model SupportAgentAction {
  id        String                   @id @default(cuid())
  ticketId  String
  toolName  String // Name of the tool executed
  input     Json // Tool input parameters
  result    Json? // Tool execution result
  status    SupportAgentActionStatus @default(EXECUTED)
  duration  Int? // Execution time in milliseconds
  createdAt DateTime                 @default(now())

  ticket SupportTicket @relation(fields: [ticketId], references: [id], onDelete: Cascade)

  @@index([ticketId])
  @@index([toolName])
  @@index([createdAt])
  @@map("support_agent_actions")
}

// Support Agent actions blocked by safety rules pending human review
model SupportAgentPendingAction {
  id          String                    @id @default(cuid())
  ticketId    String
  toolName    String // Name of the tool that was blocked
  input       Json // Tool input parameters
  reason      String // Why the action was blocked
  status      SupportAgentPendingStatus @default(PENDING)
  reviewedBy  String? // Admin who reviewed
  reviewedAt  DateTime?
  reviewNotes String? // Notes from reviewer
  createdAt   DateTime                  @default(now())

  ticket   SupportTicket @relation(fields: [ticketId], references: [id], onDelete: Cascade)
  reviewer User?         @relation("SupportAgentActionReviewer", fields: [reviewedBy], references: [id], onDelete: SetNull)

  @@index([ticketId])
  @@index([status])
  @@index([createdAt])
  @@map("support_agent_pending_actions")
}

enum SupportAgentActionStatus {
  EXECUTED
  FAILED
  BLOCKED
}

enum SupportAgentPendingStatus {
  PENDING
  APPROVED
  REJECTED
}

// ============================================================================
// Waitlist Subscribers - Pre-launch lead collection
// ============================================================================
model WaitlistSubscriber {
  id          String         @id @default(cuid())
  email       String         @unique
  company     String?
  name        String?
  source      String?        @default("landing") // landing, referral, social, etc.
  status      WaitlistStatus @default(PENDING)
  notes       String?        @db.Text
  metadata    Json? // UTM params, referrer, etc.
  invitedAt   DateTime? // When they were invited to join
  convertedAt DateTime? // When they became a user
  createdAt   DateTime       @default(now())
  updatedAt   DateTime       @updatedAt

  @@index([email])
  @@index([status])
  @@index([createdAt])
  @@map("waitlist_subscribers")
}

enum WaitlistStatus {
  PENDING // Just signed up
  CONTACTED // We've reached out
  INVITED // Sent invite to create account
  CONVERTED // Became a paying user
  DECLINED // Not interested
}

// ============================================================================
// AI Support Agents - Autonomous AI workers for handling support tickets
// ============================================================================
model SupportAIAgent {
  id     String  @id @default(cuid())
  name   String // Display name (e.g., "Technical Support Bot")
  slug   String  @unique // URL-friendly identifier
  avatar String? // Avatar initials or URL

  // AI Configuration
  specialization AIAgentSpecialization
  systemPrompt   String?               @db.Text // Custom system prompt additions
  capabilities   Json? // Tool capabilities this agent has
  model          String                @default("claude-sonnet-4-20250514") // AI model to use
  temperature    Float                 @default(0.3)

  // Behavior Settings
  autoReply     Boolean @default(true) // Automatically reply to tickets
  escalateAfter Int? // Escalate to human after N failed attempts
  maxRetries    Int     @default(3) // Max retry attempts
  responseDelay Int     @default(0) // Delay in seconds before responding (more human-like)

  // Working Hours (null = 24/7)
  workingHoursStart String? // e.g., "09:00"
  workingHoursEnd   String? // e.g., "17:00"
  workingDays       Json? // e.g., [1,2,3,4,5] for Mon-Fri
  timezone          String? // e.g., "America/New_York"

  // Status
  status       AIAgentStatus @default(ACTIVE)
  isOnline     Boolean       @default(true)
  lastActiveAt DateTime?

  // Performance Metrics (cached, updated periodically)
  totalTicketsHandled Int    @default(0)
  avgResolutionTime   Int? // in minutes
  csatAverage         Float? // Average CSAT rating
  escalationRate      Float? // % of tickets escalated to human

  // Metadata
  metadata  Json?
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  // Relations
  queues          SupportQueueAgent[]
  ticketsAssigned SupportTicket[]     @relation("AIAgentTickets")
  responses       TicketResponse[]    @relation("AIAgentResponses")

  @@index([status])
  @@index([specialization])
  @@index([isOnline])
  @@map("support_ai_agents")
}

enum AIAgentSpecialization {
  GENERAL // General support queries
  TECHNICAL // Technical/product issues
  BILLING // Billing and subscription
  ONBOARDING // New user onboarding
  ESCALATION // Handles escalated tickets
  SALES // Sales inquiries
  ENTERPRISE // Enterprise/VIP support
}

enum AIAgentStatus {
  ACTIVE // Agent is active and can receive tickets
  PAUSED // Temporarily paused
  TRAINING // Being fine-tuned/configured
  DISABLED // Permanently disabled
}

// ============================================================================
// Support Queues - Route tickets to appropriate AI agents
// ============================================================================
model SupportQueue {
  id          String  @id @default(cuid())
  name        String // Display name (e.g., "Technical Support")
  slug        String  @unique // URL-friendly identifier
  description String?

  // Routing Rules
  categories Json? // TicketCategory[] that route to this queue
  priorities Json? // TicketPriority[] this queue handles
  keywords   Json? // Keywords that trigger routing to this queue

  // Queue Settings
  isDefault     Boolean @default(false) // Default queue for unmatched tickets
  maxCapacity   Int? // Max concurrent tickets (null = unlimited)
  slaMultiplier Float   @default(1.0) // SLA time multiplier (0.5 = faster, 2.0 = slower)

  // Status
  isActive Boolean @default(true)

  // Metrics (cached)
  currentTickets Int  @default(0)
  avgWaitTime    Int? // Average wait time in minutes

  // Metadata
  metadata  Json?
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  // Relations
  agents  SupportQueueAgent[]
  tickets SupportTicket[]     @relation("QueueTickets")

  @@index([isActive])
  @@index([isDefault])
  @@map("support_queues")
}

// Junction table for Queue <-> Agent many-to-many with priority
model SupportQueueAgent {
  id       String  @id @default(cuid())
  queueId  String
  agentId  String
  priority Int     @default(0) // Higher = preferred agent for this queue
  isActive Boolean @default(true)

  queue SupportQueue   @relation(fields: [queueId], references: [id], onDelete: Cascade)
  agent SupportAIAgent @relation(fields: [agentId], references: [id], onDelete: Cascade)

  @@unique([queueId, agentId])
  @@index([queueId])
  @@index([agentId])
  @@map("support_queue_agents")
}

// ============================================================================
// Voice Call History - Stores realtime voice conversation transcripts
// ============================================================================
model CallHistory {
  id        String @id @default(cuid())
  sessionId String @unique // Client-generated session ID

  // Owner relationship
  ownerId String
  owner   User   @relation("UserCallHistory", fields: [ownerId], references: [id], onDelete: Cascade)

  // Timing
  startedAt  DateTime
  endedAt    DateTime?
  durationMs Int // Duration in milliseconds

  // Conversation metrics
  userTurnCount      Int     @default(0)
  assistantTurnCount Int     @default(0)
  userSpoke          Boolean @default(false) // Whether user actually spoke

  // Transcript and summary
  transcript     Json? // Array of {role, content, timestamp} objects
  transcriptText String? // Full transcript as text (searchable)
  summary        String? // AI-generated summary of the call

  // Tools used during the call
  toolsUsed String[] @default([])

  // Optional CRM linkages
  leadId String?
  lead   Lead?   @relation("LeadCallHistory", fields: [leadId], references: [id])

  contactId String?
  contact   Contact? @relation("ContactCallHistory", fields: [contactId], references: [id])

  accountId String?
  account   Account? @relation("AccountCallHistory", fields: [accountId], references: [id])

  opportunityId String?
  opportunity   Opportunity? @relation("OpportunityCallHistory", fields: [opportunityId], references: [id])

  // Metadata
  metadata  Json? // Additional data like voice settings, platform info
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@index([ownerId])
  @@index([startedAt])
  @@index([leadId])
  @@index([contactId])
  @@index([accountId])
  @@index([opportunityId])
  @@map("call_history")
}

// ====================================================================
// WORKFLOW AUTOMATION
// ====================================================================

enum WorkflowTriggerType {
  RECORD_CREATED
  RECORD_UPDATED
  RECORD_DELETED
  FIELD_CHANGED
  STAGE_CHANGED
  TIME_BASED
  WEBHOOK
  MANUAL
}

enum WorkflowActionType {
  SEND_EMAIL
  CREATE_TASK
  UPDATE_FIELD
  SEND_NOTIFICATION
  WEBHOOK_CALL
  ASSIGN_OWNER
  ADD_TAG
  REMOVE_TAG
  CREATE_ACTIVITY
}

enum WorkflowStatus {
  ACTIVE
  INACTIVE
  DRAFT
}

enum WorkflowExecutionStatus {
  PENDING
  RUNNING
  COMPLETED
  FAILED
  CANCELLED
}

// Workflow definition
model Workflow {
  id          String         @id @default(cuid())
  name        String
  description String?
  status      WorkflowStatus @default(DRAFT)

  // Trigger configuration
  triggerType   WorkflowTriggerType
  triggerEntity String // LEAD, CONTACT, ACCOUNT, OPPORTUNITY, TASK
  triggerConfig Json // Additional trigger configuration (field names, time schedules, etc.)

  // Conditions - when to run the workflow
  conditions Json? // Array of conditions: [{field, operator, value}]

  // Actions - what to do when triggered
  actions Json // Array of actions: [{type, config}]

  // Execution settings
  runOnce      Boolean @default(false) // Only run once per record
  delayMinutes Int     @default(0) // Delay before execution

  // Organization scope
  organizationId String?

  // Ownership and audit
  createdById      String
  lastModifiedById String?

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  // Relations
  executions WorkflowExecution[]

  @@index([status])
  @@index([triggerType])
  @@index([triggerEntity])
  @@index([organizationId])
  @@map("workflows")
}

// Workflow execution history
model WorkflowExecution {
  id         String   @id @default(cuid())
  workflowId String
  workflow   Workflow @relation(fields: [workflowId], references: [id], onDelete: Cascade)

  // Execution status
  status WorkflowExecutionStatus @default(PENDING)

  // Context
  triggeredBy String? // User ID or "SYSTEM"
  entityType  String // LEAD, CONTACT, ACCOUNT, OPPORTUNITY
  entityId    String // ID of the record that triggered the workflow

  // Execution details
  startedAt   DateTime?
  completedAt DateTime?

  // Results
  actionResults Json? // Array of action results
  errorMessage  String?

  createdAt DateTime @default(now())

  @@index([workflowId])
  @@index([status])
  @@index([entityType, entityId])
  @@index([createdAt])
  @@map("workflow_executions")
}

// ==================== EMAIL & CALENDAR INTEGRATIONS ====================

enum EmailProvider {
  GMAIL
  OUTLOOK
  IMAP
}

enum CalendarProvider {
  GOOGLE
  OUTLOOK
  APPLE
}

enum ConnectionStatus {
  ACTIVE
  INACTIVE
  EXPIRED
  ERROR
}

// User email account connection for Gmail/Outlook OAuth
model EmailConnection {
  id       String        @id @default(cuid())
  userId   String
  provider EmailProvider
  email    String // Connected email address

  // OAuth tokens (encrypted)
  accessToken    String
  refreshToken   String?
  tokenExpiresAt DateTime?

  // Connection status
  status    ConnectionStatus @default(ACTIVE)
  lastError String?

  // Sync settings
  syncEnabled  Boolean   @default(true)
  syncIncoming Boolean   @default(true)
  syncOutgoing Boolean   @default(true)
  lastSyncAt   DateTime?
  syncCursor   String? // Provider-specific sync cursor

  // Provider-specific data
  providerUserId String? // User ID from provider
  providerData   Json? // Additional provider-specific data

  // Stats
  emailsSynced Int       @default(0)
  lastEmailAt  DateTime?

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@unique([userId, provider, email])
  @@index([userId])
  @@index([provider])
  @@index([status])
  @@map("email_connections")
}

// User calendar connection for Google Calendar/Outlook
model CalendarConnection {
  id       String           @id @default(cuid())
  userId   String
  provider CalendarProvider
  email    String // Connected account email

  // OAuth tokens (encrypted)
  accessToken    String
  refreshToken   String?
  tokenExpiresAt DateTime?

  // Connection status
  status    ConnectionStatus @default(ACTIVE)
  lastError String?

  // Primary calendar info
  calendarId   String? // Default calendar ID to sync
  calendarName String? // Display name of calendar

  // Sync settings
  syncEnabled    Boolean   @default(true)
  syncPastDays   Int       @default(30) // How many days back to sync
  syncFutureDays Int       @default(90) // How many days forward to sync
  lastSyncAt     DateTime?
  syncCursor     String? // Provider-specific sync cursor

  // Provider-specific data
  providerUserId String?
  providerData   Json?

  // Stats
  eventsSynced Int       @default(0)
  lastEventAt  DateTime?

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@unique([userId, provider, email])
  @@index([userId])
  @@index([provider])
  @@index([status])
  @@map("calendar_connections")
}

// Synced calendar events from external providers
model SyncedCalendarEvent {
  id                   String           @id @default(cuid())
  calendarConnectionId String
  provider             CalendarProvider
  externalId           String // Provider's event ID

  // Event details
  title       String
  description String?
  location    String?
  startTime   DateTime
  endTime     DateTime
  allDay      Boolean  @default(false)
  timezone    String   @default("UTC")

  // Status
  status String @default("confirmed") // confirmed, tentative, cancelled

  // Organizer & attendees
  organizerEmail String?
  organizerName  String?
  attendees      Json? // Array of {email, name, status}

  // Video meeting info
  meetingUrl      String?
  meetingProvider String? // zoom, teams, meet, etc.

  // CRM linking
  leadId           String?
  contactId        String?
  accountId        String?
  opportunityId    String?
  meetingSessionId String? // Link to internal meeting session

  // Recurrence
  isRecurring      Boolean @default(false)
  recurrenceRule   String? // iCal RRULE
  recurringEventId String? // Parent event ID for instances

  // Sync metadata
  rawData      Json? // Original event data from provider
  lastSyncedAt DateTime @default(now())

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@unique([calendarConnectionId, externalId])
  @@index([calendarConnectionId])
  @@index([startTime])
  @@index([leadId])
  @@index([contactId])
  @@index([accountId])
  @@index([opportunityId])
  @@map("synced_calendar_events")
}

// ==================== TEAM MESSAGING ====================

enum TeamChannelType {
  PUBLIC
  PRIVATE
  ANNOUNCEMENT
}

model TeamChannel {
  id          String          @id @default(cuid())
  name        String
  description String?
  type        TeamChannelType @default(PUBLIC)
  avatar      String?
  isArchived  Boolean         @default(false)
  createdById String
  createdAt   DateTime        @default(now())
  updatedAt   DateTime        @updatedAt

  members  TeamChannelMember[]
  messages TeamMessage[]

  @@index([name])
  @@index([type])
  @@map("team_channels")
}

model TeamChannelMember {
  id         String    @id @default(cuid())
  channelId  String
  userId     String
  role       String    @default("member") // owner, admin, member
  joinedAt   DateTime  @default(now())
  mutedUntil DateTime?

  channel TeamChannel @relation(fields: [channelId], references: [id], onDelete: Cascade)
  user    User        @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@unique([channelId, userId])
  @@index([userId])
  @@map("team_channel_members")
}

model DirectConversation {
  id        String   @id @default(cuid())
  user1Id   String
  user2Id   String
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  user1    User          @relation("DirectConversationUser1", fields: [user1Id], references: [id], onDelete: Cascade)
  user2    User          @relation("DirectConversationUser2", fields: [user2Id], references: [id], onDelete: Cascade)
  messages TeamMessage[]

  @@unique([user1Id, user2Id])
  @@index([user1Id])
  @@index([user2Id])
  @@map("direct_conversations")
}

model TeamMessage {
  id                   String   @id @default(cuid())
  content              String
  senderId             String
  channelId            String?
  directConversationId String?
  parentId             String? // For threaded replies
  isEdited             Boolean  @default(false)
  isPinned             Boolean  @default(false)
  attachments          Json? // Array of attachment URLs/metadata
  reactions            Json? // { emoji: [userId, ...] }
  createdAt            DateTime @default(now())
  updatedAt            DateTime @updatedAt

  sender             User                @relation(fields: [senderId], references: [id], onDelete: Cascade)
  channel            TeamChannel?        @relation(fields: [channelId], references: [id], onDelete: Cascade)
  directConversation DirectConversation? @relation(fields: [directConversationId], references: [id], onDelete: Cascade)
  parent             TeamMessage?        @relation("MessageThread", fields: [parentId], references: [id], onDelete: SetNull)
  replies            TeamMessage[]       @relation("MessageThread")
  readReceipts       TeamMessageRead[]

  @@index([channelId])
  @@index([directConversationId])
  @@index([senderId])
  @@index([parentId])
  @@index([createdAt])
  @@map("team_messages")
}

model TeamMessageRead {
  id        String   @id @default(cuid())
  messageId String
  userId    String
  readAt    DateTime @default(now())

  message TeamMessage @relation(fields: [messageId], references: [id], onDelete: Cascade)

  @@unique([messageId, userId])
  @@index([userId])
  @@map("team_message_reads")
}

// ============================================
// PAYMENT & BILLING SYSTEM
// ============================================

// Payment gateway provider enum
enum PaymentGateway {
  STRIPE // US/Global payments
  RAZORPAY // India payments
}

// Subscription status enum
enum SubscriptionStatus {
  ACTIVE // Currently active subscription
  PAST_DUE // Payment failed, grace period
  CANCELED // User canceled, will end at period end
  TRIALING // In trial period
  PAUSED // Temporarily paused
  EXPIRED // Subscription ended
}

// Invoice status enum
enum InvoiceStatus {
  DRAFT // Not yet finalized
  OPEN // Sent to customer, awaiting payment
  PAID // Payment received
  VOID // Canceled/voided
  UNCOLLECTIBLE // Unable to collect
}

// Payment status enum
enum PaymentStatus {
  PENDING // Payment initiated
  PROCESSING // Being processed by gateway
  SUCCEEDED // Payment completed
  FAILED // Payment failed
  REFUNDED // Fully refunded
  PARTIALLY_REFUNDED // Partially refunded
}

// Coupon discount type enum
enum DiscountType {
  PERCENTAGE // Percentage off (0-100)
  FIXED_AMOUNT // Fixed amount in cents
}

// Coupon duration enum
enum CouponDuration {
  ONCE // Apply once
  REPEATING // Apply for N months
  FOREVER // Apply forever
}

// Payment gateway configuration - stores gateway settings
model PaymentGatewayConfig {
  id                  String         @id @default(cuid())
  provider            PaymentGateway @unique
  name                String // Display name
  isActive            Boolean        @default(true)
  isDefault           Boolean        @default(false)
  publicKey           String? // Publishable key (safe to expose)
  secretKey           String? // Encrypted secret key
  webhookSecret       String? // For verifying webhooks (encrypted)
  supportedCurrencies String[]       @default(["USD"])
  supportedCountries  String[]       @default(["US"])
  testMode            Boolean        @default(true)
  config              Json? // Provider-specific settings
  lastTestedAt        DateTime? // Last successful connection test
  connectionStatus    String? // connected, error, untested
  createdAt           DateTime       @default(now())
  updatedAt           DateTime       @updatedAt

  @@map("payment_gateway_configs")
}

// Billing customer profile - links user to payment gateways
model BillingCustomer {
  id     String @id @default(cuid())
  userId String @unique

  // Gateway customer IDs
  stripeCustomerId   String? @unique
  razorpayCustomerId String? @unique

  // Billing details
  billingEmail   String?
  billingName    String?
  billingPhone   String?
  billingAddress Json? // { line1, line2, city, state, postal_code, country }
  taxId          String? // VAT/GST number

  // Preferences
  defaultPaymentMethodId String?
  preferredGateway       PaymentGateway?
  country                String?
  currency               String          @default("USD")

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  // Relations
  user           User            @relation(fields: [userId], references: [id], onDelete: Cascade)
  subscriptions  Subscription[]
  invoices       Invoice[]
  paymentMethods PaymentMethod[]
  payments       Payment[]

  @@index([stripeCustomerId])
  @@index([razorpayCustomerId])
  @@map("billing_customers")
}

// Subscription - recurring billing for license types
model Subscription {
  id            String @id @default(cuid())
  customerId    String
  licenseTypeId String

  // Gateway subscription IDs
  stripeSubscriptionId   String? @unique
  razorpaySubscriptionId String? @unique

  // Subscription details
  status       SubscriptionStatus @default(ACTIVE)
  billingCycle String             @default("monthly") // monthly, yearly
  gateway      PaymentGateway

  // Billing period
  currentPeriodStart DateTime
  currentPeriodEnd   DateTime

  // Cancellation
  cancelAtPeriodEnd Boolean   @default(false)
  canceledAt        DateTime?
  cancelReason      String?

  // Trial
  trialStart DateTime?
  trialEnd   DateTime?

  // Pricing snapshot (at time of subscription)
  quantity   Int    @default(1)
  unitAmount Int // Price in cents
  currency   String @default("USD")

  // Discounts
  discountAmount Int     @default(0) // Discount in cents
  couponId       String?

  // Metadata
  metadata Json?

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  // Relations
  customer    BillingCustomer @relation(fields: [customerId], references: [id], onDelete: Cascade)
  licenseType LicenseType     @relation(fields: [licenseTypeId], references: [id])
  coupon      Coupon?         @relation(fields: [couponId], references: [id])
  invoices    Invoice[]

  @@index([customerId])
  @@index([licenseTypeId])
  @@index([status])
  @@index([stripeSubscriptionId])
  @@index([razorpaySubscriptionId])
  @@map("subscriptions")
}

// Invoice - billing documents
model Invoice {
  id             String  @id @default(cuid())
  invoiceNumber  String  @unique
  customerId     String
  subscriptionId String?

  // Gateway invoice IDs
  stripeInvoiceId   String? @unique
  razorpayInvoiceId String? @unique

  // Invoice details
  status   InvoiceStatus   @default(DRAFT)
  gateway  PaymentGateway?
  currency String          @default("USD")

  // Amounts (all in cents)
  subtotal       Int @default(0)
  discountAmount Int @default(0)
  taxAmount      Int @default(0)
  total          Int @default(0)
  amountPaid     Int @default(0)
  amountDue      Int @default(0)

  // Dates
  invoiceDate DateTime  @default(now())
  dueDate     DateTime?
  paidAt      DateTime?

  // Billing details
  billingReason String? // subscription_create, subscription_cycle, manual
  description   String?
  notes         String?
  footer        String?

  // URLs
  pdfUrl           String?
  hostedInvoiceUrl String?

  // Metadata
  metadata Json?

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  // Relations
  customer     BillingCustomer   @relation(fields: [customerId], references: [id], onDelete: Cascade)
  subscription Subscription?     @relation(fields: [subscriptionId], references: [id])
  lineItems    InvoiceLineItem[]
  payments     Payment[]

  // Outcome billing events
  outcomeEvents OutcomeEvent[]

  @@index([customerId])
  @@index([subscriptionId])
  @@index([status])
  @@index([invoiceDate])
  @@index([stripeInvoiceId])
  @@index([razorpayInvoiceId])
  @@map("invoices")
}

// Invoice line items - individual charges on invoice
model InvoiceLineItem {
  id        String @id @default(cuid())
  invoiceId String

  description String
  quantity    Int    @default(1)
  unitAmount  Int // Price per unit in cents
  amount      Int // Total (quantity * unitAmount) in cents

  // Period covered
  periodStart DateTime?
  periodEnd   DateTime?

  // Type of charge
  type String? // license, addon, tax, discount

  metadata  Json?
  createdAt DateTime @default(now())

  // Relations
  invoice Invoice @relation(fields: [invoiceId], references: [id], onDelete: Cascade)

  @@index([invoiceId])
  @@map("invoice_line_items")
}

// Payment - individual payment transactions
model Payment {
  id         String  @id @default(cuid())
  customerId String
  invoiceId  String?

  // Gateway payment IDs
  stripePaymentIntentId String? @unique
  razorpayPaymentId     String? @unique

  // Payment details
  gateway PaymentGateway
  status  PaymentStatus  @default(PENDING)

  amount   Int // Amount in cents
  currency String @default("USD")

  // Payment method details (snapshot)
  paymentMethodType String? // card, upi, netbanking, wallet
  cardBrand         String? // visa, mastercard, amex
  cardLast4         String?

  // Failure info
  failureCode    String?
  failureMessage String?

  // Refund info
  refundedAmount Int       @default(0)
  refundedAt     DateTime?
  refundReason   String?

  // Metadata
  metadata   Json?
  receiptUrl String?

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  // Relations
  customer BillingCustomer @relation(fields: [customerId], references: [id], onDelete: Cascade)
  invoice  Invoice?        @relation(fields: [invoiceId], references: [id])

  @@index([customerId])
  @@index([invoiceId])
  @@index([status])
  @@index([stripePaymentIntentId])
  @@index([razorpayPaymentId])
  @@map("payments")
}

// Payment method - saved payment methods
model PaymentMethod {
  id         String @id @default(cuid())
  customerId String

  // Gateway payment method IDs
  stripePaymentMethodId String? @unique
  razorpayTokenId       String?

  // Method details
  gateway   PaymentGateway
  type      String // card, upi, netbanking
  isDefault Boolean        @default(false)

  // Card details (masked)
  cardBrand    String?
  cardLast4    String?
  cardExpMonth Int?
  cardExpYear  Int?
  cardFunding  String? // credit, debit, prepaid

  // Billing address
  billingDetails Json?

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  // Relations
  customer BillingCustomer @relation(fields: [customerId], references: [id], onDelete: Cascade)

  @@index([customerId])
  @@index([stripePaymentMethodId])
  @@map("payment_methods")
}

// Coupon - discount codes
model Coupon {
  id          String  @id @default(cuid())
  code        String  @unique
  name        String
  description String?

  // Discount details
  discountType  DiscountType
  discountValue Int // Percentage (0-100) or cents
  currency      String? // Required for FIXED_AMOUNT

  // Duration
  duration       CouponDuration
  durationMonths Int? // For REPEATING duration

  // Limits
  maxRedemptions        Int? // Max total uses (null = unlimited)
  maxRedemptionsPerUser Int? @default(1)
  timesRedeemed         Int  @default(0)

  // Restrictions
  appliesToPlans    String[] @default([]) // LicenseType IDs, empty = all
  minPurchaseAmount Int? // Minimum in cents
  firstTimeOnly     Boolean  @default(false)

  // Validity
  startsAt  DateTime?
  expiresAt DateTime?
  isActive  Boolean   @default(true)

  // Gateway sync
  stripeCouponId   String? @unique
  razorpayCouponId String?

  // Metadata
  metadata  Json?
  createdBy String?

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  // Relations
  subscriptions Subscription[]
  redemptions   CouponRedemption[]

  @@index([code])
  @@index([isActive])
  @@index([expiresAt])
  @@map("coupons")
}

// Coupon redemption tracking
model CouponRedemption {
  id       String @id @default(cuid())
  couponId String
  userId   String

  // Optional reference to what was discounted
  subscriptionId String?
  invoiceId      String?

  discountApplied Int // Amount saved in cents

  redeemedAt DateTime @default(now())

  // Relations
  coupon Coupon @relation(fields: [couponId], references: [id], onDelete: Cascade)

  @@unique([couponId, userId])
  @@index([userId])
  @@map("coupon_redemptions")
}

// Webhook event log - tracks incoming webhooks for idempotency
model WebhookEvent {
  id        String         @id @default(cuid())
  gateway   PaymentGateway
  eventId   String         @unique // Gateway's event ID
  eventType String

  // Processing status
  processed   Boolean   @default(false)
  processedAt DateTime?

  // Payload
  payload Json

  // Error tracking
  attempts  Int     @default(0)
  lastError String?

  createdAt DateTime @default(now())

  @@index([gateway])
  @@index([eventType])
  @@index([processed])
  @@map("webhook_events")
}

// ==================== PHASE 1 FEATURES ====================

// ==================== TWO-FACTOR AUTHENTICATION ====================

model TwoFactorAuth {
  id     String @id @default(cuid())
  userId String @unique

  // TOTP Configuration
  secret    String // Encrypted TOTP secret
  isEnabled Boolean   @default(false)
  enabledAt DateTime?

  // Recovery
  backupCodes          String[] // Encrypted backup codes
  backupCodesUsed      Int       @default(0)
  lastBackupCodeUsedAt DateTime?

  // Verification tracking
  lastVerifiedAt DateTime?
  failedAttempts Int       @default(0)
  lockedUntil    DateTime?

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  // Relations
  trustedDevices TrustedDevice[]

  @@map("two_factor_auth")
}

model TrustedDevice {
  id              String @id @default(cuid())
  twoFactorAuthId String

  deviceName  String
  deviceType  String // desktop, mobile, tablet
  browserInfo String?
  ipAddress   String?
  location    String?

  deviceFingerprint String // Hashed device identifier

  trustedAt  DateTime @default(now())
  lastUsedAt DateTime @default(now())
  expiresAt  DateTime // Trust expiration

  twoFactorAuth TwoFactorAuth @relation(fields: [twoFactorAuthId], references: [id], onDelete: Cascade)

  @@unique([twoFactorAuthId, deviceFingerprint])
  @@index([deviceFingerprint])
  @@map("trusted_devices")
}

// ==================== PROFILES & PERMISSIONS (RBAC) ====================

model Profile {
  id          String  @id @default(cuid())
  name        String  @unique
  description String?

  isSystem  Boolean @default(false) // System profiles can't be deleted
  isDefault Boolean @default(false) // Default profile for new users

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  // Relations
  permissions ProfilePermission[]
  users       UserProfile[]

  @@map("profiles")
}

model ProfilePermission {
  id        String @id @default(cuid())
  profileId String

  module String // leads, contacts, accounts, opportunities, etc.

  // CRUD permissions
  canRead   Boolean @default(false)
  canCreate Boolean @default(false)
  canEdit   Boolean @default(false)
  canDelete Boolean @default(false)

  // Data access level
  dataAccess DataAccessLevel @default(OWN)

  profile Profile @relation(fields: [profileId], references: [id], onDelete: Cascade)

  @@unique([profileId, module])
  @@map("profile_permissions")
}

model UserProfile {
  id        String @id @default(cuid())
  userId    String
  profileId String

  assignedAt DateTime @default(now())
  assignedBy String?

  profile Profile @relation(fields: [profileId], references: [id], onDelete: Cascade)

  @@unique([userId, profileId])
  @@index([userId])
  @@index([profileId])
  @@map("user_profiles")
}

enum DataAccessLevel {
  NONE // No access
  OWN // Only own records
  TEAM // Own team's records
  ALL // All records
}

// ==================== CUSTOM FIELDS ====================

model CustomFieldDefinition {
  id String @id @default(cuid())

  name        String // API name (e.g., custom_field_1)
  label       String // Display label
  description String?

  entity    CustomFieldEntity
  fieldType CustomFieldType

  // Validation
  isRequired   Boolean @default(false)
  isUnique     Boolean @default(false)
  defaultValue String?

  // For picklist/multi-picklist types
  picklistValues Json? // Array of {value, label, isActive, sortOrder}

  // For lookup type
  lookupEntity CustomFieldEntity?

  // For number/currency types
  precision Int? // Decimal places
  minValue  Float?
  maxValue  Float?

  // For text types
  maxLength Int?
  pattern   String? // Regex pattern

  sortOrder Int     @default(0)
  isActive  Boolean @default(true)

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
  createdBy String?

  // Relations
  values CustomFieldValue[]

  @@unique([entity, name])
  @@index([entity])
  @@index([isActive])
  @@map("custom_field_definitions")
}

model CustomFieldValue {
  id      String @id @default(cuid())
  fieldId String

  // Polymorphic reference to the record
  entityType CustomFieldEntity
  entityId   String

  // Value storage (use appropriate field based on type)
  textValue    String?
  numberValue  Float?
  booleanValue Boolean?
  dateValue    DateTime?
  jsonValue    Json? // For multi-picklist, lookup references

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  field CustomFieldDefinition @relation(fields: [fieldId], references: [id], onDelete: Cascade)

  @@unique([fieldId, entityType, entityId])
  @@index([entityType, entityId])
  @@map("custom_field_values")
}

enum CustomFieldEntity {
  LEAD
  CONTACT
  ACCOUNT
  OPPORTUNITY
  PRODUCT
  QUOTE
}

enum CustomFieldType {
  TEXT
  TEXTAREA
  NUMBER
  CURRENCY
  DATE
  DATETIME
  CHECKBOX
  PICKLIST
  MULTI_PICKLIST
  EMAIL
  PHONE
  URL
  LOOKUP
}

// ==================== PRICE BOOKS ====================

model PriceBook {
  id String @id @default(cuid())

  name        String
  description String?
  currency    String  @default("USD")

  isStandard Boolean @default(false) // Standard price book
  isActive   Boolean @default(true)

  // Validity period
  validFrom DateTime?
  validTo   DateTime?

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
  createdBy String?

  // Relations
  entries PriceBookEntry[]

  @@index([isActive])
  @@index([isStandard])
  @@map("price_books")
}

model PriceBookEntry {
  id          String @id @default(cuid())
  priceBookId String
  productId   String

  listPrice   Float
  unitPrice   Float? // Override unit price
  minQuantity Int    @default(1)

  // Discount tiers (JSON array)
  discountTiers Json? // [{minQty, maxQty, discountPercent}]

  isActive Boolean @default(true)

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  priceBook PriceBook @relation(fields: [priceBookId], references: [id], onDelete: Cascade)

  @@unique([priceBookId, productId])
  @@index([productId])
  @@map("price_book_entries")
}

// ==================== ASSIGNMENT RULES ====================

model AssignmentRule {
  id String @id @default(cuid())

  name        String
  description String?

  entity AssignmentRuleEntity
  method AssignmentMethod

  isActive Boolean @default(true)
  priority Int     @default(0) // Lower = higher priority

  // For round-robin tracking
  lastAssignedIndex Int @default(0)

  // Fallback owner if no match
  fallbackOwnerId String?

  // Notification settings
  notifyAssignee   Boolean @default(true)
  notifyTemplateId String?

  // Stats
  executionCount Int       @default(0)
  lastExecutedAt DateTime?

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
  createdBy String?

  // Relations
  conditions AssignmentRuleCondition[]
  assignees  AssignmentRuleAssignee[]

  @@index([entity])
  @@index([isActive])
  @@index([priority])
  @@map("assignment_rules")
}

model AssignmentRuleCondition {
  id     String @id @default(cuid())
  ruleId String

  field    String // Field to evaluate
  operator ConditionOperator
  value    String // Value to compare (JSON for arrays)

  logicalOperator LogicalOperator @default(AND)
  sortOrder       Int             @default(0)

  rule AssignmentRule @relation(fields: [ruleId], references: [id], onDelete: Cascade)

  @@index([ruleId])
  @@map("assignment_rule_conditions")
}

model AssignmentRuleAssignee {
  id     String @id @default(cuid())
  ruleId String
  userId String

  weight           Int  @default(1) // For weighted distribution
  maxActiveRecords Int? // Max records before skipping

  isActive Boolean @default(true)

  rule AssignmentRule @relation(fields: [ruleId], references: [id], onDelete: Cascade)

  @@unique([ruleId, userId])
  @@map("assignment_rule_assignees")
}

enum AssignmentRuleEntity {
  LEAD
  CONTACT
  OPPORTUNITY
}

enum AssignmentMethod {
  ROUND_ROBIN
  LOAD_BALANCED
  FIXED
  TERRITORY
  LEAD_SCORE
}

enum ConditionOperator {
  EQUALS
  NOT_EQUALS
  CONTAINS
  NOT_CONTAINS
  STARTS_WITH
  ENDS_WITH
  GREATER_THAN
  GREATER_THAN_OR_EQUAL
  LESS_THAN
  LESS_THAN_OR_EQUAL
  IN
  NOT_IN
  IS_EMPTY
  IS_NOT_EMPTY
  BETWEEN
}

enum LogicalOperator {
  AND
  OR
}

// ==================== WEB FORMS (Lead Capture) ====================

model WebForm {
  id String @id @default(cuid())

  name        String
  description String?
  slug        String  @unique // URL-friendly identifier

  // Form configuration
  fields   Json // Array of field definitions
  styling  Json? // Custom styling options
  settings Json? // Form behavior settings

  // Success/error handling
  successMessage     String?
  successRedirectUrl String?
  errorMessage       String?

  // Assignment
  assignmentRuleId String?
  defaultOwnerId   String?

  // Tracking
  isActive         Boolean   @default(true)
  submissionCount  Int       @default(0)
  lastSubmissionAt DateTime?

  // CAPTCHA
  enableCaptcha Boolean @default(true)
  captchaType   String? // recaptcha, hcaptcha, etc.

  // Rate limiting
  maxSubmissionsPerHour Int?
  maxSubmissionsPerDay  Int?

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
  createdBy String?

  // Relations
  submissions WebFormSubmission[]

  @@index([slug])
  @@index([isActive])
  @@map("web_forms")
}

model WebFormSubmission {
  id     String @id @default(cuid())
  formId String

  // Submitted data
  data Json // Form field values

  // Processing status
  status       WebFormSubmissionStatus @default(PENDING)
  processedAt  DateTime?
  errorMessage String?

  // Created record reference
  createdLeadId    String?
  createdContactId String?

  // Metadata
  ipAddress String?
  userAgent String?
  referrer  String?

  createdAt DateTime @default(now())

  form WebForm @relation(fields: [formId], references: [id], onDelete: Cascade)

  @@index([formId])
  @@index([status])
  @@index([createdAt])
  @@map("web_form_submissions")
}

enum WebFormSubmissionStatus {
  PENDING
  PROCESSED
  FAILED
  DUPLICATE
  SPAM
}

// ==================== API KEYS (Public REST API) ====================

model ApiKey {
  id     String @id @default(cuid())
  userId String

  name        String
  description String?

  // Key (hashed for storage, shown once on creation)
  keyHash   String @unique
  keyPrefix String // First 8 chars for identification

  // Permissions/Scopes
  scopes String[] // read:leads, write:contacts, etc.

  // Restrictions
  ipWhitelist     String[] @default([])
  domainWhitelist String[] @default([])

  // Rate limiting
  rateLimit       Int @default(1000) // Requests per hour
  rateLimitWindow Int @default(3600) // Window in seconds

  // Status
  status     ApiKeyStatus @default(ACTIVE)
  lastUsedAt DateTime?
  usageCount Int          @default(0)

  // Expiration
  expiresAt DateTime?

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  // Relations
  usageLogs ApiKeyUsageLog[]

  @@index([userId])
  @@index([keyPrefix])
  @@index([status])
  @@map("api_keys")
}

model ApiKeyUsageLog {
  id       String @id @default(cuid())
  apiKeyId String

  endpoint       String
  method         String
  statusCode     Int
  responseTimeMs Int

  ipAddress String?
  userAgent String?

  requestId    String?
  errorMessage String?

  createdAt DateTime @default(now())

  apiKey ApiKey @relation(fields: [apiKeyId], references: [id], onDelete: Cascade)

  @@index([apiKeyId])
  @@index([createdAt])
  @@map("api_key_usage_logs")
}

enum ApiKeyStatus {
  ACTIVE
  REVOKED
  EXPIRED
}

// ==================== WEBHOOKS (General Purpose) ====================

model Webhook {
  id     String @id @default(cuid())
  userId String

  name        String
  description String?

  // Endpoint
  url    String
  secret String // For signature verification

  // Events to subscribe to
  events String[] // lead.created, contact.updated, etc.

  // Configuration
  isActive          Boolean @default(true)
  retryEnabled      Boolean @default(true)
  maxRetries        Int     @default(3)
  retryDelaySeconds Int     @default(60)

  // Headers
  customHeaders Json? // Additional headers to send

  // Stats
  deliveryCount       Int       @default(0)
  successCount        Int       @default(0)
  failureCount        Int       @default(0)
  consecutiveFailures Int       @default(0)
  lastDeliveryAt      DateTime?
  lastSuccessAt       DateTime?
  lastFailureAt       DateTime?

  // Auto-disable after too many failures
  autoDisableThreshold Int     @default(10)
  disabledReason       String?

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  // Relations
  deliveryLogs WebhookDeliveryLog[]

  @@index([userId])
  @@index([isActive])
  @@map("webhooks")
}

model WebhookDeliveryLog {
  id        String @id @default(cuid())
  webhookId String

  event   String // Event type
  eventId String // Unique event ID for idempotency

  // Request
  requestPayload Json
  requestHeaders Json?

  // Response
  statusCode     Int?
  responseBody   String?
  responseTimeMs Int?

  // Status
  success      Boolean @default(false)
  errorMessage String?

  // Retry tracking
  attemptNumber Int       @default(1)
  nextRetryAt   DateTime?

  createdAt DateTime @default(now())

  webhook Webhook @relation(fields: [webhookId], references: [id], onDelete: Cascade)

  @@index([webhookId])
  @@index([eventId])
  @@index([success])
  @@index([createdAt])
  @@map("webhook_delivery_logs")
}

// ==================== CPQ PHASE 4 - ORDERS & E-SIGNATURE ====================

// Order status enum
enum OrderStatus {
  DRAFT
  PENDING
  CONFIRMED
  PROCESSING
  SHIPPED
  DELIVERED
  CANCELLED
  ON_HOLD
}

// Order payment status enum
enum OrderPaymentStatus {
  UNPAID
  PARTIAL
  PAID
  REFUNDED
  CANCELLED
}

// Order fulfillment status enum
enum OrderFulfillmentStatus {
  UNFULFILLED
  PARTIAL
  FULFILLED
  RETURNED
}

// ORDER - Sales orders converted from quotes
model Order {
  id             String  @id @default(cuid())
  ownerId        String
  organizationId String? // Multi-tenant isolation
  accountId      String
  quoteId        String? @unique // Source quote if converted

  orderNumber String      @unique
  name        String
  status      OrderStatus @default(DRAFT)

  // Pricing
  subtotal Float  @default(0)
  discount Float  @default(0)
  tax      Float  @default(0)
  shipping Float  @default(0)
  total    Float  @default(0)
  currency String @default("USD")

  // Payment
  paymentStatus OrderPaymentStatus @default(UNPAID)
  paymentMethod String?
  paymentTerms  String?
  paidAmount    Float              @default(0)
  paidAt        DateTime?

  // Fulfillment
  fulfillmentStatus OrderFulfillmentStatus @default(UNFULFILLED)
  shippingMethod    String?
  trackingNumber    String?
  shippedAt         DateTime?
  deliveredAt       DateTime?

  // Dates
  orderDate            DateTime  @default(now())
  expectedDeliveryDate DateTime?

  // Billing Address
  billingStreet     String?
  billingCity       String?
  billingState      String?
  billingPostalCode String?
  billingCountry    String?

  // Shipping Address
  shippingStreet     String?
  shippingCity       String?
  shippingState      String?
  shippingPostalCode String?
  shippingCountry    String?

  // Notes
  notes         String? // Customer-visible notes
  internalNotes String? // Internal only

  metadata  Json?
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  // Relations
  lineItems OrderLineItem[]
  account   Account         @relation(fields: [accountId], references: [id], onDelete: Cascade)

  // Multi-tenant
  organization Organization? @relation("OrganizationOrders", fields: [organizationId], references: [id], onDelete: SetNull)

  @@index([ownerId])
  @@index([accountId])
  @@index([quoteId])
  @@index([status])
  @@index([paymentStatus])
  @@index([fulfillmentStatus])
  @@index([orderDate])
  @@index([organizationId])
  @@map("orders")
}

// ORDER LINE ITEM - Products/services on an order
model OrderLineItem {
  id      String @id @default(cuid())
  orderId String

  productId   String?
  productName String
  productCode String?
  description String?

  quantity        Float  @default(1)
  unitPrice       Float
  discount        Float  @default(0)
  discountPercent Float?
  tax             Float  @default(0)
  totalPrice      Float

  // Fulfillment tracking per line item
  quantityShipped   Float @default(0)
  quantityDelivered Float @default(0)
  quantityReturned  Float @default(0)

  sortOrder Int?

  metadata  Json?
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  order Order @relation(fields: [orderId], references: [id], onDelete: Cascade)

  @@index([orderId])
  @@index([productId])
  @@map("order_line_items")
}

// E-Signature provider enum
enum ESignProvider {
  DOCUSIGN
  ADOBE_SIGN
  HELLOSIGN
  PANDADOC
  INTERNAL
}

// E-Signature status enum
enum ESignStatus {
  DRAFT
  PENDING
  SENT
  VIEWED
  SIGNED
  COMPLETED
  DECLINED
  VOIDED
  EXPIRED
}

// E-SIGNATURE REQUEST - E-signature requests for quotes
model ESignatureRequest {
  id      String @id @default(cuid())
  quoteId String

  provider   ESignProvider
  externalId String? // ID from the e-signature provider

  status  ESignStatus @default(DRAFT)
  subject String
  message String?

  // Signers JSON array: [{name, email, role, order, status, signedAt}]
  signers Json

  // Document info
  documentUrl       String?
  signedDocumentUrl String?

  // Provider webhook data
  webhookPayload Json?

  // Timestamps
  sentAt      DateTime?
  viewedAt    DateTime?
  signedAt    DateTime?
  completedAt DateTime?
  declinedAt  DateTime?
  voidedAt    DateTime?
  expiresAt   DateTime?

  // Decline/void info
  declinedReason String?
  voidedReason   String?

  metadata  Json?
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  // Relations
  quote Quote @relation(fields: [quoteId], references: [id], onDelete: Cascade)

  @@index([quoteId])
  @@index([provider])
  @@index([status])
  @@index([externalId])
  @@map("esignature_requests")
}

// CPQ ANALYTICS SNAPSHOT - Daily snapshots of CPQ metrics for historical tracking
model CPQAnalyticsSnapshot {
  id      String   @id @default(cuid())
  ownerId String
  date    DateTime @db.Date

  // Quote metrics
  quotesCreated  Int
  quotesAccepted Int
  totalValue     Decimal @db.Decimal(15, 2)
  acceptedValue  Decimal @db.Decimal(15, 2)

  // Top products JSON: [{productName, count, value}]
  topProducts Json?

  createdAt DateTime @default(now())

  @@unique([ownerId, date])
  @@index([ownerId])
  @@index([date])
  @@map("cpq_analytics_snapshots")
}

// ============================================
// TERRITORY MANAGEMENT
// ============================================

enum TerritoryType {
  GEOGRAPHIC
  INDUSTRY
  ACCOUNT_SIZE
  NAMED_ACCOUNTS
  CUSTOM
}

model Territory {
  id             String        @id @default(cuid())
  organizationId String? // Multi-tenant isolation
  name           String
  description    String?
  type           TerritoryType @default(GEOGRAPHIC)

  // Assignment criteria - flexible JSON for rules
  // e.g., { "states": ["CA", "OR", "WA"] } or { "industries": ["Technology", "SaaS"] }
  criteria Json?

  // Territory owner/manager
  ownerId String?

  // Visual
  color String? // Hex color for UI

  // Status
  isActive Boolean @default(true)

  // Metadata
  metadata  Json?
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  // Relations
  owner            User?                 @relation(fields: [ownerId], references: [id])
  accountMappings  TerritoryAccount[]
  performanceStats TerritoryPerformance?

  // Multi-tenant
  organization Organization? @relation("OrganizationTerritories", fields: [organizationId], references: [id], onDelete: SetNull)

  @@index([ownerId])
  @@index([type])
  @@index([isActive])
  @@index([organizationId])
  @@map("territories")
}

// Many-to-many mapping of accounts to territories
model TerritoryAccount {
  id          String   @id @default(cuid())
  territoryId String
  accountId   String
  assignedAt  DateTime @default(now())
  assignedBy  String?

  territory Territory @relation(fields: [territoryId], references: [id], onDelete: Cascade)
  account   Account   @relation(fields: [accountId], references: [id], onDelete: Cascade)

  @@unique([territoryId, accountId])
  @@index([territoryId])
  @@index([accountId])
  @@map("territory_accounts")
}

// Cached performance stats for territories (updated periodically)
model TerritoryPerformance {
  id          String @id @default(cuid())
  territoryId String @unique

  accountCount    Int     @default(0)
  pipelineValue   Decimal @default(0) @db.Decimal(15, 2)
  closedWonValue  Decimal @default(0) @db.Decimal(15, 2)
  closedLostValue Decimal @default(0) @db.Decimal(15, 2)
  openDealsCount  Int     @default(0)
  avgDealSize     Decimal @default(0) @db.Decimal(15, 2)
  winRate         Float   @default(0)

  lastCalculatedAt DateTime @default(now())
  createdAt        DateTime @default(now())
  updatedAt        DateTime @updatedAt

  territory Territory @relation(fields: [territoryId], references: [id], onDelete: Cascade)

  @@map("territory_performance")
}

// ============================================
// SALES PLAYBOOKS
// ============================================

enum PlaybookStepType {
  TASK
  EMAIL
  CALL
  MEETING
  DOCUMENT
  WAIT
  CONDITION
}

enum PlaybookTrigger {
  DEAL_CREATED
  DEAL_STAGE_CHANGED
  LEAD_CREATED
  LEAD_QUALIFIED
  ACCOUNT_CREATED
  MANUAL
}

model Playbook {
  id             String          @id @default(cuid())
  organizationId String? // Multi-tenant isolation
  name           String
  description    String?
  trigger        PlaybookTrigger @default(MANUAL)

  // Target criteria
  targetStage    String? // Which deal stage this applies to
  targetDealType String? // e.g., "Enterprise", "SMB", "Renewal"

  // Status
  isActive  Boolean @default(true)
  isDefault Boolean @default(false)

  // Usage stats
  usageCount  Int   @default(0)
  successRate Float @default(0) // Percentage of successful completions

  // Metadata
  metadata  Json?
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
  createdBy String?

  // Relations
  steps      PlaybookStep[]
  executions PlaybookExecution[]
  creator    User?               @relation(fields: [createdBy], references: [id])

  // Multi-tenant
  organization Organization? @relation("OrganizationPlaybooks", fields: [organizationId], references: [id], onDelete: SetNull)

  @@index([trigger])
  @@index([isActive])
  @@index([targetStage])
  @@index([organizationId])
  @@map("playbooks")
}

model PlaybookStep {
  id         String           @id @default(cuid())
  playbookId String
  order      Int
  type       PlaybookStepType

  // Step details
  title       String
  description String?

  // Timing
  daysOffset Int     @default(0) // Days from playbook start (negative for before)
  isRequired Boolean @default(false)

  // Type-specific config (stored as JSON)
  // For EMAIL: { templateId, subject, body }
  // For TASK: { assignTo, priority }
  // For MEETING: { duration, agenda }
  // For CONDITION: { field, operator, value }
  config Json?

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  // Relations
  playbook       Playbook                @relation(fields: [playbookId], references: [id], onDelete: Cascade)
  stepExecutions PlaybookStepExecution[]

  @@index([playbookId])
  @@index([order])
  @@map("playbook_steps")
}

// Track playbook executions on deals/leads
model PlaybookExecution {
  id         String  @id @default(cuid())
  playbookId String
  userId     String
  dealId     String?
  leadId     String?
  accountId  String?

  status       PlaybookExecutionStatus @default(IN_PROGRESS)
  startedAt    DateTime                @default(now())
  completedAt  DateTime?
  currentStep  Int                     @default(1)
  totalSteps   Int
  successScore Float? // 0-100 based on completion and outcomes

  metadata  Json?
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  // Relations
  playbook       Playbook                @relation(fields: [playbookId], references: [id], onDelete: Cascade)
  stepExecutions PlaybookStepExecution[]

  @@index([playbookId])
  @@index([userId])
  @@index([dealId])
  @@index([status])
  @@map("playbook_executions")
}

enum PlaybookExecutionStatus {
  IN_PROGRESS
  COMPLETED
  PAUSED
  CANCELLED
  FAILED
}

model PlaybookStepExecution {
  id          String @id @default(cuid())
  executionId String
  stepId      String

  status      PlaybookStepStatus @default(PENDING)
  scheduledAt DateTime?
  startedAt   DateTime?
  completedAt DateTime?
  skippedAt   DateTime?

  // Outcome/notes
  outcome String?
  notes   String?

  // Related activity created by this step
  activityId String?

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  // Relations
  execution PlaybookExecution @relation(fields: [executionId], references: [id], onDelete: Cascade)
  step      PlaybookStep      @relation(fields: [stepId], references: [id], onDelete: Cascade)

  @@unique([executionId, stepId])
  @@index([executionId])
  @@index([stepId])
  @@index([status])
  @@map("playbook_step_executions")
}

enum PlaybookStepStatus {
  PENDING
  SCHEDULED
  IN_PROGRESS
  COMPLETED
  SKIPPED
  FAILED
}

// ============================================
// DIGITAL WORKER SYSTEM
// ============================================

// Signal types for account monitoring
enum SignalType {
  EXEC_CHANGE
  FUNDING
  EXPANSION
  NEWS
  USAGE_SPIKE
  USAGE_DECLINE
  ENGAGEMENT_SPIKE
  ENGAGEMENT_DECLINE
  TECH_CHANGE
  COMPETITIVE_THREAT
  CONTRACT_RENEWAL
  BUDGET_CYCLE
}

// Signal sources
enum SignalSource {
  INTERNAL_CRM
  ZOOMINFO
  SNOWFLAKE
  NEWS
  NEWSLETTER
  SIXSENSE
  MANUAL
}

// Signal status
enum SignalStatus {
  PENDING
  ACKNOWLEDGED
  ACTIONED
  DISMISSED
  EXPIRED
}

// Signal priority
enum SignalPriority {
  CRITICAL
  HIGH
  MEDIUM
  LOW
}

// AccountSignal - Detected change events and buying signals
model AccountSignal {
  id          String @id @default(cuid())
  accountId   String
  createdById String? // User who detected/created (for manual signals)

  // Signal details
  type        SignalType
  title       String
  description String?
  confidence  Float       @default(0.5) // 0.0 to 1.0
  source      SignalSource
  sourceId    String?     // External ID from source system (e.g., ZoomInfo ID)
  data        Json?       // Raw signal data from source

  // Recommended action
  recommendedAction String? // Suggested action type

  // Status tracking
  status          SignalStatus   @default(PENDING)
  priority        SignalPriority @default(MEDIUM)
  acknowledgedAt  DateTime?
  acknowledgedBy  String?
  actionedAt      DateTime?
  actionedBy      String?
  dismissedAt     DateTime?
  dismissedBy     String?
  dismissReason   String?

  // Expiration
  expiresAt DateTime?

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  // Relations
  account         Account              @relation(fields: [accountId], references: [id], onDelete: Cascade)
  recommendations SignalRecommendation[]

  @@index([accountId])
  @@index([type])
  @@index([status])
  @@index([priority])
  @@index([source])
  @@index([createdAt])
  @@index([expiresAt])
  @@map("account_signals")
}

// Recommendation action types
enum RecommendedActionType {
  CREATE_OPPORTUNITY
  UPDATE_OPPORTUNITY
  ESCALATE_OPPORTUNITY
  SEND_EMAIL
  SCHEDULE_CALL
  SCHEDULE_MEETING
  CREATE_TASK
  ASSIGN_TASK
  ESCALATE_TO_MANAGER
  ESCALATE_TO_EXECUTIVE
  LOG_INSIGHT
  UPDATE_ACCOUNT
  MONITOR
  DISMISS
}

// Recommendation status
enum RecommendationStatus {
  PENDING
  EXECUTED
  SKIPPED
  FAILED
}

// SignalRecommendation - AI-generated recommended actions for signals
model SignalRecommendation {
  id        String @id @default(cuid())
  signalId  String
  accountId String

  // Recommendation details
  action     RecommendedActionType
  rationale  String
  priority   String    @default("MEDIUM") // HIGH, MEDIUM, LOW
  confidence Float     @default(0.5)

  // Assignment
  suggestedAssignee String? // User ID or role (account_owner, sales_manager, etc.)
  playbookId        String? // Related playbook if applicable

  // Suggested content for action
  suggestedContent Json? // { emailSubject, emailBody, talkingPoints, etc. }

  // Execution tracking
  status      RecommendationStatus @default(PENDING)
  executedAt  DateTime?
  executedBy  String?
  result      Json?                // Outcome of execution
  errorMessage String?

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  // Relations
  signal AccountSignal @relation(fields: [signalId], references: [id], onDelete: Cascade)

  @@index([signalId])
  @@index([accountId])
  @@index([status])
  @@index([priority])
  @@map("signal_recommendations")
}

// Coaching agenda status
enum CoachingAgendaStatus {
  DRAFT
  SCHEDULED
  IN_PROGRESS
  COMPLETED
  CANCELLED
}

// CoachingAgenda - AI-generated coaching agendas for managers
model CoachingAgenda {
  id        String @id @default(cuid())
  repId     String // The sales rep being coached
  managerId String // The manager conducting the coaching

  // Agenda content
  agenda Json // Structured agenda with sections

  // Data snapshots
  pipelineSnapshot    Json? // Pipeline state at time of generation
  performanceSnapshot Json? // Performance metrics at time of generation

  // Status
  status      CoachingAgendaStatus @default(DRAFT)
  scheduledFor DateTime?
  startedAt   DateTime?
  completedAt DateTime?

  // Session outcomes
  sessionNotes    String?
  followUpActions Json?  // List of committed actions
  outcome         Json?  // Session outcome tracking

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@index([repId])
  @@index([managerId])
  @@index([status])
  @@index([scheduledFor])
  @@map("coaching_agendas")
}

// Action Item Status Enum
enum ActionItemStatus {
  PENDING
  IN_PROGRESS
  COMPLETED
  OVERDUE
  BLOCKED
  CANCELLED
}

// Slippage Reason Enum
enum SlippageReason {
  BLOCKER         // External dependency or blocker
  DEPRIORITIZED   // Intentionally deprioritized
  FORGOT          // Simply forgot or overlooked
  NO_TIME         // Didn't have time
  UNCLEAR         // Task wasn't clear
  OTHER           // Other reason
}

// Escalation Level Enum
enum EscalationLevel {
  NONE           // No escalation
  MANAGER        // First-level manager
  SKIP_LEVEL     // Skip-level escalation
  EXECUTIVE      // Executive escalation
}

// CoachingActionItem - Tracks action items from coaching sessions and 1:1s
model CoachingActionItem {
  id String @id @default(cuid())

  // Ownership
  repId     String // The sales rep who owns this action item
  managerId String // The manager who assigned/approved this item

  // Source tracking
  sourceType    ActionItemSourceType // Where this action item came from
  coachingAgendaId String?           // Link to coaching agenda if applicable
  meetingSessionId String?           // Link to meeting session if applicable

  // Action item details
  title       String
  description String?
  category    String?  // e.g., "Pipeline Management", "Skill Development", "Process"

  // Priority and status
  priority ActionItemPriority @default(MEDIUM)
  status   ActionItemStatus   @default(PENDING)

  // Timing
  dueDate       DateTime
  completedAt   DateTime?
  reminderSent  Boolean   @default(false)
  lastRemindedAt DateTime?

  // Slippage tracking
  isOverdue       Boolean        @default(false)
  slippageReason  SlippageReason?
  slippageNotes   String?
  daysOverdue     Int            @default(0)

  // Escalation tracking
  escalationLevel    EscalationLevel @default(NONE)
  escalatedAt        DateTime?
  escalatedTo        String?         // User ID of escalation recipient
  escalationHistory  Json?           // Array of escalation events

  // Completion details
  completionNotes    String?
  completionEvidence Json?   // Links to artifacts, deals, etc.

  // AI-generated insights
  aiRecommendation   String?  // AI suggestion for completing this item
  impactScore        Int?     // AI-estimated impact 0-100

  // Metadata
  metadata  Json?
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@index([repId])
  @@index([managerId])
  @@index([status])
  @@index([dueDate])
  @@index([isOverdue])
  @@index([escalationLevel])
  @@index([coachingAgendaId])
  @@map("coaching_action_items")
}

// Action Item Source Type Enum
enum ActionItemSourceType {
  COACHING_AGENDA    // From a coaching agenda/1:1
  MEETING_SESSION    // From a meeting analysis
  MANUAL             // Manually created
  AI_RECOMMENDATION  // AI-generated recommendation
}

// Action Item Priority Enum
enum ActionItemPriority {
  LOW
  MEDIUM
  HIGH
  URGENT
}

// Slippage Alert - Notifications sent for overdue items
model SlippageAlert {
  id String @id @default(cuid())

  // References
  actionItemId String
  recipientId  String  // Who received this alert (manager, skip-level, etc.)

  // Alert details
  alertType      SlippageAlertType
  escalationLevel EscalationLevel

  // Content
  title       String
  message     String
  actionUrl   String?

  // Status
  sentAt      DateTime?
  readAt      DateTime?
  acknowledgedAt DateTime?

  // Response tracking
  responseAction String?  // What action the recipient took
  responseNotes  String?

  createdAt DateTime @default(now())

  @@index([actionItemId])
  @@index([recipientId])
  @@index([alertType])
  @@index([createdAt])
  @@map("slippage_alerts")
}

// Slippage Alert Type Enum
enum SlippageAlertType {
  ITEM_OVERDUE         // Single item is overdue
  MULTIPLE_OVERDUE     // Rep has multiple overdue items
  PATTERN_DETECTED     // Pattern of missed deadlines
  ESCALATION_NOTICE    // Escalation notification
}

// QA Interaction tracking for Learn More Agent
model QAInteraction {
  id            String  @id @default(cuid())
  userId        String
  conversationId String?

  // Question details
  question     String
  questionType String // project_timeline, revenue_estimate, etc.

  // Answer details
  answer     String
  sources    String[] // Data sources used
  confidence Float    @default(0.5)

  // Context
  accountId     String?
  opportunityId String?

  // Feedback
  helpful  Boolean?
  feedback String?

  createdAt DateTime @default(now())

  @@index([userId])
  @@index([questionType])
  @@index([accountId])
  @@index([createdAt])
  @@map("qa_interactions")
}

// Playbook alignment analysis results
model PlaybookAnalysis {
  id              String @id @default(cuid())
  coachingSessionId String @unique
  playbookId      String?

  // Analysis results
  overallScore          Int     // 0-100
  stepAnalysis          Json    // Step-by-step analysis
  keyPhraseUsage        Json    // Used/missed phrases
  strengths             String[]
  gaps                  String[]
  coachingRecommendations Json  // Prioritized recommendations

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  // Relations
  session CoachingSession @relation(fields: [coachingSessionId], references: [id], onDelete: Cascade)

  @@index([coachingSessionId])
  @@index([playbookId])
  @@map("playbook_analyses")
}

// ============================================
// DIGITAL WORKER ADMIN CONFIGURATION
// ============================================

// Signal Rule Configuration - Defines rules for automatic signal detection
model SignalRule {
  id              String         @id @default(cuid())
  name            String
  description     String?
  signalType      SignalType
  triggerSource   SignalSource
  conditions      Json           // { field, operator, value, logic }
  priority        SignalPriority @default(MEDIUM)
  confidence      Float          @default(0.7)
  autoCreateSignal Boolean       @default(true)
  notifyOwner     Boolean        @default(true)
  isActive        Boolean        @default(true)
  triggerCount    Int            @default(0)
  lastTriggeredAt DateTime?
  createdBy       String?
  createdAt       DateTime       @default(now())
  updatedAt       DateTime       @updatedAt

  @@index([signalType])
  @@index([triggerSource])
  @@index([isActive])
  @@map("signal_rules")
}

// Agent schedule type enum
enum AgentScheduleType {
  MANUAL
  REALTIME
  HOURLY
  DAILY
  WEEKLY
}

// Agent Configuration - Configures behavior of digital worker agents
model AgentConfig {
  id                   String            @id @default(cuid())
  agentType            String            @unique // LISTENING, REASONING, LEARN_MORE, EMAIL_ACTION, CRM_ACTION, MEETING_ACTION
  name                 String
  description          String?
  isEnabled            Boolean           @default(true)
  scheduleType         AgentScheduleType @default(MANUAL)
  cronSchedule         String?
  parameters           Json?             // Agent-specific configuration
  allowedIntegrations  String[]          @default([])
  maxExecutionsPerHour Int               @default(60)
  maxTokensPerExecution Int              @default(4000)
  totalExecutions      Int               @default(0)
  successfulExecutions Int               @default(0)
  failedExecutions     Int               @default(0)
  avgExecutionTime     Float             @default(0)
  lastExecutedAt       DateTime?
  lastError            String?
  createdAt            DateTime          @default(now())
  updatedAt            DateTime          @updatedAt

  @@index([agentType])
  @@index([isEnabled])
  @@map("agent_configs")
}

// ============================================
// OUTCOME-BASED BILLING
// ============================================

enum OutcomePricingModel {
  REVENUE_SHARE     // X% of deal value
  TIERED_FLAT_FEE   // Different fees based on deal size brackets
  HYBRID            // Base subscription + reduced outcome fees
  FLAT_PER_DEAL     // Fixed fee per closed deal
}

enum OutcomeEventStatus {
  PENDING            // Recorded but not yet invoiced
  INVOICED           // Included in an invoice
  PAID               // Invoice has been paid
  WAIVED             // Fee waived (manual override)
  VOIDED             // Voided (e.g., deal was reopened)
  FLAGGED_FOR_REVIEW // Deal was reopened - needs admin review
}

// Outcome Pricing Plan - defines pricing model per organization
model OutcomePricingPlan {
  id             String              @id @default(cuid())
  organizationId String              @unique

  pricingModel   OutcomePricingModel @default(REVENUE_SHARE)

  // Revenue Share (pricingModel = REVENUE_SHARE)
  revenueSharePercent Float?         // e.g., 2.5 for 2.5%

  // Tiered Flat Fee (pricingModel = TIERED_FLAT_FEE)
  // JSON: [{minAmount: 0, maxAmount: 1000000, fee: 5000}, ...]
  tierConfiguration Json?

  // Flat Per Deal (pricingModel = FLAT_PER_DEAL)
  flatFeePerDeal Int?                // Fee in cents

  // Hybrid (pricingModel = HYBRID)
  baseSubscriptionId String?
  outcomePercent     Float?          // Lower % when combined with subscription

  // Limits
  monthlyCap   Int?                  // Max monthly charges in cents (null = no cap)
  minDealValue Int?                  // Min deal value to trigger billing (cents)

  // Profitability safeguards
  minFeePerDeal     Int?             // Minimum fee per deal in cents (e.g., 10000 = $100 min)
  platformAccessFee Int?             // Monthly platform fee in cents (charged regardless of deals)

  // License/Access control
  grantsFullAccess  Boolean @default(true)  // Whether this plan grants full platform access

  // Billing settings
  billingDay Int     @default(1)     // Day of month (1-28)
  currency   String  @default("USD")
  isActive   Boolean @default(true)

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  // Relations
  organization  Organization   @relation(fields: [organizationId], references: [id], onDelete: Cascade)
  outcomeEvents OutcomeEvent[]

  @@index([organizationId])
  @@index([isActive])
  @@map("outcome_pricing_plans")
}

// Outcome Event - records each deal close for billing purposes
model OutcomeEvent {
  id                   String @id @default(cuid())
  organizationId       String
  outcomePricingPlanId String
  opportunityId        String

  // Snapshot at close time
  opportunityName String
  accountName     String
  dealAmount      Int       // Deal value in cents
  closedDate      DateTime
  ownerId         String
  ownerName       String?

  // Calculated fee
  feeAmount      Int        // Fee in cents
  feeCalculation Json?      // Breakdown of calculation

  // Billing status
  status            OutcomeEventStatus @default(PENDING)
  invoiceId         String?
  invoiceLineItemId String?
  invoicedAt        DateTime?

  // Billing period
  billingPeriodStart DateTime
  billingPeriodEnd   DateTime

  // Admin notes
  adminNotes String?
  reviewedBy String?
  reviewedAt DateTime?

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  // Relations
  outcomePricingPlan OutcomePricingPlan @relation(fields: [outcomePricingPlanId], references: [id], onDelete: Cascade)
  invoice            Invoice?           @relation(fields: [invoiceId], references: [id])

  @@index([organizationId])
  @@index([outcomePricingPlanId])
  @@index([opportunityId])
  @@index([status])
  @@index([billingPeriodStart, billingPeriodEnd])
  @@map("outcome_events")
}

// ============================================================================
// REAL-TIME COLLABORATION
// ============================================================================

// Entity Lock - manages edit locking for collaborative editing
model EntityLock {
  id         String   @id @default(cuid())
  entityType String   // 'deal', 'quote', 'lead', 'contact', 'account', 'order', etc.
  entityId   String   // ID of the locked entity
  userId     String   // User holding the lock
  userName   String   // User's name for display
  userEmail  String?  // User's email for identification
  acquiredAt DateTime @default(now())
  expiresAt  DateTime // Lock expires automatically after TTL

  @@unique([entityType, entityId])
  @@index([expiresAt])
  @@index([userId])
  @@map("entity_locks")
}

// Entity Presence - tracks who is currently viewing entities (ephemeral)
model EntityPresence {
  id         String   @id @default(cuid())
  entityType String   // 'deal', 'quote', 'lead', etc.
  entityId   String   // ID of the entity being viewed
  userId     String   // User viewing
  userName   String   // User's name
  userEmail  String?  // User's email
  avatarUrl  String?  // User's avatar for display
  socketId   String   // WebSocket connection ID
  lastSeenAt DateTime @default(now()) // For cleanup of stale entries

  @@unique([entityType, entityId, userId])
  @@index([entityType, entityId])
  @@index([lastSeenAt])
  @@map("entity_presence")
}

// ============================================================================
// REVENUE SPLITS - Multi-rep credit allocation on deals
// ============================================================================

enum SplitType {
  REVENUE   // Standard revenue split
  OVERLAY   // Overlay rep (solutions engineer, specialist)
  QUOTA     // Counts toward quota only
  REFERRAL  // Referral credit
  MANAGEMENT // Management override
}

enum SplitStatus {
  PENDING   // Awaiting approval
  APPROVED  // Approved by manager
  REJECTED  // Rejected
  LOCKED    // Deal closed, split locked
}

model OpportunitySplit {
  id             String      @id @default(cuid())
  opportunityId  String
  organizationId String?
  userId         String      // Rep receiving credit
  splitType      SplitType   @default(REVENUE)
  splitPercent   Float       // 0-100
  splitAmount    Float?      // Cached: opportunity.amount * percent / 100
  includeInQuota Boolean     @default(true)
  includeInForecast Boolean  @default(true)
  status         SplitStatus @default(PENDING)
  approvedById   String?
  approvedAt     DateTime?
  notes          String?
  createdAt      DateTime    @default(now())
  updatedAt      DateTime    @updatedAt

  opportunity    Opportunity @relation(fields: [opportunityId], references: [id], onDelete: Cascade)
  user           User        @relation("SplitUser", fields: [userId], references: [id])
  approvedBy     User?       @relation("SplitApprover", fields: [approvedById], references: [id])

  @@unique([opportunityId, userId, splitType])
  @@index([opportunityId])
  @@index([userId])
  @@index([organizationId])
  @@map("opportunity_splits")
}

// ============================================================================
// COMPETITOR INTELLIGENCE - Battlecards and win/loss analysis
// ============================================================================

enum CompetitorTier {
  PRIMARY     // Main competitors
  SECONDARY   // Occasional competitors
  EMERGING    // Up-and-coming threats
  INDIRECT    // Different solution, same budget
}

enum CompetitorStatus {
  ACTIVE
  INACTIVE
  ACQUIRED
  MERGED
}

enum ThreatLevel {
  LOW
  MEDIUM
  HIGH
  CRITICAL
}

model Competitor {
  id              String           @id @default(cuid())
  organizationId  String?
  name            String
  website         String?
  logoUrl         String?
  description     String?
  tier            CompetitorTier   @default(SECONDARY)
  status          CompetitorStatus @default(ACTIVE)
  strengths       String[]
  weaknesses      String[]
  differentiators String[]
  targetMarket    String?
  pricingModel    String?
  winsAgainst     Int              @default(0)
  lossesAgainst   Int              @default(0)
  winRateAgainst  Float?           // Calculated: wins / (wins + losses)

  // AI-generated cache fields
  aiWinLossAnalysis    Json?       // Cached win/loss pattern analysis
  aiWinLossGeneratedAt DateTime?   // When the analysis was generated

  createdAt       DateTime         @default(now())
  updatedAt       DateTime         @updatedAt

  products          CompetitorProduct[]
  battlecards       Battlecard[]
  opportunityLinks  OpportunityCompetitor[]

  organization Organization? @relation("OrganizationCompetitors", fields: [organizationId], references: [id], onDelete: SetNull)

  @@unique([organizationId, name])
  @@index([organizationId])
  @@index([tier])
  @@index([status])
  @@map("competitors")
}

model CompetitorProduct {
  id                    String   @id @default(cuid())
  competitorId          String
  name                  String
  comparableToProductId String?  // Our product this competes with
  featureGaps           String[] // Features they lack vs us
  featureAdvantages     String[] // Features they have over us
  positioning           String?
  pricingInfo           String?
  createdAt             DateTime @default(now())
  updatedAt             DateTime @updatedAt

  competitor            Competitor @relation(fields: [competitorId], references: [id], onDelete: Cascade)
  comparableToProduct   Product?   @relation("ComparableProduct", fields: [comparableToProductId], references: [id])

  @@index([competitorId])
  @@map("competitor_products")
}

model Battlecard {
  id                 String   @id @default(cuid())
  competitorId       String
  title              String
  overview           String?
  keyTalkingPoints   String[]
  objectionHandling  Json?    // { objection: string, response: string }[]
  trapQuestions      String[] // Questions to ask that highlight competitor weaknesses
  winThemes          String[]
  loseThemes         String[]
  differentiators    String[] // Key differentiators to emphasize
  pricingComparison  String?
  isActive           Boolean  @default(true)
  isAiGenerated      Boolean  @default(false) // Whether this was AI-generated
  version            Int      @default(1)
  createdAt          DateTime @default(now())
  updatedAt          DateTime @updatedAt

  competitor         Competitor @relation(fields: [competitorId], references: [id], onDelete: Cascade)

  @@index([competitorId])
  @@index([isActive])
  @@index([isAiGenerated])
  @@map("battlecards")
}

model OpportunityCompetitor {
  id                  String      @id @default(cuid())
  opportunityId       String
  competitorId        String
  isPrimary           Boolean     @default(false) // Primary competitor on deal
  threatLevel         ThreatLevel @default(MEDIUM)
  notes               String?
  wasCompetitorWinner Boolean?    // Set on close-lost if this competitor won
  lossReasons         String[]
  createdAt           DateTime    @default(now())
  updatedAt           DateTime    @updatedAt

  opportunity         Opportunity @relation(fields: [opportunityId], references: [id], onDelete: Cascade)
  competitor          Competitor  @relation(fields: [competitorId], references: [id], onDelete: Cascade)

  @@unique([opportunityId, competitorId])
  @@index([opportunityId])
  @@index([competitorId])
  @@map("opportunity_competitors")
}

// ============================================================================
// ASSET/INSTALLED BASE - Customer-owned product tracking
// ============================================================================

enum AssetStatus {
  ACTIVE
  INACTIVE
  EXPIRED
  PENDING      // Pending installation/activation
  RETURNED
  UNDER_REPAIR
}

enum SupportContractType {
  STANDARD
  PREMIUM
  ENTERPRISE
  CUSTOM
}

model Asset {
  id                String      @id @default(cuid())
  accountId         String
  organizationId    String?
  productId         String?
  name              String
  serialNumber      String?     @unique
  status            AssetStatus @default(ACTIVE)
  quantity          Int         @default(1)
  purchaseDate      DateTime?
  installDate       DateTime?
  warrantyStartDate DateTime?
  warrantyEndDate   DateTime?
  renewalDate       DateTime?
  renewalValue      Float?
  licenseKey        String?
  seatCount         Int?
  seatsUsed         Int?
  version           String?
  configuration     Json?
  supportContractId String?
  notes             String?
  metadata          Json?
  createdAt         DateTime    @default(now())
  updatedAt         DateTime    @updatedAt

  account           Account           @relation(fields: [accountId], references: [id], onDelete: Cascade)
  product           Product?          @relation("AssetProduct", fields: [productId], references: [id])
  supportContract   SupportContract?  @relation(fields: [supportContractId], references: [id])

  organization Organization? @relation("OrganizationAssets", fields: [organizationId], references: [id], onDelete: SetNull)

  @@index([accountId])
  @@index([productId])
  @@index([renewalDate])
  @@index([warrantyEndDate])
  @@index([organizationId])
  @@index([status])
  @@map("assets")
}

model SupportContract {
  id             String              @id @default(cuid())
  accountId      String
  organizationId String?
  contractNumber String              @unique
  name           String
  type           SupportContractType @default(STANDARD)
  startDate      DateTime
  endDate        DateTime
  contractValue  Float
  annualValue    Float?
  slaLevel       String?             // e.g., "Gold", "Platinum", "24x7"
  responseTime   Int?                // SLA response time in hours
  autoRenew      Boolean             @default(false)
  renewalNotice  Int?                // Days notice required for non-renewal
  status         ContractStatus      @default(ACTIVATED)
  notes          String?
  metadata       Json?
  createdAt      DateTime            @default(now())
  updatedAt      DateTime            @updatedAt

  coveredAssets  Asset[]
  account        Account             @relation(fields: [accountId], references: [id], onDelete: Cascade)

  organization Organization? @relation("OrganizationSupportContracts", fields: [organizationId], references: [id], onDelete: SetNull)

  @@index([accountId])
  @@index([endDate])
  @@index([organizationId])
  @@index([status])
  @@map("support_contracts")
}

// ============================================================================
// PARTNER RELATIONSHIP MANAGEMENT (PRM) - Partner Portal
// ============================================================================

enum PartnerStatus {
  PROSPECT     // Interested but not yet onboarded
  PENDING      // Application submitted, under review
  APPROVED     // Active partner
  SUSPENDED    // Temporarily suspended
  TERMINATED   // Partnership ended
}

enum PartnerTier {
  REGISTERED   // Basic tier
  SILVER
  GOLD
  PLATINUM
}

enum PartnerType {
  RESELLER          // Sells our products
  REFERRAL          // Refers leads for commission
  TECHNOLOGY        // Technology integration partner
  SYSTEM_INTEGRATOR // Implementation/services partner
  OEM               // OEM/white-label partner
  AFFILIATE         // Affiliate marketing partner
}

enum DealRegistrationStatus {
  DRAFT         // Partner started but not submitted
  PENDING       // Submitted, awaiting review
  UNDER_REVIEW  // Being reviewed by partner manager
  APPROVED      // Approved, protection active
  REJECTED      // Rejected (duplicate, unqualified, etc.)
  EXPIRED       // Approval period expired
  CONVERTED     // Converted to opportunity
  WON           // Deal closed-won
  LOST          // Deal closed-lost
}

enum PartnerUserRole {
  ADMIN    // Partner admin - full access
  MANAGER  // Can manage deals and users
  MEMBER   // Standard partner user
  VIEWER   // Read-only access
}

model Partner {
  id               String        @id @default(cuid())
  organizationId   String?
  companyName      String
  website          String?
  logoUrl          String?
  type             PartnerType   @default(RESELLER)
  tier             PartnerTier   @default(REGISTERED)
  status           PartnerStatus @default(PROSPECT)
  commissionRate   Float?        // Default commission percentage
  discountRate     Float?        // Default discount from list price
  portalEnabled    Boolean       @default(false)
  totalRevenue     Float         @default(0)
  totalDeals       Int           @default(0)
  totalRegistrations Int         @default(0)
  partnerManagerId String?       // Internal partner manager
  contractStartDate DateTime?
  contractEndDate   DateTime?
  territory        String?
  industry         String[]
  certifications   String[]
  notes            String?
  metadata         Json?
  createdAt        DateTime      @default(now())
  updatedAt        DateTime      @updatedAt

  accounts          PartnerAccount[]
  dealRegistrations DealRegistration[]
  users             PartnerUser[]
  partnerManager    User?              @relation("PartnerManager", fields: [partnerManagerId], references: [id])

  organization Organization? @relation("OrganizationPartners", fields: [organizationId], references: [id], onDelete: SetNull)

  @@unique([organizationId, companyName])
  @@index([organizationId])
  @@index([status])
  @@index([tier])
  @@index([type])
  @@index([partnerManagerId])
  @@map("partners")
}

model PartnerUser {
  id         String          @id @default(cuid())
  partnerId  String
  userId     String
  role       PartnerUserRole @default(MEMBER)
  isPrimary  Boolean         @default(false)
  isActive   Boolean         @default(true)
  invitedAt  DateTime        @default(now())
  acceptedAt DateTime?
  createdAt  DateTime        @default(now())
  updatedAt  DateTime        @updatedAt

  partner    Partner         @relation(fields: [partnerId], references: [id], onDelete: Cascade)
  user       User            @relation("PartnerUsers", fields: [userId], references: [id], onDelete: Cascade)

  @@unique([partnerId, userId])
  @@index([partnerId])
  @@index([userId])
  @@map("partner_users")
}

model PartnerAccount {
  id          String   @id @default(cuid())
  partnerId   String
  accountId   String
  isExclusive Boolean  @default(false) // Exclusive partner for this account
  assignedAt  DateTime @default(now())
  expiresAt   DateTime?
  notes       String?
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt

  partner     Partner  @relation(fields: [partnerId], references: [id], onDelete: Cascade)
  account     Account  @relation(fields: [accountId], references: [id], onDelete: Cascade)

  @@unique([partnerId, accountId])
  @@index([partnerId])
  @@index([accountId])
  @@map("partner_accounts")
}

model DealRegistration {
  id                 String                 @id @default(cuid())
  partnerId          String
  organizationId     String?
  registrationNumber String                 @unique @default(cuid())

  // Lead/Account info (may not exist in system yet)
  accountName        String
  accountId          String?                // Link to existing account if found
  contactName        String
  contactEmail       String
  contactPhone       String?
  contactTitle       String?

  // Deal details
  estimatedValue     Float?
  estimatedCloseDate DateTime?
  productInterest    String[]
  useCase            String?
  competitorInfo     String?

  // Status workflow
  status             DealRegistrationStatus @default(PENDING)
  approvedAt         DateTime?
  approvedById       String?
  approvedUntil      DateTime?              // Protection expiration
  rejectedAt         DateTime?
  rejectedById       String?
  rejectionReason    String?

  // Commission
  commissionRate     Float?                 // Override partner default
  estimatedCommission Float?

  // Conversion
  opportunityId      String?                @unique
  convertedAt        DateTime?
  convertedById      String?

  notes              String?
  metadata           Json?
  createdAt          DateTime               @default(now())
  updatedAt          DateTime               @updatedAt

  partner            Partner                @relation(fields: [partnerId], references: [id], onDelete: Cascade)
  opportunity        Opportunity?           @relation(fields: [opportunityId], references: [id])
  account            Account?               @relation(fields: [accountId], references: [id])
  approvedBy         User?                  @relation("DealRegApprover", fields: [approvedById], references: [id])
  rejectedBy         User?                  @relation("DealRegRejecter", fields: [rejectedById], references: [id])
  convertedBy        User?                  @relation("DealRegConverter", fields: [convertedById], references: [id])

  organization Organization? @relation("OrganizationDealRegistrations", fields: [organizationId], references: [id], onDelete: SetNull)

  @@index([partnerId])
  @@index([status])
  @@index([organizationId])
  @@index([accountId])
  @@index([approvedUntil])
  @@map("deal_registrations")
}

// ==================== ACCESS REQUEST (LEAD QUALIFICATION) ====================

enum AccessRequestStatus {
  PENDING     // New request, not yet reviewed
  CONTACTED   // Sales has reached out
  QUALIFIED   // Qualified as a good fit
  APPROVED    // Approved, org code being sent
  REJECTED    // Not a fit / spam
  CONVERTED   // Converted to a lead/user
}

enum AccessRequestType {
  FREE_TRIAL  // Wants to try the product
  DEMO        // Wants a demo
  ENTERPRISE  // Enterprise inquiry
  PARTNER     // Partnership inquiry
  OTHER       // Other
}

// AccessRequest - Captures interest from users without org codes
// Flow: User submits form  Sales reviews  Sends org code  User signs up
model AccessRequest {
  id                String              @id @default(cuid())

  // Contact Information
  firstName         String
  lastName          String
  email             String
  phone             String?

  // Company Information
  companyName       String
  jobTitle          String?
  companySize       String?             // "1-10", "11-50", "51-200", etc.
  industry          String?
  website           String?

  // Request Details
  requestType       AccessRequestType   @default(FREE_TRIAL)
  interests         String[]            // ["CRM", "AI Coaching", "Analytics"]
  message           String?
  howHeard          String?             // "Google", "Referral", "LinkedIn", etc.

  // Status & Tracking
  status            AccessRequestStatus @default(PENDING)
  assignedToId      String?
  assignedTo        User?               @relation("AssignedAccessRequests", fields: [assignedToId], references: [id])

  // Conversion Tracking
  convertedLeadId   String?             @unique
  convertedLead     Lead?               @relation("AccessRequestLead", fields: [convertedLeadId], references: [id])
  organizationCodeSent String?          // The org code sent to this user

  // Metadata for tracking
  ipAddress         String?
  userAgent         String?
  utmSource         String?
  utmMedium         String?
  utmCampaign       String?

  // Admin Notes
  internalNotes     String?
  rejectionReason   String?

  // AI-Powered Insights & Enrichment
  aiScore           Int?                // 0-100 AI-calculated lead score
  aiPriority        String?             // HIGH, MEDIUM, LOW
  aiInsights        Json?               // Structured AI analysis
  aiCompanyInfo     Json?               // Enriched company data
  aiRecommendedActions String[]         // AI-suggested next steps
  aiSummary         String?             // AI-generated summary
  aiEnrichedAt      DateTime?           // When AI enrichment was performed

  // Timestamps
  createdAt         DateTime            @default(now())
  updatedAt         DateTime            @updatedAt
  contactedAt       DateTime?
  convertedAt       DateTime?

  @@index([status])
  @@index([email])
  @@index([createdAt])
  @@index([aiScore])
  @@index([aiPriority])
  @@map("access_requests")
}

// ==================== APPROVAL WORKFLOWS ====================
// Multi-level approval chains for quotes, orders, contracts, and discounts

enum ApprovalEntity {
  QUOTE
  DISCOUNT
  ORDER
  CONTRACT
}

enum ApproverType {
  USER          // Specific user must approve
  ROLE          // Anyone with specified role can approve
  MANAGER       // Submitter's direct manager
  SKIP_LEVEL_MANAGER  // Submitter's manager's manager
}

enum ApprovalStatus {
  PENDING
  APPROVED
  REJECTED
  CANCELLED
  EXPIRED
}

enum ApprovalAction {
  APPROVE
  REJECT
  DELEGATE
  ESCALATE
}

model ApprovalWorkflow {
  id           String          @id @default(cuid())
  name         String
  description  String?
  entity       ApprovalEntity
  conditions   Json            @default("[]") // WorkflowCondition[]
  isActive     Boolean         @default(true)
  priority     Int             @default(0) // Higher priority evaluated first
  
  // Relations
  steps        ApprovalStep[]
  requests     ApprovalRequest[]
  
  // Audit
  createdById  String
  createdBy    User            @relation("ApprovalWorkflowCreator", fields: [createdById], references: [id])
  
  // Multi-tenancy
  organizationId String
  organization   Organization @relation("OrganizationApprovalWorkflows", fields: [organizationId], references: [id], onDelete: Cascade)
  
  createdAt    DateTime        @default(now())
  updatedAt    DateTime        @updatedAt

  @@index([entity])
  @@index([isActive])
  @@index([organizationId])
  @@map("approval_workflows")
}

model ApprovalStep {
  id                    String        @id @default(cuid())
  workflowId            String
  workflow              ApprovalWorkflow @relation(fields: [workflowId], references: [id], onDelete: Cascade)
  
  order                 Int           // Step sequence (1, 2, 3...)
  name                  String
  description           String?
  
  // Approver configuration
  approverType          ApproverType
  approverId            String?       // User ID if type is USER
  approver              User?         @relation("ApprovalStepApprover", fields: [approverId], references: [id])
  roleId                String?       // Profile ID if type is ROLE
  
  // Automation
  autoApproveAfterHours Int?          // Auto-approve after N hours
  autoRejectAfterHours  Int?          // Auto-reject after N hours
  
  // Settings
  requireComment        Boolean       @default(false)
  allowDelegation       Boolean       @default(true)
  
  // Relations
  decisions             ApprovalDecision[]
  
  createdAt             DateTime      @default(now())
  updatedAt             DateTime      @updatedAt

  @@index([workflowId])
  @@index([order])
  @@map("approval_steps")
}

model ApprovalRequest {
  id                String          @id @default(cuid())
  workflowId        String
  workflow          ApprovalWorkflow @relation(fields: [workflowId], references: [id])
  
  // Entity being approved
  entityType        ApprovalEntity
  entityId          String
  entityName        String
  entityDetails     Json?           // Snapshot of entity at submission time
  
  // Requester
  requestedById     String
  requestedBy       User            @relation("ApprovalRequestor", fields: [requestedById], references: [id])
  
  // Progress
  currentStepOrder  Int             @default(1)
  status            ApprovalStatus  @default(PENDING)
  
  // Decisions
  decisions         ApprovalDecision[]
  
  // Timestamps
  submittedAt       DateTime        @default(now())
  completedAt       DateTime?
  expiresAt         DateTime?
  
  // Multi-tenancy
  organizationId    String
  organization      Organization    @relation("OrganizationApprovalRequests", fields: [organizationId], references: [id], onDelete: Cascade)
  
  createdAt         DateTime        @default(now())
  updatedAt         DateTime        @updatedAt

  @@index([workflowId])
  @@index([entityType, entityId])
  @@index([requestedById])
  @@index([status])
  @@index([organizationId])
  @@map("approval_requests")
}

model ApprovalDecision {
  id              String          @id @default(cuid())
  requestId       String
  request         ApprovalRequest @relation(fields: [requestId], references: [id], onDelete: Cascade)
  
  stepId          String
  step            ApprovalStep    @relation(fields: [stepId], references: [id])
  stepOrder       Int
  
  // Decision maker
  approverId      String
  approver        User            @relation("ApprovalDecisionApprover", fields: [approverId], references: [id])
  
  // Decision
  action          ApprovalAction
  comment         String?
  
  // Delegation
  delegatedToId   String?
  delegatedTo     User?           @relation("ApprovalDecisionDelegate", fields: [delegatedToId], references: [id])
  
  decidedAt       DateTime        @default(now())
  
  createdAt       DateTime        @default(now())

  @@index([requestId])
  @@index([stepId])
  @@index([approverId])
  @@map("approval_decisions")
}

// 
// Integration Data Persistence Models
// 

model IntegrationSyncLog {
  id             String   @id @default(cuid())
  organizationId String

  // What happened
  provider       String   // slack, hubspot, zapier, etc.
  eventType      String   // LEAD_CREATED, DEAL_WON, etc.
  entityType     String   // lead, contact, opportunity, etc.
  entityId       String   // CRM record ID

  // Result
  status         String   @default("pending") // pending, success, failed
  externalId     String?  // ID returned by external API (if applicable)
  responseData   Json?    // Truncated response for debugging
  errorMessage   String?
  durationMs     Int?     // How long the dispatch took

  createdAt      DateTime @default(now())

  organization   Organization @relation("OrganizationSyncLogs", fields: [organizationId], references: [id], onDelete: Cascade)

  @@index([organizationId])
  @@index([organizationId, provider])
  @@index([entityType, entityId])
  @@index([createdAt])
  @@index([status])
  @@map("integration_sync_logs")
}

model IntegrationEntityMapping {
  id             String   @id @default(cuid())
  organizationId String

  // SalesOS side
  entityType     String   // lead, contact, account, opportunity, order, quote
  entityId       String   // CRM record ID

  // External side
  provider       String   // hubspot, marketo, intercom, quickbooks, xero, etc.
  externalId     String   // ID in the external system
  externalUrl    String?  // Deep link to the record in the external system

  // Sync metadata
  lastSyncedAt   DateTime @default(now())
  syncDirection  String   @default("outbound") // outbound, inbound, bidirectional
  metadata       Json?    // Provider-specific metadata

  createdAt      DateTime @default(now())
  updatedAt      DateTime @updatedAt

  organization   Organization @relation("OrganizationEntityMappings", fields: [organizationId], references: [id], onDelete: Cascade)

  // One mapping per entity per provider
  @@unique([organizationId, entityType, entityId, provider])
  @@index([organizationId, provider])
  @@index([provider, externalId])
  @@index([entityType, entityId])
  @@map("integration_entity_mappings")
}

model IntegrationAttachment {
  id             String   @id @default(cuid())
  organizationId String

  // What entity this file belongs to
  entityType     String   // opportunity, quote, order, account, lead
  entityId       String   // CRM record ID

  // File info
  provider       String   // dropbox, gdrive, microsoft365
  externalId     String?  // File/folder ID in the provider
  fileName       String
  fileUrl        String?  // Share/access URL
  fileType       String?  // folder, document, spreadsheet, etc.
  fileSizeBytes  BigInt?

  // Context
  eventType      String?  // What CRM event triggered this (DEAL_WON, QUOTE_SENT, etc.)

  metadata       Json?
  createdAt      DateTime @default(now())

  organization   Organization @relation("OrganizationIntegrationAttachments", fields: [organizationId], references: [id], onDelete: Cascade)

  @@index([organizationId])
  @@index([entityType, entityId])
  @@index([provider])
  @@map("integration_attachments")
}
